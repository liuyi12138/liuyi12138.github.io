<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知君的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyi12138.github.io/"/>
  <updated>2021-02-23T06:34:31.925Z</updated>
  <id>https://liuyi12138.github.io/</id>
  
  <author>
    <name>知君</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>秋招面试经历整理</title>
    <link href="https://liuyi12138.github.io/2020/10/19/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/"/>
    <id>https://liuyi12138.github.io/2020/10/19/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/</id>
    <published>2020-10-19T07:09:16.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p><strong>秋招共持续了四个月，总共投了19家公司，有几家挂在了不同的阶段，最后拿到了8家的offer，这段时间里面了几十场面试，大多数面试的问题都懒得做记载了，在此只记录一下大概的问题走向、一些面试常见的问题以及一丢丢面试技巧供大家参考。</strong></p><a id="more"></a> <h2 id="秋招战况"><a href="#秋招战况" class="headerlink" title="秋招战况"></a>秋招战况</h2><h3 id="投递统计"><a href="#投递统计" class="headerlink" title="投递统计"></a>投递统计</h3><p><strong>统计了一下，秋招共向以下19个公司投递了简历，共拿了8个offer</strong></p><ul><li>一线大厂：字节、百度、腾讯、拼多多</li><li>准一线大厂：大疆、华为、快手、美团、图森未来、京东、猿辅导</li><li>二线小厂：TP-Link、招银科技、深信服、b站</li><li>国企：中电29所、国电南自、农行</li><li>外企：shopee(算半个外企吧)</li></ul><h3 id="面试情况"><a href="#面试情况" class="headerlink" title="面试情况"></a>面试情况</h3><h4 id="挂在简历筛选的公司"><a href="#挂在简历筛选的公司" class="headerlink" title="挂在简历筛选的公司"></a>挂在简历筛选的公司</h4><ul><li>只招与需求极度相符的人：b站、图森未来</li><li>要求没达到：农行(英语六级没过)</li><li>未知理由：京东(听说面试都挺迷的)</li></ul><h4 id="挂在机试的公司"><a href="#挂在机试的公司" class="headerlink" title="挂在机试的公司"></a>挂在机试的公司</h4><p><strong>机试一般有性格评测和笔试两部分，性格评测主要是性格测试题+阅读理解+小学奥数+找规律+图表题，大概30min完成。</strong></p><ul><li>性格评测挂了：拼多多(忘做了)、华为实习生(挂了被捞了)</li><li>笔试挂了：大疆(应该是和简历综合评判之后觉得不符合)</li></ul><h4 id="挂在面试的公司"><a href="#挂在面试的公司" class="headerlink" title="挂在面试的公司"></a>挂在面试的公司</h4><ul><li>实习生面试挂太多了：腾讯(之前实习生面试挂了三次，估计评分很低)</li><li>只招与需求极度相符的人：shopee(后端岗疯狂问用过哪些后端框架，不问基础和C++)</li><li>面试累了，鸽了面试：快手、猿辅导</li><li>自己拒了：中电29所(研究方向不符)</li></ul><h4 id="收割offer"><a href="#收割offer" class="headerlink" title="收割offer"></a>收割offer</h4><ul><li>TP-Link：6月就开始秋招提前批，公司有985情结，面试基本就聊天，很容易就过了，在北京工资不高，并且无加班费</li><li>字节：典型的挂了又捞，捞了有挂，经历了安全岗简历挂和一面挂，被广告部门捞起来，技术面三轮+hr面拿offer</li><li>深信服：机缘巧合投的大牛批，一面很水，二面是正常技术面，三面主管面很契合项目方向，拿了ssp</li><li>招银科技：调过电话面(摸底)，两轮技术面，问的东西都很浅，范围还比较广</li><li>国电南自：一面技术面，比较简单，三天发offer，本科生薪资低，还需要出差</li><li>百度：无人车部门两面挂，语音识别部门三轮技术面+一轮主管面，跟字节类似，主管画技术饼</li><li>华为(待安排)：实习生过了所以免笔试，一轮技术面+主管面，基本聊天，但offer下发周期长</li><li>美团点评(待安排)：三轮技术面不是很难，hr面后两个月不给结果，估计是hc少，池子深</li></ul><h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><p><strong>由于大部分公司都是投的提前批，所以很少有笔试，面试一般是2-5轮，摸底面+技术面+主管面+hr面，侧重点各不相同。</strong></p><h3 id="摸底面"><a href="#摸底面" class="headerlink" title="摸底面"></a>摸底面</h3><p>摸底面也就是很多公司的电话面，比如招银科技、国电南自，一般时间不会很长，大概在10-20分钟之间，主要是自我介绍+项目经历简介，有的会有一些常见的基础题，比如TCP为什么三次握手这种。只要有一定的准备，电话面基本都不会挂，有的公司如果你简历or笔试表现好会跳过这个环节。</p><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p>技术面是面试流程中的核心环节，主要考察我们对计算机基础知识的掌握程度，一般会涉及计网、操作系统/Linux、数据库，编程语言(c++/Java等)，部分会问到编译原理这种比较偏向计算机专业的问题。</p><p>一般公司的技术面为2-3轮，主要模式都大概相似，开始自我介绍，紧接着问一些基础知识相关的问题or项目相关的技术问题，最后是1-2道现场编程题，也有的公司会先上来让你写题，后续根据你的表现来决定问什么问题。</p><h3 id="主管面"><a href="#主管面" class="headerlink" title="主管面"></a>主管面</h3><p>并不是所有公司都有主管面，一般是部门直招or你前面面试表现较好，可能有sp的情况下才会有主管面试，一般主管的级别越高就说明你的评级越高。</p><p>主管面并不会拘泥于具体的技术问题，在你的自我介绍后，主管喜欢针对项目进行提问，主要是考察你对自己所做项目的掌握程度，并且很多时候会问到一些与人沟通相处相关的问题，比如如果组员之间出现了意见分歧你们会怎么办，另一方面，你印象最深的一次项目经历也是常问的问题，这些都是需要提前准备好的。</p><p>在主管面的时候我会更多的讲一些自己的学生工作，领导项目or组织活动的经历，当然这种经历最好是与技术挂钩的。以及与主管讨论编程规范，自动化测试、软件工程、测试驱动开发，或者项目管理等问题也是正中他们要害的，并且一定要多问，一般主管们很喜欢给新人讲这些，给他们机会，装作很感兴趣的样子。</p><h3 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h3><p>hr面一般就直接确认offer或者谈薪了，极少见到hr面还刷人的(听说京东和阿里会)，一般hr会问你一些基本的家庭和学习情况，以及你现在拿了哪些offer。</p><p>在hr面自己也可以问一问公司的一些情况，比如薪资结构，五险一金，加班情况，加班费计算，升职加薪的规章制度，年假安排等，这些都是需要提前了解并且纳入offer考虑范围的，不过薪资才是硬道理。</p><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><p><strong>实际上在实习生阶段已经整理了很多被问到的问题以及部分问题写了一下自己的解答(还有很大一部分坑没填呢)，秋招阶段感觉其实万变不离其宗，问来问去都是那么几个问题，所以就没做记录了。在此依据记忆在几个主要的方向写出几个最常见的问题吧。</strong></p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li>简述从输入网址到浏览器显示的过程</li><li>TCP为什么是三次握手四次挥手</li><li>TCP如何保障数据包有效</li><li>HTTPS和HTTP的区别</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>进程与线程的区别</li><li>堆与栈的区别</li><li>内核态和用户态的划分与切换</li><li>虚拟地址怎么映射到物理地址</li><li>简述IO多路复用</li><li>简述进程通信的各种方法</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>简述关系型数据库与菲关系形数据库的区别与联系</li><li>简述数据库的事务</li></ul><h3 id="编程语言-C"><a href="#编程语言-C" class="headerlink" title="编程语言(C++)"></a>编程语言(C++)</h3><ul><li>C++多态及其实现</li><li>C++11的新特性</li><li>右值引用</li><li>vector与list、map与unordered_map比较</li></ul><h3 id="面经总结"><a href="#面经总结" class="headerlink" title="面经总结"></a>面经总结</h3><ul><li><a href="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/">个人面经集合</a></li></ul><p>能看的大概也就下面几篇了：</p><ul><li><a href="https://liuyi12138.github.io/2020/08/19/%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/">实习生面试经历整理</a></li><li><a href="https://liuyi12138.github.io/2020/05/24/TCP%E8%AF%A6%E8%A7%A3/">TCP详解</a></li><li><a href="https://liuyi12138.github.io/2020/05/25/%E7%BD%91%E5%9D%80%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/">网址访问过程详解</a></li><li><a href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统问题整理</a></li><li><a href="https://liuyi12138.github.io/2020/06/24/C++%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">C++相关知识点梳理</a></li></ul><h3 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h3><ul><li>我感觉在技术面阶段实际上主要不在于你是不是都会，更好的实际上是你在某一两个问题上了解的特别详细，或者有项目经历，能跟面试官聊很久，这样在面试中就可以把面试官带到自己的点上，比如在面试官问网址访问过程的时候，我会讲的特别详细，并且把HTTPS和HTTP留在最后，通过HTTPS延伸到逆向工程中的一些密码学问题或者延伸到中间人攻击，这些常常会让面试官眼前一亮。</li><li>另外我感觉问面试官对自己的评价or自己哪些位置做的不好这种问题还是谨慎，如果自己表现得很完美就可以问问，不然面试官也不可能一直夸你，一般只会简单夸一下，然后绞尽脑汁想一想你有哪些位置做的不好，这就无形中提醒了他你的缺点。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;秋招共持续了四个月，总共投了19家公司，有几家挂在了不同的阶段，最后拿到了8家的offer，这段时间里面了几十场面试，大多数面试的问题都懒得做记载了，在此只记录一下大概的问题走向、一些面试常见的问题以及一丢丢面试技巧供大家参考。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>实习生面试经历整理</title>
    <link href="https://liuyi12138.github.io/2020/08/19/%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/"/>
    <id>https://liuyi12138.github.io/2020/08/19/%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/</id>
    <published>2020-08-19T13:48:16.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p><strong>收录一下实习生期间阿里云、腾讯、华为、快手、拼多多五个公司的面经，当时没有做太多准备，只拿到了华为的offer，但是对整个面试的流程以及可能涉及到的问题有了初步的了解，便于自己之后针对性学习。</strong></p><a id="more"></a> <h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>2020/4/1 上午，人才测评</li><li>2020/4/1 下午，笔试</li><li>2020/4/2 下午，一面</li></ul><h3 id="人才测评"><a href="#人才测评" class="headerlink" title="人才测评"></a>人才测评</h3><p><strong>这个人才测评的考题就比较奇葩了，与技术无关，目前也不知道有啥影响，考试形式为全是选择题，分为几个不同的部分，前三个部分每题会有限时，60s左右一提，最后一部分不限时，整个过程大概50min，实际上30min左右可完成</strong></p><ul><li>10题阅读理解，给一段话，选出其中心思想</li><li>10题图表信息提取，给一段话加一张表，提取需要的信息，需要使用计算器</li><li>10题找规律，可以参考小学做的那种找图形规律的题</li><li>98题人格测试，应该是用来测试人的性格吧</li></ul><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p><strong>阿里的笔试总共就两道题，每题50分，用的是牛客网，期间录屏+开摄像头+手机锁，基本杜绝作弊的可能（但录屏只能锁一块屏幕，拓展屏貌似不受影响）</strong></p><p><strong>听说无论笔试情况如何都能面试，这个暂时不收很清楚，反正我是一道也没写出来2333</strong></p><p>我凭借记忆记录一下笔试题，可能会有偏差</p><h4 id="T1、翻转序列"><a href="#T1、翻转序列" class="headerlink" title="T1、翻转序列"></a>T1、翻转序列</h4><p><strong>有一个只包含有0和1的序列，每次可以选择翻转一个数字，此时它两边的数字也会跟着翻转，如果选择翻转index为0或者string.size()-1的数字则只会影响到它旁边的一个数。需要将所有的数字都翻转为0，输出最少的翻转次数</strong></p><h5 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h5><p>我拿到这个题的想法就是每次遇到“11”序列则翻转，保证前面已经翻转的数字都为0，但无奈写完之后发现有“10101”这种序列， 查了好久才发现，最后没写出来。</p><h5 id="标准思路"><a href="#标准思路" class="headerlink" title="标准思路"></a>标准思路</h5><h6 id="解法一：贪心"><a href="#解法一：贪心" class="headerlink" title="解法一：贪心"></a>解法一：贪心</h6><ul><li>对数列进行遍历每次遇到0则从他的下一位开始翻转，这样就刚好影响到它本身</li><li>当对(0,string.size()-2)区间内的数字进行遍历完成后，如果最后一位为1则无法成功翻转，否则输出最少的翻转次数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="number">1</span>)&#123;</span><br><span class="line">        s[i] ^= <span class="number">1</span>;  <span class="comment">//翻转</span></span><br><span class="line">        s[i+<span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">2</span> &lt; s.size())    <span class="comment">//判断是否为倒数第二位</span></span><br><span class="line">            s[i+<span class="number">2</span>] ^= <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[s.size()<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><h6 id="解法二：滑动窗口"><a href="#解法二：滑动窗口" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h6><p><strong>可以考虑不做实际的翻转，只记录该位被翻转了多少次，而每一位是由周围2位影响的，所以需要维护一个队列来记录目前哪些位被翻转</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(), ++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty() &amp;&amp; q.front() + <span class="number">2</span> &lt;= i)</span><br><span class="line">        q.pop();    <span class="comment">//剔除已经无影响的翻转</span></span><br><span class="line">    <span class="keyword">if</span>(q.size() % <span class="number">2</span> != A[i])&#123;    <span class="comment">//判断是否需要翻转</span></span><br><span class="line">        count++;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.front() == s.size()<span class="number">-1</span>)&#123;    <span class="comment">//最后一位还需要翻转则无法成功翻转</span></span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/" target="_blank" rel="noopener">Leetcode T995 K 连续位的最小翻转次数</a></p><h4 id="T2、射箭打怪"><a href="#T2、射箭打怪" class="headerlink" title="T2、射箭打怪"></a>T2、射箭打怪</h4><p>这个题我只简单的看了一眼，无法保证完全正确<br><strong>输入m与n，表示一共有m只箭与n个怪，并会给出每一只怪的体力值，每一只箭的攻击力和价钱，输出杀死全部怪的最少花钱数</strong></p><h5 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h5><p>笔试的时候只是瞟了一眼，没有做，后来又想了一下，有一个大概的思路：用一个结构体存储箭，把箭按价钱排序，然后对每个怪遍历箭的list去寻找可以杀死它的箭并记录下价格，不确定题目是有放回还是无放回，对应的是用完的箭是否删除。不知道对不对，先写着，感觉如果还有面试应该会被问到。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>笔试第二天就安排了面试效率还是很高的，不像腾讯，都要一周了还没开始面</p><p><strong>面试主要分为知识点考察和现场编程两个环节，知识点考察是通过电话来进行的，貌似是阿里那边有一个电话转接的软件，感觉通话质量一般；现场编程是通过邮箱发过来的链接进入，面试官那边可以看到你这边写的代码。</strong><br>整个面试过程中知识点考察大概1h左右，现场编程30min吧，我这边由于网络原因所以中间花的时间比较多。</p><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><p><strong>面试官没有给自我介绍的时间，上来就直接问了项目，主要问题如下：</strong></p><h5 id="网安"><a href="#网安" class="headerlink" title="网安"></a>网安</h5><ul><li>简单介绍一下你们这个项目</li><li>你们项目中用到了DPDK你了解吗？</li><li>DPDK和一般的从网卡截取流量有什么不同？</li><li>你们项目中为什么要用深度学习，这个和网络安全有什么关系吗？</li><li>你在你们这个项目中有遇到什么难以去解决的问题吗？</li></ul><h5 id="启亦"><a href="#启亦" class="headerlink" title="启亦"></a>启亦</h5><ul><li>在启亦项目中用到实时计算(我说的这个实时计算跟你想的貌似不大一样啊)<ul><li>互联网中实时计算用到了哪些技术？(真不会了)</li></ul></li></ul><p><strong>面试官都问的网安项目，瞬间摸清了我啥都不会的事实</strong></p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>操作系统是如何进行进程切换的，请进程A切换到进程B是怎么样一个流程？<ul><li>操作系统是如何把进行从用户态切换到内存态？(软中断和硬中断)</li></ul></li><li>操作系统是在进行进程切换时的上下文切换是什么样的操作？<ul><li>一个进程在切换的时候会保存哪些资源？</li></ul></li><li>在Linux系统下怎么去创建一个新的进程？(fork)<ul><li>fork在复制的时候会拷贝原进程的数据嘛(copy-on-write)</li></ul></li><li>写过多线程代码吗？(开始尴尬)<ul><li>多线程主要会遇到什么问题？(资源抢夺-&gt;死锁)</li></ul></li><li>死锁有什么解决机制？</li><li>你了解一个进程在地址空间中会划分为什么区域吗？(往PE文件加载上去扯)<ul><li>你了解数据块中的堆内存和栈内存吗？</li><li>malloc分配的内存在哪？(自己挖坑)<ul><li>内存在堆里，变量存在堆里面，指向那块内存的指针在栈里面</li></ul></li></ul></li><li>你了解malloc是怎么管理内存的吗？(假装不知道，先埋伏他一手)<ul><li>怎么去处理内存碎片的问题？</li><li>这种处理方式有什么问题？</li></ul></li><li>你了解虚拟内存怎么映射到物理内存的吗？</li><li>你有过socket编程的经验吗？(再次没写过)<ul><li>怎么对并发请求进行处理？</li></ul></li><li>你有了解IO复用的概念吗？(这个确实忘了)</li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>你了解Linux系统的基本操作吗？<ul><li>不了解，此路不通</li></ul></li></ul><h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><ul><li>你了解静态链接和动态链接的区别吗？</li><li>简要叙述一下一个C语言程序编译生成机器码的过程</li><li>编译整个过程有哪些具体的阶段？</li><li>你了解词法分析语法分析吗</li></ul><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul><li>从输入网址到浏览器显示是怎样的一个过程<ul><li>DNS -&gt; ARP -&gt; HTTP -&gt; HTTPS(再埋伏一手，把对称加密和非对称加密简单描述一下)</li><li>DNS协议底层是用什么协议(原来是问的传输层，这波亏了)</li><li>请求DNS服务器的过程是怎样的？</li></ul></li><li>你了解Cookie吗？(开始扯自己的开发经历-&gt;MyBlog)</li><li>你了解HTTPS加密的整个过程？<ul><li>终于来了！从自己对dewdrop的分析开始引入对HTTPS的了解，夹带私货成功</li><li>为什么HTTPS不直接用非对称加密，而要先用非对称加密再用对称加密？</li><li>非对称加密的公钥存在哪，怎么去拿？(签名和证书分不清了23333)</li><li>你了解证书链的概念吗？(扯信任链，但实际上我不清楚)</li></ul></li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>数据库你用过什么数据库？(用的多的是MongoDB)<ul><li>对比MongoDB和MySQL(关系型数据库和非关系型数据库)</li><li>MySQL不使用外键，自己维护关系的情况下和MongoDB有什么区别？(我觉得貌似确实没区别啊)</li></ul></li><li>你了解数据库的索引吗？<ul><li>ObjectiveID就相当于主键</li><li>你了解给一个属性加索引吗？(我？？？)</li></ul></li><li>你了解数据库的事务吗？<ul><li>果断我没学过数据库，下一个</li></ul></li></ul><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><ul><li>React框架解决了什么问题？</li><li>Vue跟自己手写js有什么区别？</li><li>你了解过React Native框架吗？</li></ul><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><ul><li>你用过C++的智能指针吗？<ul><li>你了解智能指针的实现原理吗？</li></ul></li><li>你了解C++的多态是怎么实现的吗？</li></ul><h5 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h5><ul><li>你了解JAVA的GC机制吗？</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>你可以分享一下你最近看的一本技术书籍吗？<ul><li>话不多说《Metasploit渗透测试魔鬼训练营》，被评价接触范围广</li></ul></li><li>你对未来的规划是怎样的？是想直接工作还是读研？<ul><li>工作</li></ul></li><li>你有什么问题想问我？(标准结局)<ul><li>先扯一下对公司的各种问题</li><li>我想知道一下你对我这次面试的评价(这个就不写了)</li></ul></li></ul><h4 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h4><p><strong>写代码是用的阿里伯乐在线评测系统，代码不用编译，就在白板上手写，没有自动补全，面试完后会把你的代码给你发过来，还挺贴心</strong></p><ul><li>题目不是很难，感觉大多是考察代码规范以及思路</li><li>之前在LeetCode上写过，基本是原题，<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LeetCode T8 字符串转换整数(atoi)</a></li><li>这题我自己在大一暑假写过<a href="https://liuyi12138.github.io/2018/08/21/C++%E5%88%B7Leetcode%E7%AC%94%E8%AE%B0%E4%B9%8B%208.String%20to%20Integer%20(atoi">刷题笔记</a>/)</li><li>这次现场写的代码如下，自己面试后直接贴到LeetCode上去测过，直接AC了也是很奇妙</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">' '</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= s.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">exit</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="built_in">exit</span> = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">exit</span> &amp;&amp; s[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; <span class="string">'0'</span> || s[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            res *= <span class="number">10</span>;</span><br><span class="line">            res += (s[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(res &gt;= INT_MAX)</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            res = <span class="number">0</span> - res;</span><br><span class="line">            <span class="keyword">if</span>(res &lt;= INT_MIN)</span><br><span class="line">              <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= INT_MAX)</span><br><span class="line">          <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">int</span>(res);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="时间安排-1"><a href="#时间安排-1" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>2020/4/3 下午，后台开发一面</li><li>2020/4/3 晚上，后台开发二面</li><li>2020/4/14 上午，数据分析一面</li><li>2020/4/26 晚上，正式批笔试</li><li>2020/5/18 下午，正式批一面</li></ul><h3 id="后台开发一面"><a href="#后台开发一面" class="headerlink" title="后台开发一面"></a>后台开发一面</h3><p><strong>腾讯的一面很简单干脆，使用的是牛客网的在线面试功能，首先面试官给了我6道题，限时50min，没有屏幕共享，所以可以上网搜索搜索2333，不过我还是自己写的；写完题后简单讨论了一下思路，然后问了操作系统，计算机网络的一些基础知识，项目经历说的很多。</strong></p><p>由于忘了录音，就简单记录一下我记得的部分。</p><h4 id="项目经历-1"><a href="#项目经历-1" class="headerlink" title="项目经历"></a>项目经历</h4><ul><li>简要介绍你们的项目(网安)</li><li>你们这个项目中为什么要用到逆向分析？</li></ul><h4 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>虚拟地址如何映射到物理地址？</li><li>你了解IO复用吗？</li><li>有没有写过并发程序？</li></ul><h4 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h4><ul><li>你了解select和epoch的区别吗？</li></ul><h4 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul><li>你了解HTTPS的连接过程吗？</li></ul><h4 id="编程语言-C"><a href="#编程语言-C" class="headerlink" title="编程语言(C++)"></a>编程语言(C++)</h4><ul><li>你了解C++的多态是怎么实现的吗？</li><li>你知道C++中为什么要extern C吗？</li></ul><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>你有什么问题想问我？(标准结局)<ul><li>问一下公司的加班情况以及技术氛围</li><li>我想知道一下你对我这次面试的评价(不评价，会推给下一个面试官)</li></ul></li></ul><h4 id="题目部分"><a href="#题目部分" class="headerlink" title="题目部分"></a>题目部分</h4><h5 id="1、找出其中不含有重复字符的最长连续子串的长度"><a href="#1、找出其中不含有重复字符的最长连续子串的长度" class="headerlink" title="1、找出其中不含有重复字符的最长连续子串的长度"></a>1、找出其中不含有重复字符的最长连续子串的长度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; mMap;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; s.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(mMap[s[fast]])&#123;</span><br><span class="line">            mMap[s[slow]] = <span class="literal">false</span>;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast - slow &gt; maxLen)</span><br><span class="line">                maxLen = fast - slow;</span><br><span class="line">            mMap[s[fast]] = <span class="literal">true</span>;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h5 id="2、有一个字符串列表，从中找出按字典序最大和最小的串。"><a href="#2、有一个字符串列表，从中找出按字典序最大和最小的串。" class="headerlink" title="2、有一个字符串列表，从中找出按字典序最大和最小的串。"></a>2、有一个字符串列表，从中找出按字典序最大和最小的串。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strlist, <span class="built_in">string</span>&amp; strmin, <span class="built_in">string</span>&amp; strmax)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strlist.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    strmin = strlist[<span class="number">0</span>];</span><br><span class="line">    strmax = strlist[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strlist.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strlist[i] &lt; strmin)</span><br><span class="line">            strmin = strlist[i];</span><br><span class="line">        <span class="keyword">if</span>(strlist[i] &gt; strmax)</span><br><span class="line">            strmax = strlist[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、从有序链表中去除重复的元素"><a href="#3、从有序链表中去除重复的元素" class="headerlink" title="3、从有序链表中去除重复的元素"></a>3、从有序链表中去除重复的元素</h5><ul><li>(1, 1, 3, 3, 3, 5, 5, 5, 9, 9, 9, 9) -&gt; (1, 3, 5, 9)</li><li>这个题没有看到有序。。。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">( LinkNode * head )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; mMap;</span><br><span class="line">    <span class="keyword">while</span>(head &amp;&amp; head-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mMap[head-&gt;next-&gt;val])&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">temp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">            head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mMap[head-&gt;next-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、有一个二叉树，每个节点的值是一个整数。写一个函数，判断这颗树中是否存在从根到叶子节点的一个路径，这个路径上所有节点之和为某一个值。存在返回1，否则返回0。"><a href="#4、有一个二叉树，每个节点的值是一个整数。写一个函数，判断这颗树中是否存在从根到叶子节点的一个路径，这个路径上所有节点之和为某一个值。存在返回1，否则返回0。" class="headerlink" title="4、有一个二叉树，每个节点的值是一个整数。写一个函数，判断这颗树中是否存在从根到叶子节点的一个路径，这个路径上所有节点之和为某一个值。存在返回1，否则返回0。"></a>4、有一个二叉树，每个节点的值是一个整数。写一个函数，判断这颗树中是否存在从根到叶子节点的一个路径，这个路径上所有节点之和为某一个值。存在返回1，否则返回0。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>, * <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">haspath</span><span class="params">(struct TreeNode * root, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> (value == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(haspath(root-&gt;left, (value - root-&gt;value)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(haspath(root-&gt;right, (value - root-&gt;value)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、算一下从1到N中，“1”-在每个数出现的次数之和"><a href="#5、算一下从1到N中，“1”-在每个数出现的次数之和" class="headerlink" title="5、算一下从1到N中，“1” 在每个数出现的次数之和"></a>5、算一下从1到N中，“1” 在每个数出现的次数之和</h5><ul><li>这题当时没有想出一个很好的想法</li><li>参考<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">Leetcode 面试题43. 1～n整数中1出现的次数</a></li></ul><h5 id="6、-逻辑题-费南德的金币游戏："><a href="#6、-逻辑题-费南德的金币游戏：" class="headerlink" title="6、(逻辑题)费南德的金币游戏："></a>6、(逻辑题)费南德的金币游戏：</h5><ul><li>费南德和你抢到20个银币和一个金币；</li><li>你们的分赃规则：<ul><li>a. 俩人轮流拿，每次至少拿一个最多不能超过四个(可以等于四个);</li><li>b. 金币和银币不能混合拿，金币最后拿;</li></ul></li><li>如果由你先拿，怎么才可以拿到那个金币？</li></ul><p><strong>我的思路是要让对方拿到第20个银币，就得自己先拿到第19个银币，两个人轮流拿，可以控制周期为5，控制每轮两个人拿的银币数目为5个，因此19-&gt;14-&gt;9-&gt;4，所以最开始需要拿4个银币。</strong></p><h3 id="后台开发二面"><a href="#后台开发二面" class="headerlink" title="后台开发二面"></a>后台开发二面</h3><p>u1s1，这二面来得太快了，tx效率….</p><p><strong>二面是项目面，上来让我介绍项目，balabala把自己的自我介绍念了一遍，感觉还ok。然后整个过程面试官就问了一个问题，你在项目中遇到了哪些难点，是怎么解决的？</strong></p><p>像以前一样把逆向讲了一遍，ok，fine他不懂，Wannacry也不知道，然后问我其他项目还有没有，但我还没开始编。。。然后就扯了一下计网课设，然后就到标准结局了，他表示如果过了还有一个技术面，具体方向不告诉我。。。感觉应该是tx难点</p><p><strong>所以，大家一定要先编好故事.jpg         ——来自半小时结束二面的教训</strong></p><h3 id="数据分析一面"><a href="#数据分析一面" class="headerlink" title="数据分析一面"></a>数据分析一面</h3><p><strong>之前的后台开发二面凉了，后来又被腾讯云捞到了技术分析岗，一面面试官迟到一小时，非技术面，很迷。</strong></p><p>大致面试流程和提问如下：</p><ul><li>个人介绍(项目介绍)</li><li>你在整个大学生活中项目、学习、生活的占比是怎么样的？</li><li>你自己的职业规划是怎么样的？</li><li>你对在公司的工作环境有没有什么要求？</li><li>你接触过哪些编程语言，可以举出最熟悉的两门语言吗？</li><li>有没有接触过什么开源项目？</li><li>你在学校的加权成绩怎么样？</li><li>你个人觉得自己的闪光点有哪些？</li><li>能举例证明自己的学习能力很强吗？</li><li>你对我还有什么问题吗(标准结局)？<ul><li>问对方部门的情况</li><li>问对方对自己的评价</li></ul></li></ul><h3 id="正式批笔试"><a href="#正式批笔试" class="headerlink" title="正式批笔试"></a>正式批笔试</h3><p><strong>不得不说，腾讯的笔试是最近几个公司里面最像笔试的，其他的都整的像ACM笔试一样，一共五道题，AC了3.6道，感觉还okk</strong></p><h4 id="T1-模拟队列"><a href="#T1-模拟队列" class="headerlink" title="T1 模拟队列"></a>T1 模拟队列</h4><p>有一说一，C++有队列哦，所以对输入的字符串进行处理，然后调用队列就好了，基本上签到题。</p><h4 id="T2-求点集的最短距离"><a href="#T2-求点集的最短距离" class="headerlink" title="T2 求点集的最短距离"></a>T2 求点集的最短距离</h4><p><strong>题目如下</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200426220235.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>感觉自己只会暴力，dalao说的方法都听不懂hhhhh</li></ul><h4 id="T3-翻牌游戏"><a href="#T3-翻牌游戏" class="headerlink" title="T3 翻牌游戏"></a>T3 翻牌游戏</h4><p><strong>看到题目就不明觉厉，所以一直都没写，有人说用dfs，咱也不知道，先放着，有时间来填坑</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200426221441.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="T4-用两个栈实现队列"><a href="#T4-用两个栈实现队列" class="headerlink" title="T4 用两个栈实现队列"></a>T4 用两个栈实现队列</h4><p><strong>比较经典的一道题，不知道有没有设置时间复杂度，代码可以写得很优雅。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"add"</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(now == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.empty())&#123;</span><br><span class="line">                    s1.push(s2.top());</span><br><span class="line">                    s2.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s1.push(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">"peek"</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">                    s2.push(s1.top());</span><br><span class="line">                    s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                now = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s2.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">"poll"</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">                    s2.push(s1.top());</span><br><span class="line">                    s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                now = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="T5-一道数学题"><a href="#T5-一道数学题" class="headerlink" title="T5 一道数学题"></a>T5 一道数学题</h4><ul><li>实际上求个log确定层数，然后移位就好了</li><li>需要注意的是大数问题，用long long即可</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200426221411.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,k,t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; k;</span><br><span class="line">        t = <span class="built_in">log</span>(x) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; k)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(x/<span class="built_in">pow</span>(<span class="number">2</span>, t-k+<span class="number">1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正式批一面"><a href="#正式批一面" class="headerlink" title="正式批一面"></a>正式批一面</h3><p><strong>直接被锤爆，根本没问项目，直接从网络安全，计网，操作系统，C++，数据库，分布式，数据结构等方面把我锤了，锤得稀巴烂，近期不投不面了，有阴影。</strong></p><p>感觉准备不充分，太久没面技术面了，自我技术都说的磕磕碰碰，他也不咋问项目，直接开捶我。</p><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><ul><li>你了解Web安全吗，能说一下相关的攻击方式及防御机制吗？</li><li>你能简单说一下DDos攻击吗？</li><li>你了解对称加密吗，能说一下你知道的对称加密算法吗（这里还提到了某个hash算法，没听说过）？</li></ul><h4 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h4><ul><li>你知道tcp包里的校验和有什么用？是怎么实现的？</li><li>你知道tcp为什么要三次握手，而不是两次？</li><li>你知道tcp过程中有哪保障数据包数据有效的操作？</li></ul><h4 id="操作系统-2"><a href="#操作系统-2" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>你知道哪些进线程通信的方法？</li><li>你知道哪些高性能IO的方法？</li></ul><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul><li>你知道C++11有哪些新特性吗？</li><li>你知道右值引用解决了什么问题吗？</li></ul><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><ul><li>你平时用过哪些数据库？</li><li>你知道mongodb的高并发数据啥啥啥是怎么实现的吗？</li></ul><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ul><li>你有接触过哪些组件吗（举的例子完全不知道）？</li><li>你有接触过哪些分布式的架构？</li><li>你知道微服务吗？</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>你了解红黑树吗？B树B+树呢？</li></ul><p>最后灵魂发问，你哪个学院的，没学过这些吗？<br>对不起了大家，给种子班丢脸了，要好好复习基础了。</p><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><h3 id="时间安排-2"><a href="#时间安排-2" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>2020/4/22 晚上 笔试</li><li>2020/4/23 晚上 性格评测</li><li>2020/5/14 下午 技术面</li><li>2020/5/15 上午 部门主管面</li></ul><h3 id="笔试-1"><a href="#笔试-1" class="headerlink" title="笔试"></a>笔试</h3><p><strong>华为的笔试总共2h，三道题，第一道是签到题，后两道都有一定难度(其实并不)，和阿里一样是用的牛客的平台，没有截屏，就凭记忆简单记录一下</strong></p><h4 id="T1、输出数字字符"><a href="#T1、输出数字字符" class="headerlink" title="T1、输出数字字符"></a>T1、输出数字字符</h4><p><strong>给定一个随机的字符串，从小到大输出其中的数字字符，不考虑小数点和负数。</strong></p><ul><li><p>有一说一，这个题叙述的就有问题，我一想怎么可能是只输出字符，那也太简单了，只要维护一个长度为10的数组不就好了？然后果断理解为把连续的数字字符识别为同一个数字。</p></li><li><p>大概15-20min写完发现一直过不了，调了半天bug，最后还是改成了那个简单的理解，就过了。这道题基本就是签到题了，在这坑了半小时是真的难受。</p></li></ul><h4 id="T2、解析字符串"><a href="#T2、解析字符串" class="headerlink" title="T2、解析字符串"></a>T2、解析字符串</h4><p><strong>给定一系列的报文字符串，都是16进制数，每一段报文以0x5a开头与结尾，报文中如果有0x5a就转译为0x5b 0xba，报文中如果有0x5b就转译为0x5b 0xbb，每一段报文的结尾前一个字节是报文长度，报文与报文衔接处只有一个0x5a，给定一段报文，提取其中的正确的报文段进行输出</strong></p><p>这个题除了麻烦真的没啥亮点，于是乎我写了下面一版代码，但只通过了81%的case，也不知道为啥。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; apos;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bapos;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bbpos;</span><br><span class="line">    <span class="keyword">int</span> now, i, j, k;</span><br><span class="line">    <span class="keyword">int</span> cou = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; hex &gt;&gt; now)&#123;</span><br><span class="line">        nums.push_back(now);</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0x5a</span>)&#123;</span><br><span class="line">            apos.push_back(cou);</span><br><span class="line">        &#125;</span><br><span class="line">        cou++;</span><br><span class="line">        <span class="keyword">if</span>(getchar() == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0x5b</span> &amp;&amp; nums[i+<span class="number">1</span>] == <span class="number">0xbb</span>)&#123;</span><br><span class="line">            bbpos.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0x5b</span> &amp;&amp; nums[i+<span class="number">1</span>] == <span class="number">0xba</span>)&#123;</span><br><span class="line">            bapos.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> unlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; apos.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; bapos.size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bapos[j] &gt; apos[start] &amp;&amp; bapos[j] &lt;= apos[i])</span><br><span class="line">                unlen += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; bbpos.size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bbpos[j] &gt; apos[start] &amp;&amp; bbpos[j] &lt;= apos[i])</span><br><span class="line">                unlen += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(apos[i] - apos[start] == unlen + nums[apos[i]<span class="number">-1</span>] + <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(k = apos[start]; k &lt; apos[i]; ++k)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; nums[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start = i;</span><br><span class="line">        unlen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; <span class="number">0x5a</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//5a 12 5b ba 34 5b bb 88 05 5a 75 cd bb 62 5a 34 cd 78 cc da fb 06 5a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3、数组划分"><a href="#T3、数组划分" class="headerlink" title="T3、数组划分"></a>T3、数组划分</h4><p><strong>给定一段长度为m的数组，需要把它划分为k段，每段的和为S(n)，要使得所有的子数组中的S(n)的最大值最小，如果有多种划分方法，应该使S(1)尽量大，依次类推到S(2)、S(3)…</strong></p><p>我拿到这个题的第一想法就是算出其平均值，然后每次划分出最接近其平均值的一个数组，然后再计算平均值，继续划分。这个方法通过了80%的case。</p><p>因为是先做的T3，所以发现无法全部通过就去做T2了，也无法全部通过，直到最后30s发现了T3我的算法的问题在于可能会出现最终划分出的子数组小于k的情况，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = 9, k = 9;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">需要划分为9段，显然答案是</span><br><span class="line">1 / 2 / 3 / 4 / 5 / 6 / 7 / 8 / 9</span><br><span class="line">但我的算法会先算出每一段的均值大概是6.1</span><br><span class="line">所以会划分出</span><br><span class="line">1 2 3 / 4 / 5 / 6 / 7 / 8 / 9</span><br></pre></td></tr></table></figure></p><ul><li>在网上找到最大值最小化问题的思路，此题是最小值最大化，理论上应该是等价的，都是要求把数组均分，细微操作上有些许不同。</li><li><a href="https://blog.csdn.net/sinat_28310329/article/details/49679211?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3" target="_blank" rel="noopener">二分法解决最大值最小化问题</a></li><li>二分法解决最大值最小的问题或者最小值最大的问题思路都是相同的，即无论是最大值最小化还是最小值最大化，其结果的范围都在[数组最大值，数组和]这个范围内，并且以这个为界限一侧可以划分，另一侧无法划分，因此可以使用二分法来拟合。</li><li>其实现上区别在于求最大值最小化的时候，当sum&gt;target时在此元素后进行划分，而求最小值最大化的时候是在此元素前进行划分。</li></ul><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p><strong>华为的技术面感觉就是其他公司的一面二面结合，用的是zoom，会开摄像头。先自我介绍问项目，然后聊了一会，之后问了几个基础知识点，再然后写了一题，最后介绍自己的部门。</strong></p><p>自我介绍的时候说了项目介绍，然后对方对网安项目很感兴趣，让我介绍，最后他才说自己是做网安的，drl，班门弄斧，并且问了如果进了华为，开发岗和安全岗选哪一个，啊这，简直送命题，最后表示更倾向于开发岗，如果有培养计划可以考虑安全岗。</p><p>知识点的话就问了一下C++，真就入门水平的问题。。。虽然语言组织也不是特别好</p><ul><li>深拷贝和浅拷贝有什么区别</li><li>字符串操作有哪些</li><li>链表和数组的区别和应用场景</li></ul><p>写代码写了个找字符串最长前缀的题，Leetcode原题，还是Easy…，几分钟就写完了，然后开共享讲了一下思路。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longgestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(strs.size() == <span class="number">1</span>) strs[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].size(); ++i)&#123;</span><br><span class="line">        c = strs[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[j][i] != c)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs1 = &#123;<span class="string">"flowers"</span>, <span class="string">"flflflf"</span>, <span class="string">"fl"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs2 = &#123;<span class="string">"abc"</span>, <span class="string">"bca"</span>, <span class="string">"cba"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs3;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs4 = &#123;<span class="string">"abcd"</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; longgestCommonPrefix(strs1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后就是标准结局了，最后问对我的评价的时候就说都挺好，目前没啥问题，让我过了，本来说下午还有一轮技术面，结果一查直接部门主管面了hhhhh。</p><h3 id="部门主管面"><a href="#部门主管面" class="headerlink" title="部门主管面"></a>部门主管面</h3><p><strong>感觉这个部门主管面就相当于leader面+hr面了，挺友好的，主要是在宏观上问问项目和技术。主要就分自我介绍然后他提问，接着反问两个部分</strong></p><p>自我介绍他给了2分钟时间，就把之前的自我介绍里面关于技术的都删了，然后主要问了几个问题：</p><ul><li>你一般怎么提升自己的代码质量</li><li>能讲一下你对TDD的理解嘛</li><li>能讲一下你对敏捷开发的理解嘛</li></ul><p>主要还是根据自我介绍进行提问吧，我感觉这几个点比较好，很符合面试官的期望。</p><p>然后是给我一个机会反问一个问题，问了一个比较宽泛 的问题：</p><ul><li>你们的团队这么大，那在管理方面有没有什么好方法？然后他一个人说了好久，主要是什么高内聚低耦合啊，模块分离啊，然后他扯到了代码重构</li><li>我就继续追问你们团队在什么情况下会考虑或者允许代码重构，然后他又balabala讲一堆</li><li>我又问那如果对小范围的代码进行了重构，在测试上会是一个怎么样的流程，然后他黑盒白盒测试讲了一堆</li><li>就感觉是我在面试他，所以我就没问了</li></ul><p>面试的最后他让我说一下我自己的一个缺点，这简直送命题，就你不能真的说自己的缺点，所以我就说了自己对以后的工作方向比较迷茫，不知道怎么选，他说这不是一个缺点hhhhh，然后又给我疏导了半天，面试就结束了。</p><p>总的来说华为的两面都很舒服，感觉都是在聊天，面试官还会给你一些建议，比其他公司还是要好很多的，我感觉是因为其他公司可能工作忙吧，都是抽时间面试；而华为这些人在这两天是专职面试，所以比较放松。</p><p>最后华为的面试都过了，等后续录用再来更一次，不过去实习是不可能去实习的，只能来混混面试经验这样子。</p><h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><h3 id="时间安排-3"><a href="#时间安排-3" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>2020/4/18 晚上 人才评测</li><li>2020/4/26 下午 笔试</li><li>2020/5/11 晚上 查了一下发现直接没了</li></ul><h3 id="笔试-2"><a href="#笔试-2" class="headerlink" title="笔试"></a>笔试</h3><p><strong>快手的笔试一共4道题，分值分配为20、20、30、30,总计100分，我个人就看了前两道，第一道过了25%后超时，第二道完全没思路，心态崩了，果断提前交卷走人。</strong></p><h4 id="T1-域名归类"><a href="#T1-域名归类" class="headerlink" title="T1 域名归类"></a>T1 域名归类</h4><p><strong>试题如下图</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200426180846.png" alt="T1" title>                </div>                <div class="image-caption">T1</div>            </figure><ul><li>基本就是字符串识别+匹配</li><li>用一个map来把url前缀和路径的set对应起来</li><li>路径用set存储即可去重</li><li>对于不同的前缀，路径set相同即可归为一类</li></ul><p><strong>坑点在于常规操作会超时，进行set对比时最好使用hash，我尝试过把set放进map，但这样需要重载&lt;符号，只能作罢</strong><br>我的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; s1, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.size() != s2.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> iter1 = s1.begin();</span><br><span class="line">    <span class="keyword">auto</span> iter2 = s2.begin();</span><br><span class="line">    <span class="keyword">while</span>(iter1 != s1.end())&#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter1 != *iter2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        iter1++;</span><br><span class="line">        iter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; urls;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; paths;</span><br><span class="line">    <span class="built_in">string</span> tempUrl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tempUrl;</span><br><span class="line">        urls.push_back(tempUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> point = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">7</span>; j &lt; urls[i].size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(urls[i][j] == <span class="string">'/'</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> header = urls[i].substr(<span class="number">0</span>, j);</span><br><span class="line">                <span class="keyword">if</span>(paths.find(header)!=paths.end())&#123;</span><br><span class="line">                    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s = paths[header];</span><br><span class="line">                    s.insert(urls[i].substr(j));</span><br><span class="line">                    paths[header] = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">                    s.insert(urls[i].substr(j));</span><br><span class="line">                    paths[header] = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used(paths.size(), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">auto</span> iter = paths.begin();</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iter != paths.end())&#123;</span><br><span class="line">        <span class="keyword">while</span>(used[now] &amp;&amp; iter != paths.end())&#123;</span><br><span class="line">            iter++;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iter == paths.end())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">        <span class="keyword">auto</span> iter1 = iter;</span><br><span class="line">        <span class="keyword">int</span> now1 = now+<span class="number">1</span>;</span><br><span class="line">        iter1++;</span><br><span class="line">        <span class="keyword">while</span>(iter1 != paths.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[now1] &amp;&amp; valid(iter-&gt;second, iter1-&gt;second))&#123;</span><br><span class="line">                t.push_back(iter1-&gt;first);</span><br><span class="line">                used[now1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iter1++;</span><br><span class="line">            now1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            t.push_back(iter-&gt;first);</span><br><span class="line">            res.push_back(t);</span><br><span class="line">            counter++;</span><br><span class="line">            used[now] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter++;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; counter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res[i].size(); ++j)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大佬的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;hash_fun.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> ha(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &amp;ss)&#123;</span><br><span class="line">  <span class="keyword">size_t</span> res=<span class="number">0x12345</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:ss)res=(res+hash&lt;<span class="built_in">string</span>&gt;()(i))%<span class="number">1000000000</span>;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *head=<span class="string">"http://"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,len=<span class="built_in">strlen</span>(head);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">500</span>];</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tmp);</span><br><span class="line">    vs.push_back(tmp+len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt; um;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:vs)&#123;</span><br><span class="line">    <span class="keyword">auto</span> pos=i.find(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">      um[i].insert(<span class="string">""</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> um[i.substr(<span class="number">0</span>,pos)].insert(i.substr(pos));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>,<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:um)&#123;</span><br><span class="line">    res[ha(i.second)].insert(i.first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res.size());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:res)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j:i.second)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;head&lt;&lt;j&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="T2-辛苦的邮递员"><a href="#T2-辛苦的邮递员" class="headerlink" title="T2 辛苦的邮递员"></a>T2 辛苦的邮递员</h4><p><strong>试题如下图</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200426180955.png" alt="T2" title>                </div>                <div class="image-caption">T2</div>            </figure><p><strong>这个题我反正是没啥思路，大佬说是LCA问题，咱也不懂，咱就查</strong></p><ul><li>在简单看完这篇<a href="https://blog.csdn.net/ywcpig/article/details/52336496" target="_blank" rel="noopener">LCA问题详解</a>后我已经不想学了.jpg</li></ul><h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><h3 id="时间安排-4"><a href="#时间安排-4" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li>2020/4/30 晚上 性格评测</li><li>2020/5/6 下午 笔试</li><li>2020/5/9 下午 一面</li></ul><h3 id="笔试-3"><a href="#笔试-3" class="headerlink" title="笔试"></a>笔试</h3><p><strong>pdd的笔试难度是适中的，基本是1Easy、2Middle、1Hard，最后写出来2.6道，没截屏，简单记录一下</strong></p><h4 id="T1-PDD的盒子"><a href="#T1-PDD的盒子" class="headerlink" title="T1 PDD的盒子"></a>T1 PDD的盒子</h4><p>一共有N个盒子，每个盒子里有Ni个球，需要往盒子里加球，使得每个盒子里的球数都不一样，求最小的加球数</p><ul><li>感觉就不是很难，sort一下然后遍历就可以了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n, t, i, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; box;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        box.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(box.begin(), box.end());</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(box[i] &lt;= box[i<span class="number">-1</span>])&#123;</span><br><span class="line">            c += (box[i<span class="number">-1</span>] - box[i] + <span class="number">1</span>);</span><br><span class="line">            box[i] += (box[i<span class="number">-1</span>] - box[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2-火柴拼正方形"><a href="#T2-火柴拼正方形" class="headerlink" title="T2 火柴拼正方形"></a>T2 火柴拼正方形</h4><p>给定一组长度不同的火柴，判断能否拼成一共正方形，与<a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">Leetcode T473</a>基本一致</p><ul><li>本来写的是贪心，每次取走一个边长的火柴，按长度从长到短取，结果一直过不了，自己又举不出例子</li><li>后来改成了DFS，过了60%，但并没有超时，就比较奇怪，同样举不出例子</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> curLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curLen==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;curLen)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[i];</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(nums,curLen-tmp))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            nums[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j, c, t, now, sum, flag;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; legs;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; c; ++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            sum += t;</span><br><span class="line">            legs.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(legs.begin(), legs.end());</span><br><span class="line">        now = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span>(now &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum % now != <span class="number">0</span> || !dfs(legs, sum/now))&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= (sum/now);</span><br><span class="line">            now--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3-斐波拉契数列变形"><a href="#T3-斐波拉契数列变形" class="headerlink" title="T3 斐波拉契数列变形"></a>T3 斐波拉契数列变形</h4><p>F(i) = F(i-1) + F(i-2)，输入F(0) = A, F(1) = B,求F(T)是否能被3整除</p><ul><li>这题拿到第一想法就是分类讨论</li><li>后来发现F(x)%3必定会走上一个循环(01120221)</li><li>这个循环里包含了除了00外所有的组合</li><li>当AB不同时只是初始位置不同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a, b, i, t, now;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            now = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            now = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            now = <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            now = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            now = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            now = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            now = <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; b % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            now = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = (t + now) % <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span> || now == <span class="number">4</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p><strong>pdd的处理速度还是很快的，5.6笔试，5.7晚上发通知，5.9就面试了。</strong></p><p>一面整体感觉比较友好，上来先是自我介绍，这点要说一下，pdd用的是自己的面试平台，贼严，就连多屏幕跳转都能检测得到，没办法只能硬上了，基本情况说了一下之后着重问了一下网安项目，然后问常用的编程语言，问了操作系统的一些基础问题，最后写了两道easy的编程题<br>，问我有没有什么问题就结束了，总共不到40min时间。</p><h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><ul><li>内存泄漏的原因、检测方法、处理方法</li><li>一个线程有几个堆几个栈、为什么不大家共用堆栈</li><li>堆与栈的区别</li><li>操作系统为什么分用户态和内核态</li><li>用户态是怎么切换到内核态的(主动和被动)</li></ul><h4 id="面试编程题"><a href="#面试编程题" class="headerlink" title="面试编程题"></a>面试编程题</h4><h5 id="T1-数组去重"><a href="#T1-数组去重" class="headerlink" title="T1 数组去重"></a>T1 数组去重</h5><ul><li>给定一个数组，去掉与相邻元素重复的元素，返回剩余的元素个数X，并在数组尾部补全原数组的最后X个元素</li><li>最后被问能否不开辟空间，我给的答复是可以，但是时间复杂度就会O(n)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给的是指针就用C写了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">t1</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(l*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, l*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    temp[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] != data[i<span class="number">-1</span>])&#123;</span><br><span class="line">            temp[count] = data[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="T2-寻找key-value"><a href="#T2-寻找key-value" class="headerlink" title="T2 寻找key-value"></a>T2 寻找key-value</h5><ul><li>给定一个数组，存储着key-value。并且key是有序的，存储方式为k1,v1,k2,v2…，给定一个key，返回其value，不存在则返回-1</li><li>基本就是自己实现map，我采用的是二分法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">t2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; kvs, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(kvs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = kvs.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//当时写代码时没有考虑到mid的奇偶问题，感觉对mid的处理还是有点问题</span></span><br><span class="line">        <span class="comment">//应该初始化r=len-2,然后if(mid%2 != 0) mid+=1;</span></span><br><span class="line">        mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(kvs[mid] == key)&#123;</span><br><span class="line">            <span class="keyword">return</span> kvs[mid+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(kvs[mid] &gt; key)&#123;</span><br><span class="line">            r -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准结局"><a href="#标准结局" class="headerlink" title="标准结局"></a>标准结局</h4><ul><li>又到了给面试官提问的环节了</li><li>Q1：公司加班多吗，还是分部门(一般公司会这么说)</li><li>A1：承认整体加班都多，但反手表示各公司都加班，但pdd给加班费多</li><li>Q2：公司技术氛围如何？开会多吗？有技术分享吗？</li><li>A2：技术氛围还ok吧，开会不多，分享偶然有，但不要抱太大期望</li><li>Q3：对我的评价</li><li>A3：整体还挺好的，但就是做的东西比较杂，而且网络安全这个方向emmmm</li></ul><p>有一说一，pdd的员工真的就异常真实了，愿意承认加班多，技术氛围一般，就是钱多，也愿意对我做出最真实的评价，不像某里说不错反手给挂了，也不像某讯，表示不方便透露。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;收录一下实习生期间阿里云、腾讯、华为、快手、拼多多五个公司的面经，当时没有做太多准备，只拿到了华为的offer，但是对整个面试的流程以及可能涉及到的问题有了初步的了解，便于自己之后针对性学习。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++相关知识点梳理</title>
    <link href="https://liuyi12138.github.io/2020/06/24/C++%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>https://liuyi12138.github.io/2020/06/24/C++%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</id>
    <published>2020-06-24T08:03:36.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下与C++相关的一些常考知识点。<br><a id="more"></a> </p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><p>未加static的全局变量和函数是全局可见的，当同时编译多个文件时，文件之间的变量或者函数可能会有命名冲突的情况，可以使用static来隐藏，使得变量或函数只能在该文件可见。</p><h4 id="改变变量的存储方式和生命周期"><a href="#改变变量的存储方式和生命周期" class="headerlink" title="改变变量的存储方式和生命周期"></a>改变变量的存储方式和生命周期</h4><p>static关键字会使得它修饰的变量存储在静态存储区，在程序开始运行是就初始化，并且会一直存在直到程序结束，并且不会被再次初始化。</p><h4 id="对类成员声明static"><a href="#对类成员声明static" class="headerlink" title="对类成员声明static"></a>对类成员声明static</h4><p>同样有上述的几种功能，对该成员函数or静态变量进行隐藏以及改变其生命周期，并且所有的对象共用一个静态成员函数或静态变量。另外静态内部类也是实现单例模式的一种方法，其优点在于外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const用来表示常量，即不允许他修饰的变量被修改，在进行参数传递的时候，也常常使用const修饰引用来传参，既保证了不复制参数，又防止对象被修改。<br>C++中还可以用const修饰成员函数和数据成员来达到封装的目的，不允许使用const修饰的成员函数来修改数据成员。</p><h3 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h3><p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用(只是声明，不分配内存)</p><p>与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p><p>被extern “C”修饰的变量和函数是按照C语言方式编译和链接的</p><p>之所以要如此是因为编译器在将C++源代码编译成目标文件时，会将函数和变量的名称进行修饰，形成符号名，目标文件中所使用的符号名就是修饰后名称，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数（重载）。因此有时候在调用一些库函数的时候，会出现无法链接的情况(因为函数签名不同)所以对于C++来说，必须使用extern “C”来声明这些函数。</p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><p>RTTI是运行时类型检测，也是C++11的新特性，主要是在<code>dynamic_cast</code>、<code>typeid</code>中使用，在进行类型转换前或者获取类型时，会查询<code>type_info</code>指针来进行类型检测。</p><h3 id="cast转换"><a href="#cast转换" class="headerlink" title="cast转换"></a>cast转换</h3><ul><li>const_cast，用于将const变量转换为非const</li><li>static_cast，用于隐式转换，如非const转const，void*转指针等，能用于多态向上转化，向下不安全</li><li>static_cast，动态类型转换，可以用于层次间的向上向下转化，只能转指针和引用</li><li>reinterpret_cast，什么都可以转，可能会出问题</li></ul><h3 id="虚函数（多态）"><a href="#虚函数（多态）" class="headerlink" title="虚函数（多态）"></a>虚函数（多态）</h3><h4 id="多态及其实现条件"><a href="#多态及其实现条件" class="headerlink" title="多态及其实现条件"></a>多态及其实现条件</h4><p>c++中的多态就是在父类的函数前加上virtual关键字，在子类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是子类，就调用子类的函数，如果对象类型是父类，就调用父类的函数。</p><p>多态的实现需要两个条件：</p><ul><li>虚函数重写，设置不同的状态</li><li>对象调用虚函数时必须是指针或者引用</li></ul><h4 id="虚函数与重写"><a href="#虚函数与重写" class="headerlink" title="虚函数与重写"></a>虚函数与重写</h4><ul><li>虚函数是带有virtual关键字的成员函数</li><li>子类有个和父类完全相同(函数名,形参,返回值都相同,协变和析构函数除外)的虚函数,就称子类虚函数重写父类虚函数 </li></ul><h4 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h4><ul><li>多态是用虚函数表来实现的</li><li>有虚函数的类都会生成一个虚函数表，在编译的时候使用</li><li>虚函数表是一个存储虚函数地址的数组</li><li>生成子类的虚函数表需要经过一下步骤<ul><li>将父类的虚函数表拷贝</li><li>将子类中重写的虚函数覆盖掉父类中的虚函数</li><li>如果有新增加的虚函数则放到表的最后</li></ul></li><li>在调用时会根据对象中的虚表指针来找实际应该调用的函数</li></ul><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul><li>虚函数和普通函数一样在代码段,虚表在只读常量区</li><li>inline函数(内联函数)没有地址,无法放到虚函数表中</li><li>静态成员不能是虚函数，因为静态成员函数没有this指针,因为有this指针才能访问到虚表指针,有虚表指针才能找到虚表从而调用实际应该调用的函数</li><li>构造函数不能是虚函数，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的</li><li>析构函数可以是虚函数，并且最好把基类的析构函数定义成虚函数，当父类指针指向子类对象时,如果析构函数不是虚函数,析构就只会释放父类对象,造成内存泄漏</li><li>普通对象访问普通函数和访问虚函数是一样快的(不会触发多态);指针对象或者是引用对象，调用普通函数更快一些，因为构成了多态，运行时调用虚函数要先到虚函数表中去查找。这样然后才拿到韩式的地址，这样就不如直接可以拿到函数地址的普通函数快。</li></ul><h3 id="内存管理与内存泄露"><a href="#内存管理与内存泄露" class="headerlink" title="内存管理与内存泄露"></a>内存管理与内存泄露</h3><p>可以通过静态扫描来检测内存泄露，具体的操作为对象计数；重载new/delete，记录分配点等</p><p>解决内存泄露可以使用智能指针，但要小心循环引用的问题。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>auto实际上很早就被引入到C++，用来进行类型推导，比如用在迭代器中。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>传统的C++无法区分NULL和0，有的编译器会把NULL定义为void*的指针，有的直接就定义为0了，这就会导致一系列的问题，比如在重载时会发生混乱，所以C++11引入了nullptr来区分空指针和0。</p><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>进行遍历的时候可以像python一样写<code>auto iter:arr</code>来遍历。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>提供了统一的语法来初始化任意的对象,这两个特性就让人感觉C++越来越智能而简洁了。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11引入智能指针主要是因为C++没有自动的内存回收机制，所以当业务逻辑过于复杂的时候难免会出现内存没有delete的现象，这就容易造成内存泄漏的问题，智能指针主要就是被用来对这些资源进行动态管理，并及时释放无用的资源。</p><p>C++11提供四种智能指针，有<code>unique_ptr</code>,<code>shared_ptr</code>, <code>weak_ptr</code>,以及<code>auto_ptr</code>，不过<code>auto_ptr</code>已经被弃用。</p><p><code>shared_ptr</code>允许多个指针指向相同的对象，每次被引用就内部计数+1，析构则-1，当引用计数为0时则释放内存。<code>unique_ptr</code>只允许一个指针指向给定的对象，<code>weak_ptr</code>最大的作用在于协助<code>shared_ptr</code>，可以观测目标对象的引用计数。</p><p>智能指针会遇到的最大问题是循环引用，就像是类之间的循环引用一样，两个指针互相引用对方就会造成都无法析构的现象。循环引用的现象可以通过让引用链上的一方持用普通指针或弱智能指针(weak_ptr)来解决。</p><p>实现智能指针可以通过引入辅助类或者使用句柄。<br>辅助类实现即单独使用一个类来存储引用计数，每次在构造和析构智能指针类的时候对辅助类进行操作。<br>而句柄实现则是把指针封装起来，通过重载来重新定义指针的行为，将计数内置进去。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>C++11引入右值引用的目的是解决拷贝临时对象时的性能低下问题，在C++11之前，进行临时对象拷贝时会多调用一次构造函数并复制，这就使得性能低下。实际上直接移动变量的指向就会快得多，但C++11之前右值是不能被取地址的，所以没法进行右值引用。</p><p>从本质上来说，左值引实际上是用const指针来实现的，它保存的是一个指向数据地址的指针，而如果进行反汇编可以发现右值引用是通过取地址来实现的，一个变量的右值引用存储的就是它的地址。</p><p>而对于传入的引用，在不知道是左值还是右值的情况下，可以用move函数来将其转换为右值，也就是实现了取地址的操作。</p><h3 id="新增STL容器array以及tuple-元组"><a href="#新增STL容器array以及tuple-元组" class="headerlink" title="新增STL容器array以及tuple(元组)"></a>新增STL容器array以及tuple(元组)</h3><p>array保存在栈内存中，相比堆内存中的vector，速度更快，但array长度无法更改，没有vector灵活。</p><p>而新增了tuple感觉就是C++在像python看齐</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下与C++相关的一些常考知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="C++" scheme="https://liuyi12138.github.io/tags/C/"/>
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>网址访问过程详解</title>
    <link href="https://liuyi12138.github.io/2020/05/25/%E7%BD%91%E5%9D%80%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://liuyi12138.github.io/2020/05/25/%E7%BD%91%E5%9D%80%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-25T13:06:36.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p>在面试过程中常常会遇到这样一个问题：请你详细描述一下从我们在浏览器中输入网址到最后看到网页，这个过程中发生了什么？这个问题涉及面十分广，几乎涵盖了计网的全部相关问题，这个题的答案因人而异，可以挑选一两个着重点进行详细说明，其他的略过。<br><a id="more"></a> </p><h3 id="全过程简要概述"><a href="#全过程简要概述" class="headerlink" title="全过程简要概述"></a>全过程简要概述</h3><p>当我们将网址输入到浏览器后，第一件事就是解析url得到域名，通过<strong>DNS协议</strong>获取到该域名的ip地址，得到ip后浏览器会先与服务器通过TCP三次握手建立连接，然后构建<strong>HTTP请求</strong>，将HTTP的传输工作交给操作系统的协议栈，发送请求成功后，浏览器会从服务端拿到该页面的HTML以及资源文件，浏览器会<strong>渲染页面</strong>，呈现出我们所看到的模样。</p><p>在这整个过程中，涉及到了DNS解析，http请求，TCP\IP协议栈、页面渲染等知识，当然也可以继续扩展，比如从HTTP可以说到HTTPS，可以说到对称加密与非对称加密，可以说到网络安全等等，主要目的就是让整个面试过程跟着你的技术栈走，而不被面试官带到你不会的地方。</p><p>在这里我将重点写一下我在面试中喜欢拓展的方向，并拟出一份答案。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>浏览器在拿到url时，首先会对url进行解析，将域名与实际的文件路径分离，然后需要使用DNS协议，通过域名得到IP地址。</p><p>首先浏览器会查询浏览器缓存，如果有这个网址就可以直接获取到IP，如果没有就进一步访问本机缓存，如果本机缓存也没有才会发起DNS请求。</p><p>而DNS的服务器是一个树状结构，对于域名来说是倒着进行解析的，根节点是根DNS服务器，他的子节点为com、cn这种顶级域dns服务器，然后进一步向下进行解析。</p><p>以baidu.com为例，当我们的电脑需要发起DNS请求的时候，会先对根DNS服务器发起请求，这个服务器的IP地址一般在每台电脑上都有，我们一般会设置为8.8.8.8或者114.114.114.114，我们的电脑在访问根DNS服务器后，会得到con域DNS服务器的IP，然后会继续访问con域DNS服务器，这时就能得到baicu.com的IP地址了。</p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>在解析url时，我们能获取到需要请求资源的资源路径、端口号、请求参数等信息，这些信息会被存储在http头中，通过DNS请求获取到ip后，浏览器会构建并发送HTTP请求或者HTTPS请求，HTTPS就是在HTTP的基础上加了一个TLS协议来进行数据加密，这个我们待会说。</p><p>HTTP请求有很多种，但对资源的操作离不开增删改查，也就对应着POST、DELETE、PUT、GET请求。最常用的是GET和POST，其区别在于GET的参数是在url中的，而POST的参数是在请求的body中。</p><p>以GET为例，当需要发送HTTP请求的时候，同样也不是直接就发送了，需要先查询浏览器缓存。浏览器中的缓存分为强缓存和协商缓存，浏览器发起HTTP请求时首先会根据http头信息来判断是存有强缓存，以及其是否过期，如果有强缓存且未过期则命中，不会发送请求到服务器了。如果强缓存没命中，则会向服务器发起请求，这个请求的Header头中会带有浏览器最后一次请求该资源的时间和一个资源校验码(使用资源修改时间、资源大小等信息生成)，服务器收到这个请求后会判断协商缓存是否过期，如果过期则返回新的资源信息，如果没过期则返回304状态码，表示资源未更新，可以使用缓存中的资源。</p><h3 id="TCP-gt-网络层连接"><a href="#TCP-gt-网络层连接" class="headerlink" title="TCP-&gt;网络层连接"></a>TCP-&gt;网络层连接</h3><p><strong>TCP这一块内容比较多，所以一般不会在这个问题中详细说明，这里只写一个过渡段，想要了解TCP相关问题解答的可以看我的另一篇博客：<a href="https://liuyi12138.github.io/2020/05/24/TCP%E8%AF%A6%E8%A7%A3/">TCP详解</a></strong></p><p>HTTP请求发出后会将数据包交给下层协议栈处理，在传输层和网络层该数据包会被分别加上TCP头和IP头，并且被发送出去，沿路的网关会收到这个数据包并进行识别和转发，直到该数据包被服务器收到，通过相同的流程返回回复数据包。</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p><strong>由于我对前端不熟悉，就不展开讲，被问到的话就说是通过写爬虫来了解DOM树的(挪威组)，前端只会简单的Vue开发，底层原理不了解</strong></p><p>一般来说，浏览器第一次从服务器请求的资源都是一个HTML文件，例如服务端默认的index.html等，浏览器获取到这个HTML文件就会对其进行解析，构建出一棵DOM树，并通过执行其中的js代码发起更多的请求，请求渲染页面需要的其他资源，CSS或者一些外链的图片等，拿到CSS后将其与DOM树结合进行更进一步的渲染，我们就能看到页面了。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>由于HTTP是使用信息明文传播，所以会有窃听、篡改、冒充等风险，所以HTTPS在HTTP的基础上加上了SSL层，通过加密的方式来保证数据安全。</p><p>SSL通过加密防止窃听，通过签名来防止篡改，通过证书来防止冒充。<br>HTTPS协议在客户端与服务端开始通信前，会进行密钥协商，通过一轮非对称加密，一般是RSA加密来传递后序通信过程使用的对称密钥，由于非对称加密较慢，后续通信过程中使用对称加密。在密钥协商的过程中，服务端会将自己的证书发送给客户端，客户端会到CA机构通过摘要值验证证书的合法性，从而防止中间人攻击。</p><h4 id="补充提问：你对中间人攻击有哪些了解？"><a href="#补充提问：你对中间人攻击有哪些了解？" class="headerlink" title="补充提问：你对中间人攻击有哪些了解？"></a>补充提问：你对中间人攻击有哪些了解？</h4><p><strong>中间人攻击主要分为SSL劫持攻击、SSL剥离攻击以及针对SSL算法的攻击</strong></p><ul><li>SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样中间人就可以解密客户端和服务端的数据传输内容。可以通过在网站前端加入证书校验来预防SSL劫持攻击。</li><li>SSL剥离攻击，即将HTTPS连接降级到HTTP连接。假如客户端直接访问HTTPS的URL，攻击者是没办法直接进行降级的，该攻击方式主要是利用用户并不会每次都直接在浏览器上输入https来访问网站或者有些网站并非全网HTTPS，中间人攻击者在劫持了客户端与服务端的HTTP会话后，将HTTP页面里面所有的 https:// 超链接都换成 http:// ，用户在点击相应的链接时，是使用HTTP协议来进行访问。可以通过在网站前端检查URL是否被篡改来预防SSL剥离攻击。</li><li>针对SSL算法的攻击：低版本的SSL协议是存在漏洞的，这些漏洞可能会被公共者利用，及时升级服务端的SSL配置可以预防针对SSL算法的攻击。</li></ul><h3 id="最终答案"><a href="#最终答案" class="headerlink" title="最终答案"></a>最终答案</h3><p>浏览器在拿到url时，首先会对url进行解析，将域名与实际的文件路径分离，然后需要使用DNS协议，通过域名得到IP地址。<br>浏览器会查询浏览器缓存，如果有这个网址的缓存就可以直接获取到IP，如果没有就进一步访问本机缓存，如果本机缓存也没有才会发起DNS请求。<br>而DNS的服务器是一个树状结构，对于域名来说是倒着进行解析的，根节点是根DNS服务器，他的子节点为com、cn这种顶级域dns服务器，然后进一步向下进行解析。<br>以baidu.com为例，当我们的电脑需要发起DNS请求的时候，会先对根DNS服务器发起请求，这个服务器的IP地址一般在每台电脑上都有，我们一般会设置为8.8.8.8或者114.114.114.114，我们的电脑在访问根DNS服务器后，会得到con域DNS服务器的IP，然后会继续访问con域DNS服务器，这时就能得到baicu.com的IP地址了。</p><p>得到ip后浏览器会先与服务器通过TCP三次握手建立连接，然后构建HTTP请求。<br>在解析url时，我们能获取到需要请求资源的资源路径、端口号、请求参数等信息，这些信息会被存储在http头中，通过DNS请求获取到ip后，浏览器会构建并发送HTTP请求或者HTTPS请求，HTTPS就是在HTTP的基础上加了一个TLS协议来进行数据加密，这个我们待会说。<br>HTTP请求有很多种，但对资源的操作离不开增删改查，也就对应着POST、DELETE、PUT、GET请求。最常用的是GET和POST，其区别在于GET的参数是在url中的，而POST的参数是在请求的body中。<br>以GET为例，当需要发送HTTP请求的时候，同样也不是直接就发送了，需要先查询浏览器缓存。浏览器中的缓存分为强缓存和协商缓存，浏览器发起HTTP请求时首先会根据http头信息来判断是存有强缓存，以及其是否过期，如果有强缓存且未过期则命中，不会发送请求到服务器了。如果强缓存没命中，则会向服务器发起请求，这个请求的Header头中会带有浏览器最后一次请求该资源的时间和一个资源校验码(使用资源修改时间、资源大小等信息生成)，服务器收到这个请求后会判断协商缓存是否过期，如果过期则返回新的资源信息，如果没过期则返回304状态码，表示资源未更新，可以使用缓存中的资源。</p><p>HTTP请求发出后会将数据包交给下层协议栈处理，在传输层和网络层该数据包会被分别加上TCP头和IP头，并且被发送出去，沿路的网关会收到这个数据包并进行识别和转发，直到该数据包被服务器收到，通过相同的流程返回回复数据包。</p><p>一般来说，浏览器第一次从服务器请求的资源都是一个HTML文件，例如服务端默认的index.html等，浏览器获取到这个HTML文件就会对其进行解析，构建出一棵DOM树，并通过执行其中的js代码发起更多的请求，请求渲染页面需要的其他资源，CSS或者一些外链的图片等，拿到CSS后将其与DOM树结合进行更进一步的渲染，我们就能看到页面了。</p><p>最后再补充一下HTTPS，由于HTTP是使用信息明文传播，所以会有窃听、篡改、冒充等风险，所以HTTPS在HTTP的基础上加上了SSL层，通过加密的方式来保证数据安全。<br>SSL通过加密防止窃听，通过签名来防止篡改，通过证书来防止冒充。<br>HTTPS协议在客户端与服务端开始通信前，会进行密钥协商，通过一轮非对称加密，一般是RSA加密来传递后序通信过程使用的对称密钥，由于非对称加密较慢，后续通信过程中使用对称加密。在密钥协商的过程中，服务端会将自己的证书发送给客户端，客户端会到CA机构通过摘要值验证证书的合法性，从而防止中间人攻击。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.nowcoder.com/tutorial/93/e1b14ab2b40a4ef98d9e55830eb48d66" target="_blank" rel="noopener">C++工程师面试宝典之计算机网络</a></li><li><a href="https://blog.csdn.net/jochebed666/article/details/88377253" target="_blank" rel="noopener">在浏览器中输入一个URL会发生什么?</a></li><li><a href="https://www.cnblogs.com/tisikcci/p/5866753.html" target="_blank" rel="noopener">在浏览器中输入URL并回车后都发生了什么？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&amp;mid=2247485569&amp;idx=2&amp;sn=a9bf44fa1ec4e9ebee345d8ccae4a1fb&amp;chksm=fddede45caa957532b0c95fa6071428da1bd4ec9a7ae6511abbd3f40baed33f40f779a2818e1&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1590414335165&amp;sharer_shareid=74f3beda79e30a98e4e0f8dd6e1fd9d4#rd" target="_blank" rel="noopener">探究：一个数据包在网络中到底是怎么游走的？</a></li><li><a href="https://www.cnblogs.com/an-wen/p/11180076.html" target="_blank" rel="noopener">HTTP协议超级详解</a></li><li><a href="https://www.cnblogs.com/ranyonsue/p/8918908.html" target="_blank" rel="noopener">HTTP缓存机制</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="https://blog.csdn.net/liuxingrong666/article/details/83869161" target="_blank" rel="noopener">HTTPS的数字证书验证原理</a></li><li><a href="https://www.jianshu.com/p/a825de42ccbc" target="_blank" rel="noopener">MITM攻击(中间人攻击)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试过程中常常会遇到这样一个问题：请你详细描述一下从我们在浏览器中输入网址到最后看到网页，这个过程中发生了什么？这个问题涉及面十分广，几乎涵盖了计网的全部相关问题，这个题的答案因人而异，可以挑选一两个着重点进行详细说明，其他的略过。&lt;br&gt;
    
    </summary>
    
    
      <category term="计网" scheme="https://liuyi12138.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
      <category term="计网" scheme="https://liuyi12138.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCP详解</title>
    <link href="https://liuyi12138.github.io/2020/05/24/TCP%E8%AF%A6%E8%A7%A3/"/>
    <id>https://liuyi12138.github.io/2020/05/24/TCP%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-24T07:51:36.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中但凡问到计网，肯定会问TCP相关的问题，而很多细节总是遗忘，所以需要专门以问答的方式写一篇博客来记载一下。<br><a id="more"></a> </p><h3 id="TCP三次握手的目的是什么？为什么不用两次和四次？"><a href="#TCP三次握手的目的是什么？为什么不用两次和四次？" class="headerlink" title="TCP三次握手的目的是什么？为什么不用两次和四次？"></a>TCP三次握手的目的是什么？为什么不用两次和四次？</h3><p><strong>TCP三次握手的主要目的是防止失效的连接请求报文被服务端接受</strong></p><p>如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。</p><p>两次握手只能保证单向链路是可以通信的，理论上来说，要保证双向链路可以通信需要四次握手，但实际上服务端给客户端的SYN和ACK数据包可以合为一次握手，所以实际上只需要三次握手即可。</p><ul><li><strong>加问：那挥手为什么需要四次呢？三次不行吗？</strong></li><li>答：挥手阶段中服务端的ACK和FIN数据包不能合为一次。因为挥手阶段的流程为客户端发送FIN数据包表示自己发完了，服务端立即回复ACK数据包表示自己知道了，此时客户端到服务端的连接已经释放了，客户端不会再发送数据了，但服务端还可以继续向客户端发送数据，等到服务端也完成了数据发送，才会发送FIN，这时客户端回复ACK，就可以结束通信了。</li><li><strong>加问：TCP在四次挥手的过程中为什么客户端最后还要等待2MSL(Maximum Segment Lifetime)？</strong></li><li>答：因为客户端要保证他的ACK包顺利到达服务端，如果客户端的ACK数据包丢失，则服务端或重新发送FIN包到客户端，而这两个过程的最长时间为1MSL，加起来为2MSL，如果2MSL后客户端还没有收到服务端重发的FIN包，则说明ACK包顺利到达，可以关闭连接了。</li></ul><h3 id="TCP在握手阶段怎么管理客户端的连接？"><a href="#TCP在握手阶段怎么管理客户端的连接？" class="headerlink" title="TCP在握手阶段怎么管理客户端的连接？"></a>TCP在握手阶段怎么管理客户端的连接？</h3><p>TCP在握手阶段服务端维护了两个队列：半连接队列和全连接队列</p><ul><li>在客户端发起第一次握手时，服务端会把此请求放入半连接队列，并回复SYN+ACK</li><li>在客户端回复ACK，也就是第三次握手时，服务端将此连接加入到全连接队列</li><li>如果全连接队列满，则服务端的处理方式和<code>tcp_abort_on_overflow</code>参数的设置有关，如果该参数为0，则丢弃该ACK，如果为1则发送RST到客户端，直接放弃此次连接。</li></ul><p><strong>此条是我在了解DDOS时发现的，并非常考点，SYN Flood攻击时会造成服务端的半连接队列被占满，从而影响到服务。</strong></p><h3 id="TCP通过哪些方式来保证数据的可靠性？"><a href="#TCP通过哪些方式来保证数据的可靠性？" class="headerlink" title="TCP通过哪些方式来保证数据的可靠性？"></a>TCP通过哪些方式来保证数据的可靠性？</h3><p><strong>TCP保证数据可靠性的方式大致可以分为三类：</strong></p><ul><li>在数据包层面：校验和</li><li>在数据包传输层面：序列号、确认应答、超时重传</li><li>在流量控制层面：拥塞控制</li></ul><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且加上进位，最后取反，得到校验和。<br><strong>TCP与UDP校验方式相同</strong></p><h4 id="序列号、确认应答、超时重传"><a href="#序列号、确认应答、超时重传" class="headerlink" title="序列号、确认应答、超时重传"></a>序列号、确认应答、超时重传</h4><p>在数据包传输的过程中，每个数据包都有一个序列号，当数据到达接收方时，接收方会发出一个确认应答，表示收到该数据包，并会说明下一次需要接收到的数据包序列号(32位确认序列号)。如果发送端在一段时间内(2RTT没有收到确认应答，则说明可能是发送的数据包丢失或者确认应答包丢失，此时发送端会进行数据包重传。</p><p>但发送端并不是一定要等到接收到上一个数据包的确认应答再发送下一个数据包，TCP会利用窗口控制来提高传输速度，在一个发送窗口大小内，不用一定要等到应答才能发送下一段数据，发送窗口大小就是无需等待确认而可以继续发送数据的最大值。而发送窗口的大小是由接收端的接受窗口的剩余大小和拥塞窗口来决定的。<strong>(TCP会话的双方都各自维护一个发送窗口和一个接收窗口)</strong></p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>发送端维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送端让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p><p>TCP的拥塞控制主要是采用慢启动以及增性加，乘性减的机制，TCP一开始将拥塞窗口设置的很小，在逐渐经过一段时间的指数增长后超过门限，进入增性加阶段，此时窗口大小的增长是线性的，比之前的指数增长要慢很多，而当发生网络拥塞时，拥塞窗口大小直接减半（乘性减）。</p><h3 id="TCP长连接和短连接有什么区别？"><a href="#TCP长连接和短连接有什么区别？" class="headerlink" title="TCP长连接和短连接有什么区别？"></a>TCP长连接和短连接有什么区别？</h3><p>TCP短连接是指客户端与服务端连接后只进行一次读写就关闭连接，一般是客户端关闭。<br>而长连接则是指在进行完一次读写后不关闭连接，直到服务端压力过大则选择关闭一些长时间为进行读写的连接。</p><p>TCP短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。</p><p>TCP长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。</p><p>长短连接的区别就在于客户端和服务端选择的关闭策略不同，具体需要根据应用场景来选择合适的策略。</p><h3 id="TCP粘包、拆包及解决方法？"><a href="#TCP粘包、拆包及解决方法？" class="headerlink" title="TCP粘包、拆包及解决方法？"></a>TCP粘包、拆包及解决方法？</h3><p>TCP之所以会产生粘包和拆包拆包问题，是因为他本身就是一种字节流协议，TCP本身就没有数据包的概念，需要发送和接受的数据是没有格式的，以字节流的形式传输，而在传输过程中会被分割为一段段数据块，也就是报文。TCP要发送的数据会被先放置在数据缓冲区，接收数据也是从缓冲区获取，而缓冲区的大小即为最大报文长度，如果需要发送的数据长度大于缓冲区剩余的大小或者大于最大报文长度，则会出现拆包，如果是需要发送的数据很少，而短时间内又有其他数据包需要发送，就会出现粘包的现象。</p><p>解决方案有很多种，可以在数据包头加上数据包长度，或者把每个数据包封装为固定长度，不够则补0，以及可以使用特定分割符号等等</p><p>我们在项目中也遇到过这种问题，因为我们在做流量检测的时候，有时候难以找到恶意软件的流量特征，会把数据包长度当做特征来使用，有些恶意软件内部无论会把这些数据包长度写死，这样恶意软件本身就不存在有无法解析粘包和拆包的情况，但对于我们来说，检测就会遇到障碍，尤其是攻击者可以设置MSS来使得数据包长度改变，对于这种攻击我们目前也没有很好的方案来解决。</p><h3 id="TCP进阶问题"><a href="#TCP进阶问题" class="headerlink" title="TCP进阶问题"></a>TCP进阶问题</h3><p><strong>不会吧不会吧，真的有人会问的这么难嘛</strong></p><p>参考<a href="http://blog.sina.com.cn/s/blog_70a933a80101c686.html" target="_blank" rel="noopener">TCP细节知识 </a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/u013256816/article/details/84001583" target="_blank" rel="noopener">一文详解TCP</a></li><li><a href="https://www.nowcoder.com/tutorial/93/e1b14ab2b40a4ef98d9e55830eb48d66" target="_blank" rel="noopener">C++工程师面试宝典之计算机网络</a></li><li><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157" target="_blank" rel="noopener">网络基础：TCP协议-如何保证传输可靠性</a></li><li><a href="https://blog.csdn.net/yao5hed/article/details/81046945" target="_blank" rel="noopener">解析TCP之滑动窗口</a></li><li><a href="https://blog.csdn.net/qq_32924343/article/details/80804242" target="_blank" rel="noopener">TCP握手中的半连接队列和全连接队列</a></li><li><a href="https://www.cnblogs.com/chinaops/p/9303041.html" target="_blank" rel="noopener">TCP长连接与短连接的区别</a></li><li><a href="https://blog.csdn.net/wxy941011/article/details/80428470" target="_blank" rel="noopener">TCP粘包，拆包及解决方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中但凡问到计网，肯定会问TCP相关的问题，而很多细节总是遗忘，所以需要专门以问答的方式写一篇博客来记载一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="计网" scheme="https://liuyi12138.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
      <category term="计网" scheme="https://liuyi12138.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Web安全简介</title>
    <link href="https://liuyi12138.github.io/2020/05/23/Web%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://liuyi12138.github.io/2020/05/23/Web%E5%AE%89%E5%85%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2020-05-23T08:39:36.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p>在腾讯实习生面试的时候被问到Web安全，发现自己不是很了解，在此简单记录一下常见的一些Web安全知识。<br><a id="more"></a> </p><p><strong>Web从业者和网安从业者都需要对Web安全有一定了解，常见的Web攻击方式有XSS、SQL注入、DDOS、CSRF等，其中有一部分在ctf比赛中也会有所接触。</strong></p><h2 id="OWASP-TOP10"><a href="#OWASP-TOP10" class="headerlink" title="OWASP TOP10"></a>OWASP TOP10</h2><p>OWASP TOP10这个榜单的描述感觉挺抽象的，2017版如下，但在面试的时候最好不要全盘托出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A1 注入 Injection</span><br><span class="line">A2 失效的身份认证</span><br><span class="line">A3 敏感信息泄露</span><br><span class="line">A4 XML外部实体（XXE）</span><br><span class="line">A5 失效的访问控制</span><br><span class="line">A6 安全配置错误</span><br><span class="line">A7 跨站脚本（XSS）</span><br><span class="line">A8 不安全的反序列化</span><br><span class="line">A9 使用含有已知漏洞的组件</span><br><span class="line">A10 不足的日志记录和监控</span><br></pre></td></tr></table></figure></p><p>我的面试回答：</p><p>这个榜单我记不大全了，但我可以按照我的理解大概梳理一下常见的WEB安全问题，大概有注入（包括SQL注入、OS注入等）、身份信息验证（比如中间人攻击这种对握手阶段的攻击）、XSS攻击、CSRF攻击、以及一些安全配置问题，比如使用含有漏洞的框架等等。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h3><p>XSS攻击：跨站脚本攻击(Cross-Site Scripting)是指攻击者往Web页面中插入恶意的Script代码，当其他用户浏览该页面是，恶意代码就会执行，从而达到攻击用户的目的。</p><p>一般xss漏洞是通过php的输出函数将js代码输出到html页面，通过用户本地浏览器进行执行。</p><h3 id="XSS漏洞分类"><a href="#XSS漏洞分类" class="headerlink" title="XSS漏洞分类"></a>XSS漏洞分类</h3><p>XSS漏洞一般分为两类：</p><ul><li>存储型XSS(持久化)：主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等，攻击者在相关页面输入脚本代码，当其他用户访问时，服务器会从数据库中查询到该代码并发送给其他用户的浏览器。</li><li>反射型XSS(非持久化)：将脚本代码加入URL中，需要欺骗用户去点击链接才会触发脚本。</li></ul><p><strong><a href="https://zhuanlan.zhihu.com/p/24249045" target="_blank" rel="noopener">XSS实战</a></strong></p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>过滤特殊字符：对用户输入的内容中的敏感字段进行过滤，比如<code>&lt;script&gt;</code>标签等</li><li>使用HTTP头指定数据类型，比如指定为<code>&quot;text/javascript&quot;</code>,就可以让浏览器来解析js代码</li></ul><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="SQL注入简介"><a href="#SQL注入简介" class="headerlink" title="SQL注入简介"></a>SQL注入简介</h3><p>攻击者向服务器提交恶意的SQL查询代码，程序在接收到后错误地将输入当做查询语句的一部分进行执行，导致原始的查询逻辑被改变。</p><p>举例：<code>OR &#39;1&#39;=&#39;1&#39;</code>，当我们进行登录的时候把这段字符串作为password，就可能直接绕过SQL查询时对password的校验。</p><h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>对sql语句进行预编译，这样的话即使攻击者伪造了参数，到服务端时这些参数都会被当做字符处理</li><li>对输入的特殊字符进行正则匹配等过滤方法</li><li>在后端进行转义或者编码转换</li></ul><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><h3 id="DDOS简介"><a href="#DDOS简介" class="headerlink" title="DDOS简介"></a>DDOS简介</h3><p>DDOS全称 Distributed Denial of Service，中文意思为 “分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。</p><h3 id="DDOS分类"><a href="#DDOS分类" class="headerlink" title="DDOS分类"></a>DDOS分类</h3><h4 id="资源消耗类攻击"><a href="#资源消耗类攻击" class="headerlink" title="资源消耗类攻击"></a>资源消耗类攻击</h4><p><strong>资源消耗类DDOS是比较典型的DDOS攻击，通过大量请求消耗正常的带宽和协议栈处理资源的能力，从而达到服务端无法正常工作的目的。最具代表性的有Syn Flood、Ack Flood、UDP Flood</strong></p><h5 id="Syn-Flood"><a href="#Syn-Flood" class="headerlink" title="Syn Flood"></a>Syn Flood</h5><p>Syn Flood 是当前网络上常见的 DDoS 攻击，攻击者会向网络服务所在的端口发送大量伪造的大量的 SYN 包，并且缺少三次握手的最后一步握手 ACK 回复，造成目标服务器中的半连接队列被占满，从而阻止其他合法用户进行访问。</p><h5 id="Ack-Flood"><a href="#Ack-Flood" class="headerlink" title="Ack Flood"></a>Ack Flood</h5><p>在TCP连接建立后，所有的TCP报文都带有ACK标志位，服务器收到带有ACK标志位的数据包后悔进行查表检查该数据包所表示的连接四元组是否存在，来判断该数据包是否合法，如果不合法则需要回应RST包。攻击者在进行Ack Flood攻击时会发送大量非法的带有ACK标志位的数据包，而服务器需要进行查表和回应RST包，这就造成了服务器资源被占用，Ack Flood危害一般小于Syn Flood。</p><h4 id="服务消耗性攻击"><a href="#服务消耗性攻击" class="headerlink" title="服务消耗性攻击"></a>服务消耗性攻击</h4><p><strong>服务消耗性攻击主要是针对服务的特点进行精确定点打击，比如文件下载，数据检索等接口</strong></p><h5 id="Web的CC攻击"><a href="#Web的CC攻击" class="headerlink" title="Web的CC攻击"></a>Web的CC攻击</h5><p>CC(Challenge Collapsar)就是模拟多个用户，多少线程就是多少用户，不停地进行访问那些需要大量数据操作，就是需要大量CPU时间的页面，造成服务器资源的浪费，CPU长时间处于100%，永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。</p><h4 id="反射类攻击"><a href="#反射类攻击" class="headerlink" title="反射类攻击"></a>反射类攻击</h4><p>反射攻击也叫放大攻击，该类攻击以UDP协议为主，一般请求回应的流量远远大于请求本身流量的大小。攻击者通过流量被放大的特点以较小的流量带宽就可以制造出大规模的流量源，从而对目标发起攻击。</p><h3 id="防御方法-2"><a href="#防御方法-2" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>对流量进行检测与拦截</li><li>可以引申出nmap</li></ul><h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><p>nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（通过指纹判断）。</p><p>nmap扫描使用的数据包都是自行构建的，在流量层面有一定的特征，可以根据这些特征检测出是否有主机被nmap进行扫描，并及时阻断。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="CSRF简介"><a href="#CSRF简介" class="headerlink" title="CSRF简介"></a>CSRF简介</h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p><p>用大白话解释解释就是在你访问恶意站点A的时候，A让你去访问一次网站B，你在访问B的时候浏览器会自动带上你之前访问A所留下的cookie，这样恶意网站A就可以模拟用户的操作了。</p><h3 id="防御方法-3"><a href="#防御方法-3" class="headerlink" title="防御方法"></a>防御方法</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源策略是保障浏览器安全的一种重要的安全策略，他要求不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。而同源策略在我们进行Web开发时会导致跨域问题。</p><h4 id="Hash验证"><a href="#Hash验证" class="headerlink" title="Hash验证"></a>Hash验证</h4><p>在表单中增加对Cookie的Hash，来保证请求是由客户端发送的。但由于用户的Cookie可能被XSS攻击等方式获取到，所以这种方法无法完全保证安全。</p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>用户登录需要填写验证码，这个方案很不方便</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/morethink/p/8734103.html" target="_blank" rel="noopener">常见web攻击总结</a></li><li><a href="https://blog.csdn.net/qq_33945246/article/details/104417576" target="_blank" rel="noopener">DDoS 攻击详解1</a></li><li><a href="https://blog.csdn.net/weixin_44489066/article/details/87934156" target="_blank" rel="noopener">DDoS 攻击详解2</a></li><li><a href="https://www.cnblogs.com/rain-chenwei/p/9520240.html" target="_blank" rel="noopener">同源策略和跨域解决方案</a></li><li><a href="https://www.cnblogs.com/btgyoyo/p/6195897.html" target="_blank" rel="noopener">CSRF攻击原理以及防御</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在腾讯实习生面试的时候被问到Web安全，发现自己不是很了解，在此简单记录一下常见的一些Web安全知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>遥寄远方的碎碎念</title>
    <link href="https://liuyi12138.github.io/2020/05/03/%E9%81%A5%E5%AF%84%E8%BF%9C%E6%96%B9%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://liuyi12138.github.io/2020/05/03/%E9%81%A5%E5%AF%84%E8%BF%9C%E6%96%B9%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2020-05-03T08:22:44.000Z</published>
    <updated>2021-02-23T06:34:31.941Z</updated>
    
    <content type="html"><![CDATA[<p>爱情心理学课程作业——写给xx的一封情书！</p><a id="more"></a> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了大半天的时间去回忆与搜寻了咱俩自第一次见面起的点点滴滴，感觉心里有万千话语涌起，等到下笔时，却又不知道从何讲起了。我不是很喜欢情书这种形式，因为太多情话在两个人耳鬓厮磨时已经说尽了，无非就是我爱你，永远爱你，一辈子都爱你。但等到夜深人静时，再去仔细品味两个人之间的点点滴滴，又别是一番风味。于是乎，就有了这篇碎碎念，别嫌我啰嗦，我只是想把我记忆中的每一次的心动与每一抹温柔都说给你听。</p><h2 id="初闻"><a href="#初闻" class="headerlink" title="初闻"></a>初闻</h2><p>人们常说第一映像就决定了未来两个人会不会在一起，每当我回想起对你的第一映像，都会觉得十分魔幻，因为第一次知道有你这个人是在18级的新生群，我是学长，你是学妹。乍一听又是学长追到学妹的烂俗戏码，但实则我第一次见到你的照片的感触就是“嗷，这个学妹好漂亮，完全是我的菜，但我不敢去追。”，换成后来百日纪念时我记下的话语则是”世上有如此佳人，只怨年少读书甚少，做不得锦衣才子。”，至于为什么说魔幻，是因为当时我发誓不找学妹做女朋友的，毕竟我不想找一个没有恋爱经历的女孩子作为女朋友，我觉得恋爱中但凡有一个人不善于经营感情，往往这段恋情都不会太长久，并且从热恋褪去到分手的这段过程是极度曲折而痛苦的，就像我和我的前女友一样。但最终我对你的态度从不想相识，到认识就好，再到想做你的男朋友，这其中的转变真的曲折而奇妙，那种感觉能让我自己回味很久。</p><p>回到正题，当时一眼见你，就戳到了我心里，一下子在我心里勾勒出了一个邻家小妹的形象。仿佛就是我在<a href="https://liuyi12138.github.io/2018/04/09/念一个云白花清的人/">旧文</a>说道的那个水样的姑娘。于是，我开始想认识你，就只是认识认识，远远观望就行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200503171114.png" alt="xx与她的录取通知书" title>                </div>                <div class="image-caption">xx与她的录取通知书</div>            </figure><p>那时我还加了你们班群，在暑假里与你们班的小伙伴们打成一片，每天白天在实验室辛苦工作，晚上回到寝室就与你们视频或连麦，也就是那时，知道了你有男朋友诶，后来临近开学又知道你分手了，当然这对于当时的我来说也并不是多大的一个消息，因为当时觉得有个漂亮学妹做朋友就已经很不错了。日子就这么一天天过着，转眼间就到了咱俩初见的那一天了。</p><h2 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h2><p>初见的那天是18年九月初，是你们入学的日子，当时我是电信学院科协副主席，所以参与了迎新工作。我还记得是下午三四点的样子，天气很热，我在寝室楼下的迎新帐篷里写代码，修理着学生会的招新网站。那时你和你们班的另一位女生踏着小碎步跑过来，给了我一袋零食，我愣了一愣，一句谢谢刚说出口，你们就一路小跑溜掉了。第一次相见话都没说上，还没仔细看看你，就记得你蹦蹦跳跳的背影，很是可爱呢。</p><p>第一次说上话是赠书与你。当时你们要购置大一的课本，我就说把我的课本送给你吧，你也是相当不客气地就同意了。那天下着小雨，你来到我们寝室，小心翼翼地敲门，歪着脑袋只从门框里露出一个头，微微一笑，嘴角的小虎牙就跑出来了。我赶忙把一摞资料书帮你搬到楼下，下楼的过程中我们有说有笑，很是开心，即使那一天你和照片上长得不大一样。在楼下我提出帮你把书搬到你们寝室，被你拒绝了，你叫来了你的一个同学帮你搬书，你帮他打伞，两个人一起走回寝室。我独自一人上楼，突然感觉有些落寞，我就在想，是不是有点喜欢你了呢。</p><p>再到下一次见面是科协赛事部的面试，我好说歹说把你忽悠着报名了赛事部，并且安排着由我来面试你。面试的时候两个人都很紧张，我在装模作样问了你几个问题后就开始跟你拉家常，这时候才对你的性格与想法有了一个大致的了解。后来啊，学长和学妹的故事，同时又变成了部长和部员的故事。在咱俩在一起挺久之后，一次科创改革中，我们打算砍掉赛事部这个部门了，你知道后还难过了好久，我问你为什么难过，你委屈巴巴地说“你想啊，要是咱俩以后有了孩子，他问我们是怎么认识的，我可以告诉他，我和爸爸是在学生会的科协赛事部认识的。但你们却要把它砍掉，感觉自己的回忆就会消失了。”我一下子哑然，虽然赛事部最终还是没有了，但我开始知道原来xx这么在意回忆啊，后续有关回忆还有种种，我们慢慢说道。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200503215806.png" alt="第一次一起自习" title>                </div>                <div class="image-caption">第一次一起自习</div>            </figure><h2 id="相知与相恋"><a href="#相知与相恋" class="headerlink" title="相知与相恋"></a>相知与相恋</h2><p>此刻回想起第一次心动，大概是第一次约你出来喝奶茶讲故事。那时我正好从实验室回来，月色正美，就发消息约你出来喝奶茶，你也欣然接受了。两个人拎着奶茶在启明路上有一搭没一搭地聊着，聊得多的是你高中时的一些经历，渐渐地两个人聊到了感情。你给我讲了你和你的前男友，讲到你担心他太累，觉得这段感情肯定没结果所以选择了分手，我当时心里就暗暗在想，这个女孩子真的好潇洒，在感情中拿得起放得下。也正是这是，爱情的种子开始在我心里生根发芽。</p><p>两个人正式相恋是在国庆节，你回到家中，而我当时压力里很大，选择了一个人出游郑州，在郑州的几天里我卸载了QQ，放下了很多事情，专心放松身心，后来渐渐地也不知道为什么，开始每天和你打电话，这是我第一次知道原来两个人打电话能打四五个小时之久。10月7日回到学校后，我俩去看了电影，很自然而然地，两个人就走到了一起。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200503215123.png" alt="Ly&Xx" title>                </div>                <div class="image-caption">Ly&Xx</div>            </figure><h2 id="浪漫与温柔"><a href="#浪漫与温柔" class="headerlink" title="浪漫与温柔"></a>浪漫与温柔</h2><p>xx你总是很懊恼，懊恼当时我俩没在一起的时候没多吊我一段时间，导致我没有怎么追你就得手了；同时你又总是很埋怨，埋怨我没有一个正式的表白，感觉恋爱少了这两个阶段就不够完整。我也常常笑道，不如你就甩了我，我再追你一次呗。其实两个人在一起的时间里，有着太多浪漫与温柔，如果担心以后会忘记，不妨把它记录下来，若是你不愿意去做记录，那就我来吧。</p><ul><li><p>2019年2月14日，咱俩在一起的第一个情人节，我记得那是大年初十，我初七回到学校，收拾好东西后就萌生念头想去找你，于是我买了第二天晚上的火车票，因为没钱所以买的都是坐票，在辗转了五个多小时之后终于在深夜到达了你所在的城市，同样是因为没钱，住了一个很破的宾馆，并且订了第二天晚上11点的火车回武汉，因为可以少住一晚上宾馆。我至今还记得那天晚上看你酸了别人好久之后，漫不经心地告诉你我到你家了，你当时整个人都炸了，激动与兴奋从电话里溢了出来，我当时就感觉十分满足，感觉一切努力都是值得的。</p></li><li><p>2019年2月17日，你回到武汉，而我经过了16日一整天的休息之后正好可以去接你。这次我带上了为你准备了三个月的生日礼物，你是早上7点到武汉的火车，所以我5点就早早起床了，骑上了租八戒去往光谷赶早班地铁，最终到达火车站与你汇合。时隔两天你又一次高兴地叫出了声，因为我给你织了一条围巾。从上一年的期末考试周开始，每天晚上回到寝室都一心一意地织半小时围巾，虽然很辛苦，但是心里是暖的。当天晚上给你准备了一个小蛋糕、一只香薰蜡烛、一瓶红酒，我单膝跪地拿出了施华洛世奇的项链，给你补上了你期待已久的表白：zxx，做我女朋友好吗？</p></li><li><p>2019年10月7日，我们的一周年纪恋日，收到了xx送的一套衣服，送给xx了我们的周年纪念册，是以照片的形式记录了我们一年以来的点点滴滴。在纪念册的最后一页，是一个进度条，1/80。和xx约定好了，以后每年我们都轮番做纪念册，每年一本，直到老去，想想都觉得浪漫呢。</p></li></ul><p>除此之外还有太多太多美妙的回忆，我记得在武汉动物园那个活泼俏皮的你；我记得在东湖樱园那个激动兴奋的你；我记得在江汉路那个性感撩人的你；我记得江滩边上那个温婉可人的你。我记得太多太多两个人在一起的美好瞬间，从邂逅到相爱，从现在到永远。</p><p>当然，我也常常忘记一些重要的事情，有时也会伤到xx的心，但我希望xx知道，虽然我不善言辞不太会哄人，虽然我时常没法看透xx的想法，虽然有时我会很固执不听劝阻，也许作为一个男朋友我可能表现得并不如人意，但我一直在努力，努力着让自己变得更好，努力着为xx做更多，努力着让咱俩一直走下去。</p><p><img src="https://gitee.com/know_the_emperor/picture/raw/master/20200503215556.png" alt="左图为情人节说说，右图为xx为我庆生"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇碎碎念前前后后花了近乎一天的时间来完成(算上我打游戏摸鱼的时间)，写得很啰嗦，更多的是在写自己一直以来想要记录的点点滴滴，顺便完成了“爱情心理学”课程的作业，当然最终这份作业也会公开发布在我的博客上，最希望的还是xx能看到，我后续也会一直记录自己与xx的感情故事，如果不嫌弃，也希望有人能一直关注，毕竟甜甜的恋爱谁会不喜欢呢~</p><p>在本文中我也提到了一些自己以前写的小段文字，大家可以如果喜欢也可以看看：</p><ul><li><p><a href="https://liuyi12138.github.io/2018/04/09/念一个云白花清的人/">高中旧文：念一个云白花清的人</a></p></li><li><p><a href="https://liuyi12138.github.io/2019/01/27/春天的十八个瞬间/">百日纪念：春天的十八个瞬间</a></p></li><li><a href="https://liuyi12138.github.io/2018/10/06/城游－郑州/">国庆出游：郑州——三日谈</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爱情心理学课程作业——写给xx的一封情书！&lt;/p&gt;
    
    </summary>
    
    
      <category term="文学" scheme="https://liuyi12138.github.io/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="心声" scheme="https://liuyi12138.github.io/tags/%E5%BF%83%E5%A3%B0/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理——编程语言(主C++)</title>
    <link href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(%E4%B8%BBC++)/"/>
    <id>https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(%E4%B8%BBC++)/</id>
    <published>2020-04-02T15:11:16.000Z</published>
    <updated>2021-02-23T06:34:31.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一下面试以来遇到的编程语言相关问题及解答</strong><br><a id="more"></a> </p><h2 id="C-相关问题及解答"><a href="#C-相关问题及解答" class="headerlink" title="C++相关问题及解答"></a>C++相关问题及解答</h2><h3 id="简述智能指针及其实现原理"><a href="#简述智能指针及其实现原理" class="headerlink" title="简述智能指针及其实现原理"></a>简述智能指针及其实现原理</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，有时候没有delete就可能会造成内存泄露的情况，此C++ 引用了智能指针。</p><p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。</p><p>一般实现智能指针可以采用辅助类的方式，需要实现构造，析构，拷贝构造，以及对一些解引用运算符。</p><h3 id="简述C-多态及其实现原理"><a href="#简述C-多态及其实现原理" class="headerlink" title="简述C++多态及其实现原理"></a>简述C++多态及其实现原理</h3><p><strong>涉及公司：阿里云实习生、腾讯实习生</strong></p><h4 id="多态及其实现条件"><a href="#多态及其实现条件" class="headerlink" title="多态及其实现条件"></a>多态及其实现条件</h4><p>c++中的多态就是在父类的函数前加上virtual关键字，在子类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是子类，就调用子类的函数，如果对象类型是父类，就调用父类的函数。</p><p>多态的实现需要两个条件：</p><ul><li>虚函数重写，设置不同的状态</li><li>对象调用虚函数时必须是指针或者引用</li></ul><h4 id="虚函数与重写"><a href="#虚函数与重写" class="headerlink" title="虚函数与重写"></a>虚函数与重写</h4><ul><li>虚函数是带有virtual关键字的成员函数</li><li>子类有个和父类完全相同(函数名,形参,返回值都相同,协变和析构函数除外)的虚函数,就称子类虚函数重写父类虚函数 </li></ul><h4 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h4><ul><li>多态是用虚函数表来实现的</li><li>有虚函数的类都会生成一个虚函数表，在编译的时候使用</li><li>虚函数表是一个存储虚函数地址的数组</li><li>生成子类的虚函数表需要经过一下步骤<ul><li>将父类的虚函数表拷贝</li><li>将子类中重写的虚函数覆盖掉父类中的虚函数</li><li>如果有新增加的虚函数则放到表的最后</li></ul></li><li>在调用时会根据对象中的虚表指针来找实际应该调用的函数</li></ul><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul><li>虚函数和普通函数一样在代码段,虚表在只读常量区</li><li>inline函数(内联函数)没有地址,无法放到虚函数表中</li><li>静态成员不能是虚函数，因为静态成员函数没有this指针,因为有this指针才能访问到虚表指针,有虚表指针才能找到虚表从而调用实际应该调用的函数</li><li>构造函数不能是虚函数，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的</li><li>析构函数可以是虚函数，并且最好把基类的析构函数定义成虚函数，当父类指针指向子类对象时,如果析构函数不是虚函数,析构就只会释放父类对象,造成内存泄漏</li><li>普通对象访问普通函数和访问虚函数是一样快的(不会触发多态);指针对象或者是引用对象，调用普通函数更快一些，因为构成了多态，运行时调用虚函数要先到虚函数表中去查找。这样然后才拿到韩式的地址，这样就不如直接可以拿到函数地址的普通函数快。</li></ul><h3 id="C-中的extern-C"><a href="#C-中的extern-C" class="headerlink" title="C++中的extern C"></a>C++中的extern C</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用(只是声明，不分配内存)</p><p>与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p><p>被extern “C”修饰的变量和函数是按照C语言方式编译和链接的</p><p>之所以要如此是因为编译器在将C++ 源代码编译成目标文件时，会将函数和变量的名称进行修饰，形成符号名，目标文件中所使用的符号名就是修饰后名称，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数。因此有时候在调用一些库函数的时候，会出现无法链接的情况(因为函数签名不同)所以对于C++ 来说，必须使用extern “C”来声明这些函数。</p><h3 id="为什么会有内存泄漏，怎么检测，怎么避免"><a href="#为什么会有内存泄漏，怎么检测，怎么避免" class="headerlink" title="为什么会有内存泄漏，怎么检测，怎么避免"></a>为什么会有内存泄漏，怎么检测，怎么避免</h3><p><strong>涉及公司：拼多多实习生</strong></p><p>TODO</p><h3 id="C-11有哪些新特性"><a href="#C-11有哪些新特性" class="headerlink" title="C++11有哪些新特性"></a>C++11有哪些新特性</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>TODO</p><h3 id="右值引用解决了什么问题"><a href="#右值引用解决了什么问题" class="headerlink" title="右值引用解决了什么问题"></a>右值引用解决了什么问题</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>TODO</p><h2 id="Java相关问题及解答"><a href="#Java相关问题及解答" class="headerlink" title="Java相关问题及解答"></a>Java相关问题及解答</h2><h3 id="简述JAVA的GC机制"><a href="#简述JAVA的GC机制" class="headerlink" title="简述JAVA的GC机制"></a>简述JAVA的GC机制</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录一下面试以来遇到的编程语言相关问题及解答&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理——Linux&amp;编译原理</title>
    <link href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94Linux&amp;%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94Linux&amp;%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-02T15:11:16.000Z</published>
    <updated>2021-02-23T06:34:31.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一下面试以来遇到的Linux&amp;编译原理相关问题及解答</strong><br><a id="more"></a> </p><h2 id="Linux相关问题及解答"><a href="#Linux相关问题及解答" class="headerlink" title="Linux相关问题及解答"></a>Linux相关问题及解答</h2><h3 id="简述fork创建新进程的机制"><a href="#简述fork创建新进程的机制" class="headerlink" title="简述fork创建新进程的机制"></a>简述fork创建新进程的机制</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="简述select和epoll的区别"><a href="#简述select和epoll的区别" class="headerlink" title="简述select和epoll的区别"></a>简述select和epoll的区别</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>TODO</p><hr><h2 id="编译原理相关问题及解答"><a href="#编译原理相关问题及解答" class="headerlink" title="编译原理相关问题及解答"></a>编译原理相关问题及解答</h2><h3 id="静态链接和动态链接的区别"><a href="#静态链接和动态链接的区别" class="headerlink" title="静态链接和动态链接的区别"></a>静态链接和动态链接的区别</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="一个C语言程序编译生成机器码的过程"><a href="#一个C语言程序编译生成机器码的过程" class="headerlink" title="一个C语言程序编译生成机器码的过程"></a>一个C语言程序编译生成机器码的过程</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>这个过程主要分为编译、链接、装载三个步骤，在编译过程中，C语言程序会被编译为汇编代码，再进一步被转换为机器码；在链接过程中，会将该程序调用的各种库与程序链接起来生成一个可执行文件，在装载过程中会去替换机器码中的一些相对地址吗，把它们替换为链接库的绝对地址，最后这个程序就可以运行了。</p><h3 id="编译整个过程有哪些具体的阶段"><a href="#编译整个过程有哪些具体的阶段" class="headerlink" title="编译整个过程有哪些具体的阶段"></a>编译整个过程有哪些具体的阶段</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="词法分析语法分析"><a href="#词法分析语法分析" class="headerlink" title="词法分析语法分析"></a>词法分析语法分析</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录一下面试以来遇到的Linux&amp;amp;编译原理相关问题及解答&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理——数据库</title>
    <link href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-04-02T15:11:16.000Z</published>
    <updated>2021-02-23T06:34:31.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一下面试以来遇到的数据库相关问题及解答</strong><br><a id="more"></a> </p><h3 id="简述关系型数据库与菲关系形数据库的区别与联系"><a href="#简述关系型数据库与菲关系形数据库的区别与联系" class="headerlink" title="简述关系型数据库与菲关系形数据库的区别与联系"></a>简述关系型数据库与菲关系形数据库的区别与联系</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="简述数据库的事务"><a href="#简述数据库的事务" class="headerlink" title="简述数据库的事务"></a>简述数据库的事务</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录一下面试以来遇到的数据库相关问题及解答&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="数据库" scheme="https://liuyi12138.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理——计算机网络</title>
    <link href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-04-02T15:11:16.000Z</published>
    <updated>2021-02-23T06:34:31.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一下面试以来遇到的计算机网络相关问题及解答</strong><br><a id="more"></a> </p><h3 id="简述从输入网址到浏览器显示的过程"><a href="#简述从输入网址到浏览器显示的过程" class="headerlink" title="简述从输入网址到浏览器显示的过程"></a>简述从输入网址到浏览器显示的过程</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="简述HTTPS的建立过程"><a href="#简述HTTPS的建立过程" class="headerlink" title="简述HTTPS的建立过程"></a>简述HTTPS的建立过程</h3><p><strong>涉及公司：阿里云实习生、腾讯实习生</strong></p><p>TODO</p><h3 id="简述对Cookie的理解"><a href="#简述对Cookie的理解" class="headerlink" title="简述对Cookie的理解"></a>简述对Cookie的理解</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="简述DNS协议的请求过程"><a href="#简述DNS协议的请求过程" class="headerlink" title="简述DNS协议的请求过程"></a>简述DNS协议的请求过程</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>TODO</p><h3 id="tcp包里的校验和有什么用？是怎么实现的？"><a href="#tcp包里的校验和有什么用？是怎么实现的？" class="headerlink" title="tcp包里的校验和有什么用？是怎么实现的？"></a>tcp包里的校验和有什么用？是怎么实现的？</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>TODO</p><h3 id="为什么tcp是三次握手，而不是两次？"><a href="#为什么tcp是三次握手，而不是两次？" class="headerlink" title="为什么tcp是三次握手，而不是两次？"></a>为什么tcp是三次握手，而不是两次？</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>TODO</p><h3 id="tcp过程中有哪保障数据包数据有效的操作"><a href="#tcp过程中有哪保障数据包数据有效的操作" class="headerlink" title="tcp过程中有哪保障数据包数据有效的操作"></a>tcp过程中有哪保障数据包数据有效的操作</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录一下面试以来遇到的计算机网络相关问题及解答&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="计算机网络" scheme="https://liuyi12138.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试问题整理——操作系统</title>
    <link href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-02T15:11:16.000Z</published>
    <updated>2021-02-23T06:34:31.941Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一下面试以来遇到的操作系统相关问题及解答</strong><br><a id="more"></a> </p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="简述进程切换的流程"><a href="#简述进程切换的流程" class="headerlink" title="简述进程切换的流程"></a>简述进程切换的流程</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>如果想要从A进程切换到B进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当CPU在用户进程手上的时候，他可以选择一直执行，不让出CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用CPU的A进程，才能切换到B进程。</p><p>由于从用户态切换到内核态的时候，CPU是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。</p><p>这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB(进程控制块)等。</p><h3 id="进程在地址空间中会划分为哪些区域"><a href="#进程在地址空间中会划分为哪些区域" class="headerlink" title="进程在地址空间中会划分为哪些区域"></a>进程在地址空间中会划分为哪些区域</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>这个问题在我之前的工作中其实还是有所涉及的，我来简单讲一下把文件加载到内存中的一个过程，以Window平台为例吧，PE文件我比较熟，在PE文件中，有一个叫节的概念，节是PE文件中存放代码和数据的基本单元，用以存储不同类型的数据，比如data节、code节等，一个节的所有原始数据必须加载到连续的内存空间里，这也就造成了在虚拟地址空间中的区块划分。</p><p>在虚拟地址空间中会按照节划分为代码段、数据段、未初始化的数据段以及堆栈这些区块。</p><h3 id="栈与堆有什么区别"><a href="#栈与堆有什么区别" class="headerlink" title="栈与堆有什么区别"></a>栈与堆有什么区别</h3><p><strong>涉及公司：阿里云实习生、拼多多实习生</strong></p><p>我们常说堆栈堆栈，其实堆栈是两个不同的概念，最直观的理解，堆是由用户来控制的，我们可以使用malloc这种命令来在堆中申请内存，而栈是由操作系统控制的，在栈中存储的是这个进程的局部变量等，比如我们用malloc来申请一块内存，内存本身是在堆中开辟的，而指向这块内存的指针存储在栈中。</p><h3 id="操作系统为什么分内核态和用户态，这两者之间如何切换"><a href="#操作系统为什么分内核态和用户态，这两者之间如何切换" class="headerlink" title="操作系统为什么分内核态和用户态，这两者之间如何切换"></a>操作系统为什么分内核态和用户态，这两者之间如何切换</h3><p><strong>涉及公司：拼多多实习生</strong></p><p>因为在CPU的指令中，有一些是非常危险的，比如清理内存、设置时钟等，如果所有的程序都能使用，就可能造成系统的崩溃，所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统使用。CPU的特权级别有四级，从Ring0到Ring3，正常使用时一般只有两级，即用户态的Ring3和内核态的Ring0。Ring3状态不能访问Ring0的地址空间，包括代码和数据。</p><p><strong>用户态切换到内核态的三种方式</strong></p><ul><li>系统调用（系统调用是通过软中断实现的）</li><li>中断（硬）</li><li>异常</li></ul><h3 id="malloc的实现机制"><a href="#malloc的实现机制" class="headerlink" title="malloc的实现机制"></a>malloc的实现机制</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>malloc本质上是维护了一个内存空闲链表，每次我们调用malloc申请空间的时候，链表就会从头开始遍历，来寻找一个合适的空闲内存空间，然后把这个空间给分割开，一部分分配给用户，另一部分继续标注为空闲，而当没有足够大的空闲块时，malloc就会通过系统调用来申请更多的内存块。而我们调用free来释放内存块的时候，该内存块就会回到链表中，并且相邻的内存块会被合并。</p><p>搜索空闲块的算法主要有首次适配、下一次适配、最佳适配，首次适配即第一次找到足够大的内存块就分配，但这样会产生很多的内存碎片，也因此第二次适配被提出来缓解这个问题。另一个极端则是最佳适配，即找到一块刚好大于我们所需内存大小的内存块，这种做法一方面耗时长，另一方面也会产生一些极小的内存碎片。<br>这两种思路可以看出是在性能和空间利用率上寻找一个平衡点，在工程中实际上有很多这种没有完美解决方案，只能寻找平衡的问题。</p><h3 id="虚拟地址怎么映射到物理地址"><a href="#虚拟地址怎么映射到物理地址" class="headerlink" title="虚拟地址怎么映射到物理地址"></a>虚拟地址怎么映射到物理地址</h3><p><strong>涉及公司：阿里云实习生、腾讯实习生</strong></p><p>虚拟地址的构成为页目录索引(10位)+页表索引(10位)+表内偏移(12位)</p><p>以win32系统为例，页目录和页表都为1024个，页表大小为4KB，一共是4G的虚拟内存空间</p><p>而从虚拟地址映射到物理地址实际上就是通过页目录和页表的索引找到内存页。</p><p>在页表项中有一位标志位，用来标识包含此数据的页是否在物理内存中，如果在的话，就直接做地址映射，否则，抛出缺页中断，操作系统会把次数据页调入内存。</p><h3 id="socket编程中怎么处理并发请求"><a href="#socket编程中怎么处理并发请求" class="headerlink" title="socket编程中怎么处理并发请求"></a>socket编程中怎么处理并发请求</h3><p><strong>涉及公司：阿里云实习生、腾讯实习生</strong></p><p>对多线程的处理与单线程不同的位置在于各个不同的进程可能会访问相同的资源，如果是对资源进行修改的话，就需要用到锁</p><h3 id="简述IO多路复用"><a href="#简述IO多路复用" class="headerlink" title="简述IO多路复用"></a>简述IO多路复用</h3><p><strong>涉及公司：阿里云实习生、腾讯实习生</strong></p><p>Linux的IO访问通常是先将数据拷贝到操作系统的内核缓冲区，然后再从内核缓冲区拷贝到应用程序的地址空间。在这两个阶段中，有不同的IO方式，主要分为阻塞IO、非阻塞IO、异步IO以及IO多路复用。</p><p>阻塞IO即当数据还未准备好，也就是数据还在操作系统的内核缓存区时，用户进程就会一直阻塞，等待数据从操作系统内核缓冲区拷贝到应用程序的地址空间。阻塞IO在这两个阶段都是阻塞的。</p><p>非阻塞IO则是如果数据还没准备好，操作系统会给应用程序返回一个error，并不阻塞应用程序，而一般应用程序会持续询问内核数据是否准备好，所以从另一个角度来说也是阻塞的。</p><p>而异步IO才是真正的不阻塞，当用户程序发起read后，操作系统会立即进行回复，这样用户程序就可以去做其他事情，当数据被拷贝到用户程序的地中空间后，操作系统会给用户程序发一个信号，而用户程序可以采用回调函数的方式对这个信号进行响应。</p><p>IO多路复用则是允许一个程序同时等待多个文件描述符，当任意一个文件描述符就绪，select函数就会返回，当然IO多路复用在本质上还术语阻塞IO，只不过可以同时进行多个IO操作。</p><p>Linux的IO多路复用机制中有select、poll、epoll三种，<br>select和poll的时间复杂度都是O(n),因为他们都是在对IO列表进行轮询，不同点在于select能监视的文件描述符有上限，一般为1024，当然这个是在Linux内核中进行的宏定义，是可以修改的，而poll是基于链表来存储的，所以没有这个上限。<br>而epoll是基于事件驱动的，所以不需要轮询，epoll会把事件和每一个IO流对应起来。并且epoll是通过一块共享内存来实现内核空间和用户空间的通信的，比起select和poll的大量数据拷贝效率更高。<br>不过select的优点在于兼容不同的操作系统，而poll和epoll都只能在linux上使用。</p><h3 id="简述进程通信的各种方法"><a href="#简述进程通信的各种方法" class="headerlink" title="简述进程通信的各种方法"></a>简述进程通信的各种方法</h3><p><strong>涉及公司：腾讯实习生</strong></p><p>进程间通信的方式通常分为管道、系统IPC、套接字三种，其中管道有无名管道、命名管道，系统IPC有消息队列、信号、共享内存</p><ul><li>无名管道的本质是在内核缓冲区的环形队列，每次读取数据后缓冲区都会移动，并且无名管道只能在有亲缘关系的进程间使用</li><li>命名管道则以文件的形式存在，由于有一个路径名，使用没有亲缘关系的进程间也可以使用命名管道</li><li>消息队列是存放在内核中的消息链表，具有特定的格式，支持多种数据类型，且允许多个进程进行读写</li><li>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，并且信号可以在用户空间进程和内核之间直接交互</li><li>共享内存顾名思义就是两个进行对同一块内存进行读写，是最快的IPC形式，但不适合大量的数据传输</li><li>Socket是对TCP/IP协议族的封装，不仅可以用于本机上的进程间通信，更多的被用于网络通信中</li></ul><h2 id="进程线程管理"><a href="#进程线程管理" class="headerlink" title="进程线程管理"></a>进程线程管理</h2><h3 id="进程的互斥与同步"><a href="#进程的互斥与同步" class="headerlink" title="进程的互斥与同步"></a>进程的互斥与同步</h3><p>在操作系统中，进程是占有资源的最小单位，对于那种只能同时被一个进程持有的资源我们称为临界资源，对于临界资源的访问，必须是互斥的。（对于；临界资源的访问过程分为：进入区、临界区、退出区、剩余区）</p><p>而进程之间访问临界资源时可以构成同步与互斥两种关系，同步即两个进程的资源访问必须是先后关系，比如经典的生产者消费者问题，读者写着问题。而互斥则是两种在进行资源抢到，比如购票问题。</p><p>通常在软件层面可以使用替换算法来实现，即每个进程持有一个标志，每次当使用资源时则将自己的标志与资源的标志互换，如果在互换的过程中发现自己获得的标志是正在使用的状态，则在此循环等待。这种方法的缺点在于每个进程都需要进行循环等待，比较低效。所以一般是通过硬件层面的信号量即PV操作来实现进程的临界资源管理。</p><h3 id="死锁的解决方法"><a href="#死锁的解决方法" class="headerlink" title="死锁的解决方法"></a>死锁的解决方法</h3><p><strong>涉及公司：阿里云实习生</strong></p><p>死锁的产生是在这样一种环境中：比如我们有两个进程AB，他们都需要资源1和资源2，当进程A持有资源1，进线程B持有资源2的时候，他们都需要对方手上的进程，而一般操作系统又不允许抢占，这个时候就发生了死锁。</p><p>从这个例子中其实可以总结出死锁的几个必要条件：</p><ul><li>1.一个资源只能被一个进程所占有，不能共享</li><li>2.一个线程请求资源失败时，它会等待而不是释放</li><li>3.一个线程在释放资源之前其他进程不能抢夺资源</li><li>4.循环等待</li></ul><p>从死锁产生的原因未明可以设计一些方法去避免死锁的发生</p><ul><li>1.静态分配资源，一开始就把一个进程所需的全部资源都分配给它，但这样会降低资源的使用效率</li><li>2.允许抢占，需要设置进程的不同优先级，高优先级的进程可以抢占低优先级的进程的资源</li><li>3.把资源进行编号，申请资源必须按照资源的编号顺序来申请</li></ul><p>如果死锁已经发生了，就需要去解开死锁，其本质思想就是分配资源打破循环等待</p><ul><li>1.可以运行抢占，从一个或多个进程中抢出资源来给其他进程</li><li>2.也可以终止一些进程，来达到释放资源的目的</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul><li>先来先服务调度算法<ul><li>对长作业比较有利，但对短作业不利</li></ul></li><li>时间片轮转调度法<ul><li>每个进程只能运行一个时间片</li><li>时间片的大小对系统性能的影响很大，时间片过大就和先来先服务算法一样，时间片过小会导致进行切换开销大</li></ul></li><li>短作业优先调度算法<ul><li>对长作业不利，不能保证紧迫性作业（进程）被及时处理</li></ul></li><li>最短剩余时间优先<ul><li>允许抢占，总是选择预期剩余时间最短的进程</li></ul></li><li>高响应比优先调度算法<ul><li>R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间），选择R最大的进行执行</li></ul></li><li>优先级调度算法<ul><li>进程优先级可以分为静态优先级和动态优先级</li></ul></li><li>多级反馈队列调度算法<ul><li>分为多个队列，每个队列中按时间片轮转调度算法来进行进程调度，每一级的队列时间片大小也不一样，如果进行在第一个队列的时间片内没有完成，就会进入第二个队列，以此类推，只有当第一个队列为空才执行第二个队列的进行</li><li>短作业有限且长作业不会太长时间不被处理</li></ul></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul><li>先来先服务算法（FCFS）<ul><li>根据进程请求访问磁盘的先后次序进行调度</li><li>优点是公平、简单</li><li>缺点是吞吐量低，寻道时间长</li></ul></li><li>最短寻道时间优先算法（SSTF）<ul><li>访问与当前磁头所在的磁道距离最近的磁道</li><li>优点是可以得到比较好的吞吐量</li><li>缺点是对内外边缘磁道的请求将会被无限延迟</li></ul></li><li>扫描算法（SCAN）电梯调度算法<ul><li>优先考虑磁头当前的移动方向，再考虑欲访问的磁道与当前磁道的距离</li><li>优点是避免了饥饿现象的出现</li><li>缺点是两侧磁道被访问的频率仍低于中间磁道</li></ul></li><li>循环扫描算法（CSCAN）<ul><li>在SCAN算法的基础上，磁头只单向移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道</li><li>优点是访问请求均匀分布</li></ul></li></ul><h3 id="页面调度算法"><a href="#页面调度算法" class="headerlink" title="页面调度算法"></a>页面调度算法</h3><ul><li>先进先出调度算法（FIFO，First In First Out）</li><li>最近最少使用算法(LFU, Least Frequently Used)</li><li>最近最久未使用算法（LRU，Least Recently Used）</li><li>时钟置换算法——为每一页设置访问位和修改位，将内存中所有页面通过连接指针接成循环队列，当页面被访问时访问位置1，被修改则修改位置1，每次淘汰时，从指针当前位置开始循环遍历，第一次寻找访问位和修改位都为0的页面，如果没有则将扫描过的节点访问位为1的置为0，找到第一个访问位为0的将其淘汰。这个算法的原则就的在LRU的基础上偏向于淘汰未被修改的页面。</li><li>最佳置换算法——理想算法，找一个未来最长时间才会被访问的页面进行淘汰。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录一下面试以来遇到的操作系统相关问题及解答&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="操作系统" scheme="https://liuyi12138.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>个人经历整理</title>
    <link href="https://liuyi12138.github.io/2020/03/31/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/"/>
    <id>https://liuyi12138.github.io/2020/03/31/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/</id>
    <published>2020-03-31T15:44:16.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p><strong>昨天第一次投出了简历，目标腾讯，可能最近就要开始面试了，所以对个人的项目经历及获奖经历进行一个整理</strong></p><a id="more"></a> <h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><h3 id="深信服安全邮箱APP开发"><a href="#深信服安全邮箱APP开发" class="headerlink" title="深信服安全邮箱APP开发"></a>深信服安全邮箱APP开发</h3><h4 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h4><p>一个与深信服公司合作的开发项目，我们这边负责整个邮箱APP的开发，深信服公司负责给APP加上一层安全系统。我主要负责的是底层开发，用的是C++，但其实那时候是第一次接触面向对象语言，自己比较菜，所以做的是边缘一点的模块，最后在语言方面其实并没有学到多少。在这个项目里面更多的是学到了企业级项目的管理与沟通，以及接触到了代码规范，团队开发中的代码管理，接触到了一些简单的设计模式，测试驱动开发，以及了解到了当时看到学长们在做的一些并发程序设计。</p><p>总而言之在这个项目里，我自己coding能力并没有很显著的提升，但自己这种稍微大一点的工程有了更强的把握能力，在这个项目里学到的这些在我之后领导小组做网站开发的时候都有用到。</p><h4 id="涉及的知识点"><a href="#涉及的知识点" class="headerlink" title="涉及的知识点"></a>涉及的知识点</h4><ul><li>项目管理与沟通<ul><li>每日站会、日报周报、996</li><li>架构&gt;开发、前后端沟通：API文档(引申到自己领导小组进行网站开发)</li></ul></li><li>代码规范<ul><li>函数/类名驼峰式命名，变量下划线命名</li><li>局部变量、私有变量加前缀等等</li></ul></li><li>代码管理(Git)<ul><li>深信服自己搭建gitlab/网安项目组用svn</li><li>静态审查</li></ul></li><li>设计模式</li><li>测试驱动开发(TDD)</li><li>并发程序设计</li></ul><h3 id="启亦伏安表APP开发"><a href="#启亦伏安表APP开发" class="headerlink" title="启亦伏安表APP开发"></a>启亦伏安表APP开发</h3><h4 id="项目简介-1"><a href="#项目简介-1" class="headerlink" title="项目简介"></a>项目简介</h4><p>这个项目能说的就不多了，这是和武汉启亦电子有限公司合作的一个软硬结合的项目，目的是做一个能在他们专用的pad上运行三相电流伏安表，由于我在这个项目是临时抽调，待的时间不长，其中还有一个月出国交流了。在这个项目组的时间里主要就是Android入门，主要工作就做了一个Word报表的生成，这个就比较有意思了，这是我第一次以一个程序员的角度去看待我们常用的Word这个工具，当时其实还挺惊讶，原来word文档的组织结构跟一个网页是相似的。</p><h4 id="涉及的知识点-1"><a href="#涉及的知识点-1" class="headerlink" title="涉及的知识点"></a>涉及的知识点</h4><ul><li>Android开发(现在不会了)</li><li>Java操作Word</li></ul><h3 id="网络安全系统构建"><a href="#网络安全系统构建" class="headerlink" title="网络安全系统构建"></a>网络安全系统构建</h3><h4 id="项目简介-2"><a href="#项目简介-2" class="headerlink" title="项目简介"></a>项目简介</h4><p>从大三上到现在我就一直都在一个做网络安全的项目组，这个项目是一个研究型的项目，他是一个国家级项目的子课题，我们主要是要构建一套流量的检测与防御系统，还有其他子课题在研究如何去攻击，两边互为矛盾，互相砥砺。我在这个项目中主要做的是逆向工程，比较底层，平时主要接触的是汇编和C，但其实在这个项目组基本就没怎么写过代码，主要以调研与分析为主。在这个项目组里面有意思的工作也不太多，emmm，可能有意思一点的就在于一开始学PE的时候做了一个新人任务，如何用最小的空间去完成一个helloworld程序，当时主要用到方法是裁剪资源表以及利用Dos头里的空间等，以及还考虑过去做字节压缩，但最后没写出来。然后平时的工作有时还会涉及到部分计算机网络的知识。</p><h4 id="涉及的知识点-2"><a href="#涉及的知识点-2" class="headerlink" title="涉及的知识点"></a>涉及的知识点</h4><ul><li>逆向工程</li><li>PE文件</li><li>一些骚操作(HelloWorld裁剪)</li><li>计算机网络</li></ul><h3 id="华中赛数模——库存补单及销量预测"><a href="#华中赛数模——库存补单及销量预测" class="headerlink" title="华中赛数模——库存补单及销量预测"></a>华中赛数模——库存补单及销量预测</h3><ul><li>时间序列分解</li></ul><h3 id="求是杯——鸭梨管家心理压力检测仪"><a href="#求是杯——鸭梨管家心理压力检测仪" class="headerlink" title="求是杯——鸭梨管家心理压力检测仪"></a>求是杯——鸭梨管家心理压力检测仪</h3><ul><li>项目原理</li></ul><h3 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h3><ul><li>express+vue</li><li>跨域问题</li></ul><hr><h2 id="自我介绍初稿"><a href="#自我介绍初稿" class="headerlink" title="自我介绍初稿"></a>自我介绍初稿</h2><p>面试官你好，我是来自华中科技大学Dian团队的一名17级本科生，我叫刘羿，目前就读于电子信息与通信工程学院，基于项目的信息类专业教育实验班，我的意向岗位是后台开发。在这里我就先简单介绍一下我在大学三年的时间里的一些项目经历以及获奖经历，以便面试官对我有一个初步的了解。</p><p>我在大一下参与了与深信服公司合作的安全邮箱APP的开发，在这个项目组我们团队这边负责整个邮箱APP的开发，深信服公司负责给APP加上一层安全系统。在这项目中我主要负责的是底层开发，用的是C++，但其实那时候是第一次接触面向对象语言，自己比较菜，所以做的是边缘一点的模块，最后在语言方面其实并没有学到多少。在这个项目里面更多的是学到了企业级项目的管理与沟通，以及接触到了代码规范，团队开发中的代码管理，接触到了一些简单的设计模式，测试驱动开发，以及了解到了当时看到学长们在做的一些并发程序设计。</p><p>总而言之在这个项目里，我自己coding能力并没有很显著的提升，但自己这种稍微大一点的工程有了更强的把握能力，在这个项目里学到的这些在我之后领导小组做网站开发的时候都有用到。</p><p>这个是我大一下到大二上做的一个项目，在大二下就没有做项目了，主要是参加了几个比赛，这个我待会再讲。大三上的时候参与了启亦伏安表APP开发，这个项目能说的其实并不多，这是和武汉启亦电子有限公司合作的一个软硬结合的项目，目的是做一个能在他们专用的pad上运行三相电流伏安表，由于我在这个项目是临时抽调，待的时间不长，其中还有一个月出国交流了。在这个项目组的时间里主要就是Android入门，主要工作就做了一个Word报表的生成，这个就还比较有意思，这是我第一次以一个程序员的角度去看待我们常用的Word这个工具，当时其实还挺惊讶，原来word文档的组织结构跟一个网页是相似的。</p><p>从大三上到现在我就一直都在一个做网络安全的项目组，这个项目是一个研究型的项目，他是一个国家级项目的子课题，我们主要是要构建一套流量的检测与防御系统，还有其他子课题在研究如何去攻击，两边互为矛盾，互相砥砺。我在这个项目中主要做的是逆向工程，比较底层，平时主要接触的是汇编和C，但其实在这个项目组基本就没怎么写过代码，主要以调研与分析为主。在这个项目组里面有意思的工作也不太多，emmm，可能有意思一点的就在于一开始学PE的时候做了一个新人任务，如何用最小的空间去完成一个helloworld程序，当时主要用到方法是裁剪资源表以及利用Dos头里的空间等，以及还考虑过去做字节压缩，但最后没写出来。然后平时的工作有时还会涉及到部分计算机网络的知识。</p><p>接下来我说一下获奖的经历吧，主要就是两个奖项，一个是华中赛的数模，做的是一个库存补单及销量预测的一个模型，一开始拿到这个这个题目就考虑用机器学习去做，但最后效果不是很好，毕竟我们也不是专业做AI的，后来是做了一个基于统计的模型，用的时间序列的分解，把一个销量的模型按季节性、商业活动、新品上市等方面去做拆分，最后给商家设计了一套进货的策略模型，在这个比赛中是拿了一等奖。</p><p>还有一个是求是杯，这是一个创新创业的比赛，我们的项目是一个实验室的课题，做的是一款心理压力检测仪叫鸭梨管家，他的原理主要是人在压力大的时候唾液里的一种酶会增多，然后有一种检测试纸可以检测浓度，当时我是和一个学长一起做对试纸的图像分析，我负责软件方面，主要做了一些图像识别的工作，后来还加上了CNN去预测心理压力纠正数据误差，但其实这个效果也不好去评判。最后这个项目拿了一个三等奖。</p><p>除了这些项目和参赛的经历之外，我也做了不少学生工作，担任过电信学院的科协主席，也是在这个时候带着学弟学妹去做过一些网站，比如学院的选课网站啊，以及学生会的招新网站等，这个在前面也提到过，用的主要是nodejs的express框架，比较基础，数据库都用的mongodb，对其数据库只是了解，并不太熟。</p><p>我自己在平时也会做一些也会做一些便利工作与生活的一些小玩意，比如学Android的时候写过一个火锅计时器，在整博客的时候写过一个自动同步有道云笔记到Hexo博客的PC端程序，还有什么自动评教脚本这些等等，但对于这些技术其实也没有太深刻的理解，做的时候都是秉承着能用就行的原则，技术为需求服务。</p><p>这大概就是我本科阶段的一些经历，整体说起来其实做得很杂，什么都接触过，但感觉什么都不精通，所以可能很多细节原理部分自己都是一知半解的，但个人感觉在接受新知识的方面应该是比一般同学要强一点，毕竟啥都接触过一点，可能就这么点优势。我的自我介绍大概就这么多，面试官有没有什么问题我们再来探讨。</p><hr><h2 id="详细知识点整理"><a href="#详细知识点整理" class="headerlink" title="详细知识点整理"></a>详细知识点整理</h2><h3 id="git与svn区别"><a href="#git与svn区别" class="headerlink" title="git与svn区别"></a>git与svn区别</h3><ul><li>git是分布式的，svn是集中式的</li><li>git能具体定位到元数据，而svn则是按文件进行管理</li><li>svn的分支就只是另一个文件夹，git的才是真分支</li><li>git的主分支和其他分支没有本质差别，svn的其他分支都是基于某一个主分支进行管理的</li></ul><h3 id="测试驱动开发-TDD"><a href="#测试驱动开发-TDD" class="headerlink" title="测试驱动开发(TDD)"></a>测试驱动开发(TDD)</h3><ul><li>先写单元测试再开始写代码</li><li>注意输入参数合法性校验以及边界值检测</li><li>g_test框架</li></ul><h3 id="Word文档结构"><a href="#Word文档结构" class="headerlink" title="Word文档结构"></a>Word文档结构</h3><ul><li>XML</li></ul><h3 id="跨域问题及解决"><a href="#跨域问题及解决" class="headerlink" title="跨域问题及解决"></a>跨域问题及解决</h3><ul><li>问题产生缘由：浏览器的同源策略</li><li>同源策略缘由：保障浏览器安全<ul><li>CSRF攻击（Cross-site request forgery）跨站请求伪造</li></ul></li><li>解决方案：CORS（跨资源共享）-&gt; 修改Header信息</li></ul><h2 id="知识点整理集合"><a href="#知识点整理集合" class="headerlink" title="知识点整理集合"></a>知识点整理集合</h2><p><a href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94Linux&%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">Linux&amp;编译原理</a></p><p><a href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p><p><a href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p><p><a href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p><p><a href="https://liuyi12138.github.io/2020/04/02/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80(%E4%B8%BBC++)/">编程语言</a></p><h2 id="面经List"><a href="#面经List" class="headerlink" title="面经List"></a>面经List</h2><p><a href="https://liuyi12138.github.io/2020/04/01/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">阿里云实习生</a></p><p><a href="https://liuyi12138.github.io/2020/04/03/%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">腾讯实习生</a></p><h2 id="深入交流的point"><a href="#深入交流的point" class="headerlink" title="深入交流的point"></a>深入交流的point</h2><h3 id="并发程序设计案例"><a href="#并发程序设计案例" class="headerlink" title="并发程序设计案例"></a>并发程序设计案例</h3><p>记忆中比较深刻的一次开发经历是我在深信服组做底层开发的时候，当时我写的是配置模块，就是一些设置项，这些是存储在本地的，因为数据量不大，所以当时是用的文件读写的方式进行存储的。一般的配置项其实对并发要求并不高，但当时在配置模块中还存储了自动回复的消息，每次自动回复的时候都会进行访问，所以有一定的并发性。</p><p>当时第一次写完程序的时候，高并发测试一直过不去，我自己就先自查嘛，尝试计了一下时，发现大部分的时间花在了文件读写上，在数据处理上花的时间不太多，所以当时就去询问项目经理怎么办，我们的项目经理是深信服公司过来的带着我们做的一个架构师，他当时告诉我说可以用缓存来解决高并发的问题，让我自己去网上查一下。然后我就自己尝试着写了一个缓存的模型，大概就是每次启动APP的时候我就把自动回复的信息读取到内存中，每次写入的时候就更新缓存再异步写入到文件里。</p><p>对于这个缓存模型一开始我是用单例模式来实现的，一开始不熟悉单例模式自己一边百度一边写出了一个懒汉模式，但在测试过程数据时不时会出现一些问题，查了很久才发现是因为我实现的这个类线程不安全，可能会造成有多个对象被创建，最后是用双重锁检查机制来解决的这个问题，也就是在加锁之前后各检查一次对象是否存在。</p><p>整个过程其实挺曲折的，我在写这个的时候也让项目经理废了不少心，毕竟当时才大一，很多东西不懂，我记得我当时每次很快就写好了代码然后兴冲冲地提交，每次审代码的时候又会被驳回并被教育一次，在这个过程中虽然做的不是很复杂，最后看来也就是一个缓存机制加一个锁的机制，但整个过程下来就理解了为什么要这么做，让我很印象深刻。</p><ul><li>Q：为什么要用双重锁机制进行两次检验呢，一次不可以吗？</li><li><p>A：理论上来说一次检验也是可以的，但如果没有第一次的instance的检测，那么在后续获取单例的时候，如果是多个线程同时访问的话就会在synchronized排队，这个时候实际上是不需要同步的，所以才会引入双重锁机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;  </span><br><span class="line">    Singleton()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">Singleton* Singleton::getInstance()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Lock();</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;  </span><br><span class="line">        &#125;  </span><br><span class="line">        UnLock();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> m_instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Q：常见的单例模式有哪些实现方法</p></li><li>A：主要有以下四种：<ul><li>饿汉式(在类加载的时候完成对象加载，线程安全)</li><li>懒汉式(第一次使用的时候完成对象加载，线程不安全，可以加入单重/双重锁检查机制)</li><li>静态内部类(线程安全)</li><li>枚举(线程安全)</li></ul></li></ul><h3 id="一台主机不能设置两个网关"><a href="#一台主机不能设置两个网关" class="headerlink" title="一台主机不能设置两个网关"></a>一台主机不能设置两个网关</h3><p>在网安组记忆比较深刻的是我们在做恶意软件复现的时候搭建了一个攻防平台，要求是两个内网中间用一个交换机连接。当时交换机有其他小组在用，所以我们就用了一台双网卡的机器来当做交换机，配置防火墙和抓包也方便。</p><p>但遇到了一个问题是内外网ping不同，于是就开始排查，找了很久发现没什么问题，觉得每一个网段都没问题，应该是在充当交换机的机器这卡住了。后来看到ping的输出是目标主机不可达，这就很奇怪，因为一般网络不通会请求超时，所以我们判断应该是网关有问题，可能是防火墙设置的问题，没有把数据包转发出去。</p><p>后来发现是这台机器上的两个网卡都设置了网关，同一台机器或者路由器上的两个网口是可以互相通信的，所以内网网口是不需要设置网关的，只需要对外的网口设置网关即可，如果两个网口都设置了网关，路由器就不知道数据包往哪发了，所以就返回了目标主机不可达。</p><p>从这次经历中我们也明白了理论知识对于实践的重要性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;昨天第一次投出了简历，目标腾讯，可能最近就要开始面试了，所以对个人的项目经历及获奖经历进行一个整理&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://liuyi12138.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue桌面程序开发实战</title>
    <link href="https://liuyi12138.github.io/2020/03/09/Electron-vue%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>https://liuyi12138.github.io/2020/03/09/Electron-vue%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</id>
    <published>2020-03-09T10:36:16.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>很早之前就想把<a href="https://liuyi12138.github.io/2019/03/21/Python%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%88%B0Hexo/">博客迁移脚本(YoudaoToHexo)</a>给做成一个应用程序，由于脚本是python写的，之前调研过pyqt、vxpython等，感觉做的都比较丑，正好看到了PicGo的开发使用的是Electron-vue，比较符合我的技术栈，所以就进行了一次尝试</strong></p><a id="more"></a> <h2 id="Electron-vue简介"><a href="#Electron-vue简介" class="headerlink" title="Electron-vue简介"></a>Electron-vue简介</h2><ul><li>Electron-vue这个东西就比较神奇了，其作用就是利用vue来开发桌面端程序，并且可以适配主流的三种平台。</li><li>这就很类似于之前见过的Hbuilder(有兴趣的同学可以了解一下，也是用web开发的方式快速开发应用，可以直接适配Web，Android，ios，微信小程序等平台)</li><li>这两者其实本质上都是给web套个壳，虽然可能不如原生流畅，但开发周期短，感觉挺适合个人开发者自己玩</li><li>Electron-vue的好处就在于他可以调用操作系统的API，Hbuilder貌似是不能的，但坏处就在于要把node、vue等一套打包，所以做出来的程序会比较大</li></ul><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><ul><li>目前BlogGo-1.0.0已经开发完成，在此简单地记录了一下开发流程</li></ul><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p><code>vue init simulatedgreg/electron-vue Exename</code></p><h3 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h3><ul><li>在进行electron-vue开发的时候，为了实现需要的功能，找了不少小巧方便，即插即用的组件，为开发提供了极大的便利</li></ul><h4 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h4><ul><li>element-ui为vue开发常见的组件模组</li><li><p><code>/src/renderer/main.js</code>添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &apos;element-ui&apos;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure></li><li><p><code>/.electron-vue/webpack.renderer.config.js</code>第22行添加element-ui模块<br><code>let whiteListedModules = [&#39;vue&#39;,&#39;element-ui&#39;]</code></p></li><li><p>删除<code>package-lock.json</code>,在<code>package.json</code>中修改,重新npm install</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//在此就把接下来用上的packets都写了</span><br><span class="line">&quot;dependencies&quot;:&#123;</span><br><span class="line">    &quot;element-ui&quot;: &quot;^2.13.0&quot;,</span><br><span class="line">    &quot;child_process&quot;: &quot;^1.0.2&quot;,</span><br><span class="line">    &quot;electron-store&quot;: &quot;^5.1.1&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="electron-store"><a href="#electron-store" class="headerlink" title="electron-store"></a>electron-store</h4><ul><li>electron-store用于信息存储</li><li><p>在vue文件中直接引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Store = require(&apos;electron-store&apos;)</span><br><span class="line">const store = new Store()</span><br><span class="line">let dataSet = store.set(&apos;data&apos;)</span><br><span class="line">let dataGet = store.get(&apos;data&apos;)</span><br></pre></td></tr></table></figure></li><li><p>electron-store存储的信息在<code>C:\Users\User\AppData\Roaming\Exename\config.json</code>中，也是因此electron-store不适合存储大量数据，大量数据可采用文件或者数据库的方式存储</p></li></ul><h4 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h4><ul><li>electron好就好在可以调用操作系统的API，当有调用cmd的需求时可以使用child_process</li><li>使用方式与electron-store相似，直接在vue文件中使用即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const exec = require(&apos;child_process&apos;).exec</span><br><span class="line">//cmdStr为需要执行的语句，path为执行目录</span><br><span class="line">let workerProcess = exec(cmdStr, &#123;cwd: path&#125;)</span><br><span class="line"></span><br><span class="line">//有警告或者错误输出时的回调函数</span><br><span class="line">workerProcess.stderr.on(&apos;data&apos;, function (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line">//正常输出时的回调函数</span><br><span class="line">workerProcess.stdout.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">//程序执行结束时的回调函数</span><br><span class="line">workerProcess.on(&apos;close&apos;, function (code) &#123;</span><br><span class="line">    console.log(code)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="开发踩坑"><a href="#开发踩坑" class="headerlink" title="开发踩坑"></a>开发踩坑</h3><p>由于本来就不太会vue，js写的也一般，所以在整个开发过程中还是踩了不少的坑，但最终还是把产品做出来了，很多模块之后可以复用，当然也可以给其他朋友们一点帮助</p><h4 id="request请求乱码"><a href="#request请求乱码" class="headerlink" title="request请求乱码"></a>request请求乱码</h4><ul><li><p>在BlogGo的开发中我需要向有道云发起请求，使用的是nodejs的request模块如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var request = require(&apos;request&apos;)</span><br><span class="line"> request(&#123;</span><br><span class="line">      url: url,</span><br><span class="line">      method: &apos;POST&apos;,</span><br><span class="line">      json: true,</span><br><span class="line">      headers: HEADERS,</span><br><span class="line">      form: data,</span><br><span class="line">      gzip: true</span><br><span class="line">    &#125;, function (error, response, body) &#123;</span><br><span class="line">        console.log(body)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li><p>遇到乱码主要是受到的responce是数据包，没有解压导致的，需要在request的参数中加入gzip</p></li></ul><h4 id="JS异步调用"><a href="#JS异步调用" class="headerlink" title="JS异步调用"></a>JS异步调用</h4><ul><li>JS是我目前见过的最奇葩的一门语言了，因为我一般都是在做Web时使用js，这也就导致遇到的大部分函数调用都是异步的，之前一直是采用回调函数的方法来解决，也就是上面request请求所使用的方法，但如果逻辑比较复杂，回调函数就会写得及其恐怖，这次算是彻底解决了这个问题</li><li>主要用到的有async，await，Promise，下面将一一个例子来讲解用法，但别指望我能把这些东西讲清楚，能用就行，想具体了解自行百度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">async myRequest() &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        var request = require(&apos;request&apos;)</span><br><span class="line">         request(&#123;</span><br><span class="line">              url: url,</span><br><span class="line">              method: &apos;POST&apos;,</span><br><span class="line">              json: true,</span><br><span class="line">              headers: HEADERS,</span><br><span class="line">              form: data,</span><br><span class="line">              gzip: true</span><br><span class="line">            &#125;, function (error, response, body) &#123;</span><br><span class="line">                if(!error &amp;&amp; response.statusCode === 200)</span><br><span class="line">                    resolve(body)</span><br><span class="line">                else</span><br><span class="line">                    reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">let body = await myRequest()</span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义标题栏"><a href="#自定义标题栏" class="headerlink" title="自定义标题栏"></a>自定义标题栏</h4><ul><li>Electron-vue自带的标题栏其实还行，但一定要绑定工具栏就巨难受，为了不显示工具栏，终于走上了自定义标题栏的不归路……</li><li><p>其实主要想法也很简单，就是在主页面上单独放置一个MyTitle.vue页面，这需要在APP.vue中进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//修改后的APP.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Mytitle /&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Mytitle from &apos;@/components/MyTitle&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;BlogGo&apos;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Mytitle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">html,</span><br><span class="line">body,</span><br><span class="line">div &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>而对于MyTitle.vue，自然是想怎么设置就怎么设置，但需要注意两个点</p></li><li>一个是去除顶部栏无法拖动的问题，这个上百度其实大家都讲得很清楚，基本都是给顶部栏加上一个<code>-webkit-app-region: drag</code>的style就可以，但如果在顶部栏上有按键的话，需要给按钮设置不可拖动<code>style=&quot;-webkit-app-region: no-drag&quot;</code>不然无法触发点击事件</li><li>另一个是点击事件的传递问题，由于窗口是由main管理的，页面是由renderer管理，所以需要对windows操作需要联系到main，网上的大部分方法都是使用ipcMain与main的index.js进行通信，但我确实是没跑通，最终采用的是在PicGo中抄过来的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//MyTitle.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;mytitle&quot;&gt;</span><br><span class="line">  &lt;el-row&gt;</span><br><span class="line">    &lt;el-col :span=&quot;8&quot; :offset=&quot;8&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;view-title&quot;&gt;</span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;el-col :span=&quot;8&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;titlebtn&quot;&gt;</span><br><span class="line">        &lt;el-button type=&quot;text&quot; size=&quot;medium&quot; icon=&quot;el-icon-minus&quot; circle @click=&quot;winmin&quot; style=&quot;-webkit-app-region: no-drag&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;text&quot; size=&quot;medium&quot; icon=&quot;el-icon-full-screen&quot; circle @click=&quot;winmax&quot; style=&quot;-webkit-app-region: no-drag&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;text&quot; size=&quot;medium&quot; icon=&quot;el-icon-close&quot; circle @click=&quot;winclose&quot; style=&quot;-webkit-app-region: no-drag&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">  &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123;remote&#125; = require(&apos;electron&apos;)</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &apos;BlogGo-1.0.0&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      winmin () &#123;</span><br><span class="line">        const window = remote.BrowserWindow.getFocusedWindow()</span><br><span class="line">        window.minimize()</span><br><span class="line">      &#125;,</span><br><span class="line">      winmax () &#123;</span><br><span class="line">        const window = remote.BrowserWindow.getFocusedWindow()</span><br><span class="line">        if (window.isMaximized()) &#123;</span><br><span class="line">          window.restore()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          window.maximize()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      winclose () &#123;</span><br><span class="line">        const window = remote.BrowserWindow.getFocusedWindow()</span><br><span class="line">        window.close()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;style&gt;</span><br><span class="line">#mytitle &#123;</span><br><span class="line">    position: left;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 30px;</span><br><span class="line">    -webkit-app-region: drag;</span><br><span class="line">&#125;</span><br><span class="line">.titlebtn&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 30px;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.view-title&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200311195809.png" alt="BlogGo" title>                </div>                <div class="image-caption">BlogGo</div>            </figure><h3 id="打包及发布"><a href="#打包及发布" class="headerlink" title="打包及发布"></a>打包及发布</h3><ul><li>打包及发布有两种形式<ul><li>electron-packager用于简单地打包</li><li>electron-builder用于完整的安装程序、自动更新的支持等，也就是所谓的CI构建</li></ul></li><li>使用electron-packager打包只需要npm run build一条命令然后等待就可以了，十分方便</li><li>具体的打包与构建可以参考<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/building_your_app.html" target="_blank" rel="noopener">官方文档</a>，其实也没写的多具体,一两句话…</li><li>还可以通过<a href="https://molunerfinn.com/electron-vue-5/#%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">PicGo开发笔记</a>来了解更多，一般比较需要的是一些基本的修改比如应用名称啊，版本号啊，图标啊等等，更多的可自行参考上述的参考资料</li></ul><h2 id="开发感想"><a href="#开发感想" class="headerlink" title="开发感想"></a>开发感想</h2><ul><li>有一说一花了四天时间使用一项新技术开发出一个作品是一件挺值得让人骄傲的事情，先高兴一下</li><li>主要是作为一名业余选手，无论是Web、APP还是PC桌面程序的开发其实都是为了使自己的生活更加便捷，所以在整个开发过程中基本都是需要什么技术就去找，找到了就用上，并不关心背后的技术原理以及是否有更好的解决方法，有时候连为什么bug通了都不知道，但其实也无所谓，能用就行23333</li><li>另一方面就是要开始注意版本管理与发布了，之前一直不懂Github的ReadMe怎么去写，现在也要开始着手去学了，之后估计并不会用上CI吧，毕竟是做给自己用的，不过大家提的issue还是需要尝试去改进</li><li>路漫漫其修远兮，继续加油吧</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;很早之前就想把&lt;a href=&quot;https://liuyi12138.github.io/2019/03/21/Python%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E5%88%B0Hexo/&quot;&gt;博客迁移脚本(YoudaoToHexo)&lt;/a&gt;给做成一个应用程序，由于脚本是python写的，之前调研过pyqt、vxpython等，感觉做的都比较丑，正好看到了PicGo的开发使用的是Electron-vue，比较符合我的技术栈，所以就进行了一次尝试&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://liuyi12138.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="轮子" scheme="https://liuyi12138.github.io/tags/%E8%BD%AE%E5%AD%90/"/>
    
      <category term="vue" scheme="https://liuyi12138.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Mitre ATT&amp;CK调研</title>
    <link href="https://liuyi12138.github.io/2020/02/07/Mitre%20ATT&amp;CK%E8%B0%83%E7%A0%94/"/>
    <id>https://liuyi12138.github.io/2020/02/07/Mitre%20ATT&amp;CK%E8%B0%83%E7%A0%94/</id>
    <published>2020-02-07T05:53:36.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p>网安组调研内容<br><a id="more"></a> </p><h2 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h2><h3 id="Cyber-Kill-Chain"><a href="#Cyber-Kill-Chain" class="headerlink" title="Cyber Kill Chain"></a>Cyber Kill Chain</h3><ul><li>杀伤链”这个概念源自军事领域，它是一个描述攻击环节的六阶段模型，理论上也可以用来预防此类攻击（即反杀伤链）。</li><li>Cyber Kill Chain是由洛克希德-马丁公司提出的网络攻击杀伤链，本质是一种针对性的分阶段攻击。同样，这一理论可以用于网络防护。</li></ul><center><img src="https://gitee.com/know_the_emperor/picture/raw/master/CyberKillChain.png" width="300" height="500" alt="CyberKillChain"></center><h3 id="ATT-amp-CK"><a href="#ATT-amp-CK" class="headerlink" title="ATT&amp;CK"></a>ATT&amp;CK</h3><ul><li>ATT&amp;CK是MITRE在2013年推出的模型，用以根据真实的观察数据来描述和分类对抗行为,该框架把攻击者所采用的 TTP (战术Tactics、技术Techniques、过程Procedures) 系统性地组织起来.</li><li>ATT&amp;CK将已知攻击者行为转换为结构化列表，将这些已知的行为汇总成战术和技术，并通过几个矩阵以及结构化威胁信息表达式（STIX）、指标信息的可信自动化交换（TAXII）来表示。</li></ul><h3 id="MITRE-ATT＆CK与Kill-Chain的对比"><a href="#MITRE-ATT＆CK与Kill-Chain的对比" class="headerlink" title="MITRE ATT＆CK与Kill Chain的对比"></a>MITRE ATT＆CK与Kill Chain的对比</h3><ul><li>ATT&amp;CK模型是在KillChain模型的基础上进行构建的。</li><li>目前ATT&amp;CK模型分为三部分，分别是PRE-ATT&amp;CK，ATT&amp;CK for Enterprise和ATT&amp;CK for Mobile。<ul><li>PRE-ATT&amp;CK覆盖Kill Chain模型的前两个阶段，包含了与攻击者在尝试利用特定目标网络或系统漏洞进行相关操作有关的战术和技术。</li><li>ATT&amp;CK for Enterprise覆盖Kill Chain的后五个阶段。</li><li>ATT&amp;CK for Mobile包含适用于移动设备的战术和技术。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200207141533.png" alt="ATT＆CK与Kill Chain的对比流程图" title>                </div>                <div class="image-caption">ATT＆CK与Kill Chain的对比流程图</div>            </figure><ul><li>ATT&amp;CK与Kill Chain的不同之处在于，它并不遵循任何线性顺序，攻击者可以任意切换战术来实现目标。</li><li>除了在Kill Chain战术上更加细化之外，ATT＆CK还描述了可以在每个阶段使用的技术，而Kill Chain则没有这些内容。</li></ul><h2 id="MITRE-ATT＆CK框架详细介绍"><a href="#MITRE-ATT＆CK框架详细介绍" class="headerlink" title="MITRE ATT＆CK框架详细介绍"></a>MITRE ATT＆CK框架详细介绍</h2><ul><li>MITRE ATT＆CK以矩阵的形式来展现完整的攻击过程。</li><li>攻击战术展示在矩阵顶部，每列下面列出了单独的技术。一个攻击序列按照战术，至少包含一个技术，并且通过从左侧（初始访问）向右侧（影响）移动，就构建了一个完整的攻击序列。</li><li>攻击者不一定会使用矩阵顶部所示的所有12项战术。相反，攻击者会使用最少数量的战术来实现其目标，因为这可以提高效率并且降低被发现的几率。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/ATT%26CK%20Matrix%20for%20Enterprise.png" alt="MITRE ATT＆CK矩阵" title>                </div>                <div class="image-caption">MITRE ATT＆CK矩阵</div>            </figure></li></ul><h3 id="ATT-amp-CK-for-Enterprise攻击战术"><a href="#ATT-amp-CK-for-Enterprise攻击战术" class="headerlink" title="ATT&amp;CK for Enterprise攻击战术"></a>ATT&amp;CK for Enterprise攻击战术</h3><ul><li>初始访问:从PRE-ATT&amp;CK到ATT&amp;CK的理想过渡点</li><li>执行:恶意软件的运行、APT攻击等</li><li>持久化:使用注册表Run键、启动文件夹等方法使得恶意软件在靶机上持续存在</li><li>提升权限:利用系统漏洞获取到root级访问权</li><li>防御规避:骗过防病毒产品或绕过应用白名单等技术</li><li>凭据访问:窃取密码来获得访问权限</li><li>发现:类似于Cyber Kill Chain中的侦查,较难防御</li><li>横向移动:攻击者在利用单个系统漏洞后，通常会尝试在网络内进行横向移动，寻找更高的访问权限，以期达成最终目标</li><li>收集:攻击者为了发现和收集实现目标所需的数据而采取的技术</li><li>命令与控制:通过命令和控制权来渗透数据、告诉恶意软件下一步执行什么指令</li><li>数据渗漏:攻击者获得访问权限后会四处搜寻相关数据，然后开始着手数据渗透</li><li>影响:攻击者试图操纵、中断或破坏企业的系统和数据</li></ul><h3 id="ATT-amp-CK-for-Enterprise技术描述"><a href="#ATT-amp-CK-for-Enterprise技术描述" class="headerlink" title="ATT&amp;CK for Enterprise技术描述"></a>ATT&amp;CK for Enterprise技术描述</h3><p><strong>在ATT&amp;CK中所有的攻击检测都是基于数据源和策略的特征匹配，我们如果需要检测某个攻击技术，首先需要获取到这项技术所对应的数据。</strong></p><ul><li>这些数据就是当攻击者执行某项技术攻击主机或网络后，在主机或网络设备上留下的蛛丝马迹，他们所呈现的形式往往是各种日志，可能是系统或应用内置的日志，也可能是因为安全需要而特意录制的日志数据。</li><li>在 MITRE ATT&amp;CK 的每项技术描述中都有对应于该技术的数据源信息，它告诉我们可以从哪些类型的数据中找到攻击技术实施后所留下的痕迹。</li><li>并且MITRE ATT&amp;CK还给出了每项技术的程序示例、侦测及缓解措施。</li></ul><p><strong>在此以LSASS Driver为例来予以说明</strong></p><ul><li>我们所分析过的wannacry正是采用了DLL注入到进程lsass.exe 中的方法来实现执行和持久化这两个步骤。</li></ul><h4 id="技术描述"><a href="#技术描述" class="headerlink" title="技术描述"></a>技术描述</h4><ul><li>对于每一项技术ATT&amp;CK都会给出一段简单的描述便于使用者去简要理解这项技术。</li><li>从技术描述中我们可以了解到<code>对手可能将lsass.exe驱动程序作为目标来获得执行和/或持久性。对手可以实现由连续LSA操作触发的任意代码执行</code>这和我们分析得出的Wannacry使用的技术相符合。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/%E6%8A%80%E6%9C%AF%E6%8F%8F%E8%BF%B0.png" alt="describe" title>                </div>                <div class="image-caption">describe</div>            </figure><h4 id="数据源信息"><a href="#数据源信息" class="headerlink" title="数据源信息"></a>数据源信息</h4><ul><li>在ATT&amp;CK的数据库中对每一项技术都有自己特有的ID，并且给出了侦测与防御它所需要的数据源。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208131508.png" alt="sourceData" title>                </div>                <div class="image-caption">sourceData</div>            </figure><h4 id="侦测与防御方案"><a href="#侦测与防御方案" class="headerlink" title="侦测与防御方案"></a>侦测与防御方案</h4><ul><li>最后ATT&amp;CK也给出了侦测与防御的建议。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208131726.png" alt="Detection&Defence" title>                </div>                <div class="image-caption">Detection&Defence</div>            </figure><h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><ul><li>对于每一项技术，ATT&amp;CK还给出了使用过这种技术的攻击示例。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208132336.png" alt="example" title>                </div>                <div class="image-caption">example</div>            </figure><ul><li>而对于每一个攻击示例，也提供了各种信息，可以用来定点防范。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208132730.png" alt="example2" title>                </div>                <div class="image-caption">example2</div>            </figure><h2 id="ATT-amp-CK的应用场景"><a href="#ATT-amp-CK的应用场景" class="headerlink" title="ATT&amp;CK的应用场景"></a>ATT&amp;CK的应用场景</h2><p><strong>至目前为止，ATT&amp;CK 知识库主要被应用在以下四大方向上：</strong></p><ul><li>模拟攻击:基于 ATT&amp;CK 进行红蓝攻防演练，进行红蓝军建设。</li><li>检测分析:基于具体的技术，有效增强检测能力，用于甲方安全建设。</li><li>威胁情报:使用 ATT&amp;CK框架来识别攻击组织，用于安全情报建设。</li><li>评估改进:将解决方案映射到 ATT&amp;CK 威胁模型，发现并弥补差距，用于评估安全能力。</li></ul><h3 id="模拟攻击"><a href="#模拟攻击" class="headerlink" title="模拟攻击"></a>模拟攻击</h3><p><strong>此部分重点讨论如何基于ATT&amp;CK框架来制定红蓝对抗方案以提升检测能力。</strong></p><ul><li>传统的渗透测试侧重于突出攻击者可能在某个时间段会利用不同类型系统上的哪些漏洞。MITRE的对抗模拟方法不同于这些传统方法。其目标是让红队成员执行基于特定或许多已知攻击者的行为和技术，以测试特定系统或网络的防御效果。</li><li>对抗模拟演习由小型的重复性活动组成，这些活动旨在通过系统地将各种新的恶意行为引入环境，来改善和测试网络上的防御能力。</li><li>进行威胁模拟的红队与蓝队紧密合作(通常称为紫队)，以确保进行深入沟通交流，这对于快速磨练组织机构的防御能力至关重要。因此，与全范围的渗透测试或以任务目标为重点的红队相比，对抗模拟测试测试速度更快、测试内容更集中。</li><li>具体实例可参考<a href="https://www.secpulse.com/archives/117592.html" target="_blank" rel="noopener">《基于ATT&amp;CK框架的红蓝对抗，有效提升检测能力》</a></li></ul><h3 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h3><ul><li>ATT&amp;CK（对手战术、技术及通用知识库）是一个反映各个攻击生命周期的攻击行为的模型和知识库，而威胁情报是对攻击者及其恶意活动的可运营的知识（actionable knowledge）和洞见（insight），其中知识包括上下文、机制、指标、含义和可执行的建议。因此我们可以利用ATT&amp;CK模型来增强威胁情报。</li><li>具体实例可参考<a href="https://www.secpulse.com/archives/111108.html" target="_blank" rel="noopener">《实战化ATT&amp;CK™：威胁情报》</a>及<a href="https://www.anquanke.com/post/id/194911" target="_blank" rel="noopener">《ATT＆CK在情报中的运用》</a>两篇博文。</li></ul><h3 id="ATT-amp-CK框架的影响"><a href="#ATT-amp-CK框架的影响" class="headerlink" title="ATT&amp;CK框架的影响"></a>ATT&amp;CK框架的影响</h3><ul><li>ATT&amp;CK 框架可以成为业界的标准（能力可度量）<ul><li>目前 ATT&amp;CK 框架主要包含终端相关安全知识，可以根据检测能力的矩阵覆盖率来评估部分安全产品的能力，例如：沙箱、EDR、SIEM 等。</li><li>如果顺利发展的话后期也可能加入Web安全相关安全知识，那时 WAF、RASP、代码审计等 Web 相关安全产品也可以凭借框架进行评估。</li></ul></li><li>ATT&amp;CK框架可以成为业界的通用语言（威胁数据标签化）<ul><li>在安全分析工作中，语言多样性同时造成语言障碍，影响协作能力。</li><li>比如今天这个设备的告警叫 “smb漏洞利用”，明天相同的告警叫 “MS17-010”，若是能以后大家都称其为 T1210-Exploitation of Remote Services，SubTxxxx-MS17010，每个人的一小步，却是行业的一大步。</li></ul></li></ul><h3 id="ATT-amp-CK框架的局限与不足"><a href="#ATT-amp-CK框架的局限与不足" class="headerlink" title="ATT&amp;CK框架的局限与不足"></a>ATT&amp;CK框架的局限与不足</h3><ul><li>虽然 ATT&amp;CK 框架期望实现建立一个大而全的威胁知识库，但目前的阶段还尚处于初步了解框架概念。MITRE 致力于建立一个 Cyber Analytics Repository，但由于内容太少而不足以提供丰富的检测能力。</li><li>在ATT&amp;CK中，PRE-ATT&amp;CK中才是情报建设核心能力的部分，但是这部分的能力建设门槛比较高，并且ATT&amp;CK在这一部分中的定义的比较粗，基本都是计划、人员组织、开发测试等逻辑术语。</li><li>不过也有很多迫不及待的人已经提前动起了手，例如 Red Teaming Experiments、atomic-red-team，但他们更注重的是 Red Team 攻击过程的复现，我们期望的是 Red Team 代码级复现 +Blue Team 威胁特征提取。</li></ul><p><strong>随着 ATT&amp;CK 框架的认知度越来越高，其完善发展的速度一定会更快，应用的方向也会更广。就目前阶段，ATT&amp;CK 最大作用是帮助恶意行为的检测和分析。</strong></p><h2 id="ATT-amp-CK框架的实施与使用"><a href="#ATT-amp-CK框架的实施与使用" class="headerlink" title="ATT&amp;CK框架的实施与使用"></a>ATT&amp;CK框架的实施与使用</h2><h3 id="整体实施规划"><a href="#整体实施规划" class="headerlink" title="整体实施规划"></a>整体实施规划</h3><p><strong>对于不同成熟度阶段的防御方案中，ATT&amp;CK框架有着不同的映射方法，以便各种防御方案都能从中获取到价值。</strong></p><h4 id="阶段1：参考和数据丰富"><a href="#阶段1：参考和数据丰富" class="headerlink" title="阶段1：参考和数据丰富"></a>阶段1：参考和数据丰富</h4><ul><li>MITRE ATT&amp;CK 框架包含大量具有潜在价值的数据，在此阶段可将该框架的数据当做详细的对手资料参考源，人工丰富对事件和警报的分析。</li><li>为更好地消费该数据，可以运用能方便访问并共享该数据的工具，比如数据丰富工具，或带中央威胁库方便用户聚合数据并搜索对手资料的平台<br>。</li></ul><h4 id="阶段2：指标或事件驱动的响应"><a href="#阶段2：指标或事件驱动的响应" class="headerlink" title="阶段2：指标或事件驱动的响应"></a>阶段2：指标或事件驱动的响应</h4><ul><li>阶段2建立在参考和理解MITRE ATT&amp;CK数据的能力基础上。</li><li>第二阶段中安全团队要在自身运营工作流中融入该平台的各项功能，更有效地对数据进行操作。</li><li>通过自动关联事件及内部环境相关指标(指标源包括安全信息及事件管理(SIEM)系统、日志管理存储、案例管理系统和安全基础设施)和来自MITRE ATT&amp;CK框架的指标，安全团队能获得相关上下文，即时知晓攻击的发起者、目标、源头、时间、动机和方式</li><li>一旦能够以自动化的方式简洁明了地利用ATT&amp;CK数据，安全团队便可更有效地调查和响应事件，将威胁情报高效推送至传感器加以检测，有效追捕威胁。</li></ul><h4 id="阶段3：战术或技术驱动的主动威胁捕捉"><a href="#阶段3：战术或技术驱动的主动威胁捕捉" class="headerlink" title="阶段3：战术或技术驱动的主动威胁捕捉"></a>阶段3：战术或技术驱动的主动威胁捕捉</h4><ul><li>在这一阶段，威胁捕捉团队可从寻找指标转向充分利用ATT&amp;CK数据。</li><li>不是专注看起来可疑的具体数据点，而是利用该平台站在更高的角度考虑对手及其相关TTP的信息。</li><li>威胁捕捉团队可采取主动，从风险情况入手，将风险映射到具体对手及其战术，深挖这些对手使用的技术，然后就可以在发现相关数据时立即展开调查了。</li></ul><p><strong>万丈高楼平地起，在完全没开始利用MITRE ATT&amp;CK 框架之前对更高层次的部署方案做太多调研意义不大。所以接下来的内容更注重于在阶段1中如何筛选技术并对想应的数据加以利用。</strong></p><h3 id="技术筛选"><a href="#技术筛选" class="headerlink" title="技术筛选"></a>技术筛选</h3><p><strong>MITRE ATT＆CK框架中有好几百种技术，并且会随着新技术的推出以及人工智能和机器学习系统的部署而逐渐扩大,我们并不可能对所有的技术都进行检测与相应，所以需要根据具体的需求从中筛选。</strong></p><h4 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h4><ul><li>对于公司来说需要了解清楚最需要防护什么，攻击者最可能盯上什么。</li><li>对于已经有一定防御措施的情况，可以从已有的技术出发来逐步构建与完善整个防护模型。</li></ul><h4 id="寻找关键技术"><a href="#寻找关键技术" class="headerlink" title="寻找关键技术"></a>寻找关键技术</h4><ul><li>Red Canary通过对过去五年里，其客户环境中发生的一万多起恶意事件进行分析，得出了威胁事件利用每种ATT&amp;CK技术的频率,并列出了Top 20的攻击技术。</li><li>构建防御模型也常常需要考虑覆盖到这些关键技术。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208152700.png" alt="Top20" title>                </div>                <div class="image-caption">Top20</div>            </figure><h4 id="确认攻击难度"><a href="#确认攻击难度" class="headerlink" title="确认攻击难度"></a>确认攻击难度</h4><ul><li>Tripwire 的 Travis Smith 在 ATT&amp;CKCon 大会上做了题为“ATT&amp;CK as a Teacher”的演讲，将 ATT&amp;CK 矩阵按漏洞利用难度加以组织。</li><li>构建防御模型时可以以攻击难度为标准来选择适合自己的技术。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208162634.png" alt="技术难度分级" title>                </div>                <div class="image-caption">技术难度分级</div>            </figure><h4 id="数据源筛选"><a href="#数据源筛选" class="headerlink" title="数据源筛选"></a>数据源筛选</h4><ul><li>当确定要在检测方案中实施相关检测技术时，需要确保有适当的数据源来实施针对该技术的检测方案，所以也需要根据自己可获取到的数据源来选择技术。</li><li>而较多技术所需要的数据源的获取也是防御模型的构建者所需要考虑的问题。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208162802.png" alt="数据源统计" title>                </div>                <div class="image-caption">数据源统计</div>            </figure><ul><li>需要注意的是，ATT＆CK命名的几乎每个高级数据源都包含子数据源(该数据源的不同形式)，所以有必要了解自己可以访问哪些数据源，弄清这些子数据源提供哪些信息，只找出其中一个子数据源是不够的。</li><li>实现不同相关技术检测的时候，可以通过分析特定技术与自己防御模型的相关性，来减少自己需检测的子数据源数量。<ul><li>比如说有 66种不同技术需要文件和进程监视数据源，而我们所需要检测的技术可能只需要子数据源的一个子集就够了。</li></ul></li><li>以及可以使用两种不同的方法来执行和检测一种技术，所以需要考虑哪个数据源对我们的防御模型更加关键，有所侧重才能更高效地执行检测。</li></ul><h3 id="数据源信息获取"><a href="#数据源信息获取" class="headerlink" title="数据源信息获取"></a>数据源信息获取</h3><ul><li>github上有<a href="https://github.com/Cyb3rWard0g/OSSEM" target="_blank" rel="noopener">开源安全事件元数据(Open Source Security Events Metadata (OSSEM))</a>可供使用。</li><li>OSSEM 由 Rodriguez 兄弟创建，提供数据源相关的四类信息:<ul><li>ATT&amp;CK数据源：将 ATT&amp;CK 技术的数据源映射到实际系统事件或分析，产生适用于该技术检测机制的数据。</li><li>检测数据模型</li><li>通用信息模型</li><li>数据字典</li></ul></li></ul><h3 id="数据整合"><a href="#数据整合" class="headerlink" title="数据整合"></a>数据整合</h3><ul><li>在了解数据源的物理来源以及事件与这些物理数据源的关系之后，需要有一个信息存储库及相应的查询方式。</li><li>可以使用图形数据库，并根据数据字典和公共信息模型中的信息实现类似于以下图表的内容：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/20200208161525.png" alt="数据整合" title>                </div>                <div class="image-caption">数据整合</div>            </figure><ul><li>数据整合工作量非常大，这个过程可以选择一些开源工具辅助进行。</li></ul><h4 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h4><ul><li>目前我所见到的与ATT&amp;CK想匹配的数据整合工具有以下两个，但两个工具的具体职能是什么？是否功能重叠？各有什么局限性？这些问题还有待后续调研。</li><li>Osquery<ul><li>OSquery可以收集环境中各主机的信息，并将数据聚合到表格中。可以使用类似SQL的查询来访问表格中的数据并编写检测方案，因此对于接触过关系型数据库的人来说难度并不大。</li><li>此外，OSquery可以创建查询集合，映射到ATT＆CK中的目标TTP，进行威胁捕获。安全人员可以即时创建和执行在线实时查询。</li><li>有些查询可以识别网络攻击者，这些查询可以集成到SIEM（Security Information and Event Management，安全信息及事件管理）系统中来。</li></ul></li><li>Sysmon<ul><li>Sysmon 是微软的一款免费的轻量级系统监控工具，它通过系统服务和驱动程序实现记录进程创建，网络连接以及文件创建时间更改的详细信息，并把相关的信息写入并展示在 windows 的日志事件里，以便用户使用SIEM（Security Information and Event Management，安全信息及事件管理）工具收集相应信息。</li></ul></li></ul><h3 id="落地项目简介"><a href="#落地项目简介" class="headerlink" title="落地项目简介"></a>落地项目简介</h3><p><strong>不像其它理论只是提供理论指导作用,ATT&amp;CK 框架的可落地性很强,并且目前已经有很多落地的项目可以帮助使用者来学习如何使用该框架。</strong></p><p>若想了解更将详细的信息可参考《ATT&amp;CK 实战指南》。</p><h4 id="理论学习使用"><a href="#理论学习使用" class="headerlink" title="理论学习使用"></a>理论学习使用</h4><ul><li>ATT&amp;CK™ Navigator项目：导航工具，有较好的可交互性，便于了解 ATT&amp;CK 的各项技术。</li><li>ATT&amp;CK™ 的 CARET 项目：CAR(Cyber Analytics Repository 网络分析库) 项目的演示版本，有助于理解 CAR 这个项目 (具体会在 Blue Team使用中介绍)表达的内容。</li></ul><h4 id="Red-Team-使用"><a href="#Red-Team-使用" class="headerlink" title="Red Team 使用"></a>Red Team 使用</h4><ul><li>Red Canary™ Atomic Red Team项目：可以根据框架的技术通过脚本的自动化攻击。<br>结合此项目可以完善红队攻击测试库，根据实际情况不断进行测试和回归测试，让安全攻击水准达到一个比较好的水平。</li><li>ATTACK-Tools项目：可用作模拟攻击的计划工具或ATT&amp;CK关系型数据库的查询工具。</li></ul><h4 id="Blue-Team-使用"><a href="#Blue-Team-使用" class="headerlink" title="Blue Team 使用"></a>Blue Team 使用</h4><ul><li>ATT&amp;CK™ CAR 项目：理论架构，主要是针对 ATT&amp;CK 的威胁检测和追踪，内容丰富度上比较欠缺。</li><li>Endgame™ EQL 项目：EQL（Event Query Language）是一种威胁事件查询语言，可以对安全事件进行序列化、归集及分析。该项目可以进行事件日志的收集，不局限于终端数据，还可以是网络数据。</li><li>DeTT&amp;CT 项目：DeTT&amp;CT（DEtect Tactics, Techniques &amp; Combat Threats）项目，用于帮助防御团队评估日志质量、检测覆盖度的工具。</li><li>Sigma 项目：Sigma项目是一个SIEM的特征库格式项目。该项目可以直接使用sigma格式进行威胁检测的描述，可以进行共享，也可以进行不同 SIEM 系统的格式转换。</li><li>MISP 项目：恶意软件信息共享平台 MISP（Malware Information Sharing Platform）是一个开源的威胁情报平台。</li></ul><h4 id="CSO-首席信息官-使用"><a href="#CSO-首席信息官-使用" class="headerlink" title="CSO(首席信息官) 使用"></a>CSO(首席信息官) 使用</h4><p>• Atomic Threat Coverage 项目：组织型项目，重点组成部分是上面提到的两个项目：Red Canary™ Atomic Red Team 和 Sigma项目，二者分别负责模拟攻击和攻击检测。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://attack.mitre.org/" target="_blank" rel="noopener">Mitre ATT&amp;CK官网</a><h3 id="先验知识-1"><a href="#先验知识-1" class="headerlink" title="先验知识"></a>先验知识</h3></li><li><a href="https://www.jianshu.com/p/174b5a081b51" target="_blank" rel="noopener">简书:《Cyber Kill Chain洛克希德-马丁公司的网络杀伤链》</a></li><li><a href="https://www.lockheedmartin.com/content/dam/lockheed-martin/rms/documents/cyber/LM-White-Paper-Intel-Driven-Defense.pdf" target="_blank" rel="noopener">《洛克希德-马丁公司的七步网络杀伤链白皮书》</a></li></ul><h3 id="MITRE-ATT＆CK框架详细介绍-1"><a href="#MITRE-ATT＆CK框架详细介绍-1" class="headerlink" title="MITRE ATT＆CK框架详细介绍"></a>MITRE ATT＆CK框架详细介绍</h3><ul><li><a href="https://www.secpulse.com/archives/115412.html" target="_blank" rel="noopener">安全脉搏:《一文看懂ATT&amp;CK框架以及使用场景实例》</a></li></ul><h3 id="MITRE-ATT＆CK的应用场景"><a href="#MITRE-ATT＆CK的应用场景" class="headerlink" title="MITRE ATT＆CK的应用场景"></a>MITRE ATT＆CK的应用场景</h3><ul><li><a href="https://www.jianshu.com/p/a49a001fef44" target="_blank" rel="noopener">简书:《ATT&amp;CK如何为安全产品赋能》</a></li><li><a href="https://www.secpulse.com/archives/117592.html" target="_blank" rel="noopener">安全脉搏:《基于ATT&amp;CK框架的红蓝对抗，有效提升检测能力》</a></li><li><a href="https://www.anquanke.com/post/id/194911" target="_blank" rel="noopener">安全客:《ATT＆CK在情报中的运用》</a></li><li><a href="https://www.secpulse.com/archives/111108.html" target="_blank" rel="noopener">安全脉搏:《实战化ATT&amp;CK™：威胁情报》</a></li><li><a href="https://www.aqniu.com/tools-tech/58397.html" target="_blank" rel="noopener">安全牛:《ATT&amp;CK 在大数据安全分析中的应用思考》</a></li></ul><h3 id="ATT-amp-CK框架的实施与使用-1"><a href="#ATT-amp-CK框架的实施与使用-1" class="headerlink" title="ATT&amp;CK框架的实施与使用"></a>ATT&amp;CK框架的实施与使用</h3><ul><li><a href="https://www.aqniu.com/tools-tech/45459.html" target="_blank" rel="noopener">安全牛:《加速检测与响应的最新工具：MITRE ATT&amp;CK 框架》</a></li><li><a href="https://www.secpulse.com/archives/115559.html" target="_blank" rel="noopener">安全脉搏:《青藤细述MITRE ATT＆CK框架的实施和使用方式》</a></li><li><a href="https://www.aqniu.com/learn/61033.html" target="_blank" rel="noopener">安全牛:《MITRE ATT&amp;CK 框架“入坑”指南》</a></li><li><a href="https://www.aqniu.com/industry/60527.html" target="_blank" rel="noopener">安全牛:《浅谈ATT&amp;CK对提升主机EDR检测能力的探索》</a></li><li><a href="https://www.doit.com.cn/p/350715.html" target="_blank" rel="noopener">DOIT:《ATT&amp;CK框架：攻击者最常用的TOP7攻击技术及其检测策略》</a></li><li><a href="https://www.secrss.com/articles/14991" target="_blank" rel="noopener">安全内参:《ATT&amp;CK实战指南》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网安组调研内容&lt;br&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言刷Leetcode笔记之 88. Merge Sorted Array</title>
    <link href="https://liuyi12138.github.io/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%88%B7Leetcode%E7%AC%94%E8%AE%B0%E4%B9%8BMerge%20Sorted%20Array/"/>
    <id>https://liuyi12138.github.io/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%88%B7Leetcode%E7%AC%94%E8%AE%B0%E4%B9%8BMerge%20Sorted%20Array/</id>
    <published>2020-02-01T06:33:04.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本来说今天选一个简单题做来着，结果想着想着这奇奇怪怪的方法他就出来了。</strong></p><p><strong>ps:以后打死我也不会再研究一些奇奇怪怪的算法了，人生苦短我用qsort</strong></p><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">Leetcode传送门</a></p><a id="more"></a> <h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><strong>其实主要的思想都是一样的(毕竟题很简单),但思路拓宽来，就扯到归并排序了，然后发现了奇奇怪怪的原地归并排序(谁想出来的烧脑玩意)</strong></p><h3 id="暴力qsort"><a href="#暴力qsort" class="headerlink" title="暴力qsort"></a>暴力qsort</h3><ul><li>做题第一步，必定先暴力一次过，qsort给劲，效果也还不错</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">void</span>* a, <span class="keyword">void</span>*b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        nums1[m+i] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(nums1, m+n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针比较法"><a href="#双指针比较法" class="headerlink" title="双指针比较法"></a>双指针比较法</h3><ul><li>写这个方法前是有很难受的思考与实践的，是真的难受</li><li>第一想法是还是先将num2搬到num1中去，由于合并后的数组具有特定规律(前后排序完成)，可采用特定方法进行排序</li><li>有意思的是这时的情形与归并排序的merge相同</li><li>然而归并排序的merge需要用到额外空间，这样必定浪费时间和空间</li><li>所以既然要用归并排序的合并思想，那不如直接用num2的空间，采用双指针比较法来合并。</li><li>思想大概是每次选出一个最大的数放在最后面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[m<span class="number">-1</span>-i] &gt; nums2[n<span class="number">-1</span>-j])&#123;</span><br><span class="line">            nums1[m+n-count] = nums1[m<span class="number">-1</span>-i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[m+n-count] = nums2[n<span class="number">-1</span>-j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)&#123;</span><br><span class="line">        nums1[m+n-count] = nums2[n<span class="number">-1</span>-j];</span><br><span class="line">        j++;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原地归并排序Merge"><a href="#原地归并排序Merge" class="headerlink" title="原地归并排序Merge"></a>原地归并排序Merge</h3><ul><li>左思右想，有没有法子把num2合到num1中后，不开辟空间把俩数组合并呢</li><li>自己尝试了一下并不顺利</li><li>于是百度了不消耗空间的归并函数，于是乎发现了原地归并排序这么个玩意</li><li>想要具体了解可以参考<a href="https://www.cnblogs.com/xiaorenwu702/p/5880841.html" target="_blank" rel="noopener">原地归并排序</a></li><li>但有一说一,最终效果并不咋地,毕竟不耗空间是以时间复杂度为代价的</li><li>其中一个有意思的思想就是把通过三次数组倒置的方式来实现数组旋转，有兴趣可以尝试做一下<a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">Leetcode T189 Rotate Array</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reverse(nums, start, mid);</span><br><span class="line">    reverse(nums, mid, end);</span><br><span class="line">    reverse(nums, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        nums1[m+i] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = m;</span><br><span class="line">    <span class="keyword">int</span> mid = m;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; j &lt; m+n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums1[i] &lt;= nums1[j])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m+n &amp;&amp; nums1[j] &lt; nums1[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(nums1,i,mid,j);</span><br><span class="line">        i += step;</span><br><span class="line">        mid = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li>搞了半天其实也没有提高算法的效率，只能说是拓展了思路(以后打死我也不会用这个算法了)</li><li>康康排行榜上这题的最佳解法居然是写了个快排</li><li>我就不明白了为啥自己写的快排能快过qsort…</li><li>代码我就放这了，有兴趣自己康</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        nums1[m+i]=nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Q_sort(nums1,<span class="number">0</span>,m+n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Q_sort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="built_in">array</span>[low];</span><br><span class="line">    <span class="keyword">int</span> start=low,end=high;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end&amp;&amp;key&lt;=<span class="built_in">array</span>[end])end--;</span><br><span class="line">        <span class="built_in">array</span>[start]=<span class="built_in">array</span>[end];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end&amp;&amp;key&gt;=<span class="built_in">array</span>[start])start++;</span><br><span class="line">        <span class="built_in">array</span>[end]=<span class="built_in">array</span>[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[start]=key;</span><br><span class="line">    Q_sort(<span class="built_in">array</span>,low,start<span class="number">-1</span>);</span><br><span class="line">    Q_sort(<span class="built_in">array</span>,start+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本来说今天选一个简单题做来着，结果想着想着这奇奇怪怪的方法他就出来了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ps:以后打死我也不会再研究一些奇奇怪怪的算法了，人生苦短我用qsort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://liuyi12138.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="https://liuyi12138.github.io/tags/Leetcode/"/>
    
      <category term="C语言" scheme="https://liuyi12138.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言刷Leetcode笔记之 1. Two Sum</title>
    <link href="https://liuyi12138.github.io/2020/01/31/C%E8%AF%AD%E8%A8%80%E5%88%B7Leetcode%E7%AC%94%E8%AE%B0%E4%B9%8BTwo%20Sum/"/>
    <id>https://liuyi12138.github.io/2020/01/31/C%E8%AF%AD%E8%A8%80%E5%88%B7Leetcode%E7%AC%94%E8%AE%B0%E4%B9%8BTwo%20Sum/</id>
    <published>2020-01-31T07:50:04.000Z</published>
    <updated>2021-02-23T06:34:31.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2020寒假在家，给19级小朋友出题时想了Two Sum的多种实现方法如下。</strong></p><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Leetcode传送门</a></p><a id="more"></a> <h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><strong>主要想到了三种思路及其改进，以及还有最近刷题常见的Hash表法</strong></p><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><ul><li>最直观的方法就是遍历了</li><li>时间复杂度O(n^2) 空间复杂度O(1)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><ul><li>这个想法由来已久，去年用C++刷题时就想到能否尝试，主要是看到算法导论上有一个例题的分析方法与之类似一直想试一下，直到今天才have a try 但改进效果有限</li><li>(<a href="https://liuyi12138.github.io/2018/08/20/C%E5%88%B7Leetcode%E7%AC%94%E8%AE%B0%E4%B9%8B1TwoSum/">去年的C++刷题笔记</a>)</li><li>时间复杂度O(n^2) 空间复杂度O(1)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    分治法实现2Sum，思路为把数组分为两半，问题变为3个子问题：</span></span><br><span class="line"><span class="comment">    2个数都在左侧/2个数都在右侧/左右各一个</span></span><br><span class="line"><span class="comment">    如果两个数在同侧则继续递归,最小子问题为只剩两个数时直接比较，只剩一个数时判false</span></span><br><span class="line"><span class="comment">    如果两个数分别在两边，则for循环遍历两侧，时间复杂度为O(n^2),但系数为原来的1/4</span></span><br><span class="line"><span class="comment">    此方法时间复杂度为O(n^2),最理想条件下时间复杂度为O(nlogn),空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ergodic</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> target, <span class="keyword">int</span>* result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> med = (l + h) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= med; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = med + <span class="number">1</span>; j &lt;= h; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[i] + nums[j])&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find2Sum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> target, <span class="keyword">int</span>* result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h &lt;= l)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(h == l + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[l] + nums[h])&#123;</span><br><span class="line">            result[<span class="number">0</span>] = l;</span><br><span class="line">            result[<span class="number">1</span>] = h;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> med = (l + h) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> leftRes = find2Sum(nums, l, med, target, result);</span><br><span class="line">    <span class="keyword">int</span> rightRes = find2Sum(nums, med, h, target, result);</span><br><span class="line">    <span class="keyword">if</span>(!leftRes &amp;&amp; !rightRes)</span><br><span class="line">        <span class="keyword">return</span> ergodic(nums, l, h, target, result);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(find2Sum(nums, <span class="number">0</span>, numsSize<span class="number">-1</span>, target, result))&#123;</span><br><span class="line">        *returnSize = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先排序后搜索"><a href="#先排序后搜索" class="headerlink" title="先排序后搜索"></a>先排序后搜索</h3><ul><li>思路为排序后搜索，需要开辟空间来存储原数组防止丢失索引</li></ul><h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><ul><li>排序和搜索的时间复杂度都为O(nlogn),算法的空间复杂度为O(n)</li><li>(这个二分搜索代码的边界条件有问题aaaaa，真的调不出来，代码思路在这，凑合着看)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">void</span>* a, <span class="keyword">void</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(numsSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> resultl, resulth;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        temp[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(temp, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">int</span> h = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= h)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + h) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] + temp[mid] == target)&#123;</span><br><span class="line">                resultl = temp[i];</span><br><span class="line">                resulth = temp[mid];</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[l] + temp[mid] &gt; target) h = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        *returnSize = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> flagl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flagh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flagl &amp;&amp; nums[i] == resultl)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                flagl = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!flagh &amp;&amp; nums[i] == resulth)&#123;</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">                flagh = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针遍历搜索"><a href="#双指针遍历搜索" class="headerlink" title="双指针遍历搜索"></a>双指针遍历搜索</h4><ul><li>此方法为上一个思路的改进，改进点在于搜索</li><li>因为qsort的时间复杂度最差为O(nlogn)，但搜索一定是O(nlogn)所以需要改进</li><li>具体措施为将二分法改为双指针遍历的方法，时间复杂度为O(n)</li><li>算法整体的时间复杂度还是O(nlogn),空间复杂度为O(n)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">void</span>* a, <span class="keyword">void</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(numsSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> resultl, resulth;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        temp[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(temp, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; h)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[l] + temp[h] == target)&#123;</span><br><span class="line">            resultl = temp[l];</span><br><span class="line">            resulth = temp[h];</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp[l] + temp[h] &lt; target) l++;</span><br><span class="line">        <span class="keyword">else</span> h--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        *returnSize = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> flagl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flagh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flagl &amp;&amp; nums[i] == resultl)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                flagl = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!flagh &amp;&amp; nums[i] == resulth)&#123;</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">                flagh = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash表法"><a href="#Hash表法" class="headerlink" title="Hash表法"></a>Hash表法</h3><ul><li>Hash表是什么我在此就不讲解了，不懂的自行百度</li><li>最近刷题得分高的解法里面很大一部分都是使用Hash表去解</li><li>我不大愿意使用Hash表主要是因为C标准库中本身没有实现Hash表(就是懒)</li><li>之前也有过用C实现Hash表来着(<a href="https://github.com/liuyi12138/Utils/tree/master/C_HashSet" target="_blank" rel="noopener">Hash表的C语言实现</a>)</li><li>言归正传，Hash表法的思路其实很简单，主要还是靠搜索，不过通过Hash的方式实现搜索可以将时间复杂度降低</li><li>Hash存数据时间复杂度为O(1)，取数据时间复杂度为O(1) ~ O(n)</li><li>整体而言该算法的时间复杂度在O(n) ~ O(n^2)之间，空间复杂度是O(n),个人感觉效果一般</li><li>最后贴一个嫖来的Hash表法实现2Sum，大家自行体会<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> *<span class="title">hash_mem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> **<span class="title">hash_header</span>;</span></span><br><span class="line"><span class="keyword">int</span> hash_size = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_func</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> - (num % hash_size));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num % hash_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">build_hash</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i, v;</span><br><span class="line">     hash_header = <span class="built_in">malloc</span>(hash_size * <span class="keyword">sizeof</span>(struct hash_node *));</span><br><span class="line">     <span class="keyword">if</span> (hash_header == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">memset</span>(hash_header, <span class="number">0</span>, hash_size * <span class="keyword">sizeof</span>(struct hash_node *));</span><br><span class="line">     hash_mem = <span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(struct hash_node));</span><br><span class="line">     <span class="keyword">if</span> (hash_mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">free</span>(hash_header);</span><br><span class="line">         hash_header = <span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        v = hash_func(nums[i]);</span><br><span class="line">        hash_mem[i].element = nums[i];</span><br><span class="line">        hash_mem[i].index = i;</span><br><span class="line">        hash_mem[i].next = hash_header[v];</span><br><span class="line">        hash_header[v] = &amp;hash_mem[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">struct hash_node *<span class="title">hash_find</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> *<span class="title">node_p</span>;</span></span><br><span class="line"></span><br><span class="line">     v = hash_func(num);</span><br><span class="line"></span><br><span class="line">    node_p = hash_header[v];</span><br><span class="line">     <span class="keyword">while</span> (node_p) &#123;</span><br><span class="line">         <span class="keyword">if</span> (node_p-&gt;element == num &amp;&amp; node_p-&gt;index &gt; index) &#123;</span><br><span class="line">             <span class="keyword">return</span> node_p;</span><br><span class="line">         &#125;</span><br><span class="line">         node_p = node_p-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> node_p;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">hash_free</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (hash_mem) &#123;</span><br><span class="line">         <span class="built_in">free</span>(hash_mem);</span><br><span class="line">         hash_mem = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (hash_header) &#123;</span><br><span class="line">         <span class="built_in">free</span>(hash_header);</span><br><span class="line">         hash_header = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, need;</span><br><span class="line">    <span class="keyword">int</span> *res;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> *<span class="title">node_p</span>;</span></span><br><span class="line"></span><br><span class="line">    ret = build_hash(nums, numsSize);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        hash_free();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        need = target - nums[i];</span><br><span class="line">        node_p = hash_find(need, i);</span><br><span class="line">        <span class="keyword">if</span> (node_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *returnSize = <span class="number">0</span>;</span><br><span class="line">            hash_free();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = i;</span><br><span class="line">        res[<span class="number">1</span>] = node_p-&gt;index;</span><br><span class="line">        *returnSize = <span class="number">2</span>;</span><br><span class="line">        hash_free();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hash_free();</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><strong>在广大群友的讨论以及百度之下get到了更多解法</strong></p><h3 id="传说中的双向并行二分查找"><a href="#传说中的双向并行二分查找" class="headerlink" title="传说中的双向并行二分查找"></a>传说中的双向并行二分查找</h3><ul><li>排序方法我就不说了，有各种各样的实现，我个人还是趋向于使用qsort</li><li>在网上嫖到了<a href="https://blog.csdn.net/weixin_41043240/article/details/79440040" target="_blank" rel="noopener">双向并行二分查找的C语言实现</a>，在此大概贴一个思路，有兴趣的同学自行跳转到上述链接。</li><li>有一说一这思路不大好说，大家自行根据代码画图来看吧，个人觉得比较烧脑，短时间内写不出来。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)</span><br><span class="line">&#123;</span><br><span class="line">    mid = start + (end-start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(numList[start] + numList[end]&lt;target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numList[mid]+numList[end]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            start=mid;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numList[mid]+numList[end]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index[<span class="number">0</span>]=mid;</span><br><span class="line">            index[<span class="number">1</span>]=end;</span><br><span class="line">            <span class="comment">//printf("index:%d,%d\n",index[0],index[1]);</span></span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numList[start] + numList[end]&gt;target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numList[start]+numList[mid]&gt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            end=mid;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numList[start]+numList[mid]&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index[<span class="number">0</span>]=start;</span><br><span class="line">            index[<span class="number">1</span>]=mid;</span><br><span class="line">            <span class="comment">//printf("index:%d,%d\n",index[0],index[1]);</span></span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;               </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        index[<span class="number">0</span>]=start;</span><br><span class="line">        index[<span class="number">1</span>]=end;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"index:%d,%d\n"</span>,index[<span class="number">0</span>],index[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体排序后搜索"><a href="#结构体排序后搜索" class="headerlink" title="结构体排序后搜索"></a>结构体排序后搜索</h3><ul><li>leetcode上看到的最优解法</li><li>主要思路还是qsort排序 + 双指针遍历搜索</li><li>通过结构体的方式保存了下标，避免了对下标的二次遍历</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((struct node*)a)-&gt;value - ((struct node*)b)-&gt;value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">nodes</span> = (<span class="title">struct</span> <span class="title">node</span>*)<span class="title">malloc</span>(<span class="title">numsSize</span>*<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">node</span>));</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *ans=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    nodes[i].value = nums[i];</span><br><span class="line">    nodes[i].index = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(nodes, numsSize, <span class="keyword">sizeof</span>(struct node), comp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(nodes[begin].value + nodes[end].value == target)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("nodes[begin].value,nodes[end].value %d,%d,%d,%d\n",begin,nodes[begin].value,end,nodes[end].value);</span></span><br><span class="line">    ans[<span class="number">0</span>] = nodes[begin].index;</span><br><span class="line">    ans[<span class="number">1</span>] = nodes[end].index;</span><br><span class="line">            <span class="built_in">free</span>(nodes);</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nodes[begin].value + nodes[end].value &gt; target)</span><br><span class="line">    &#123;</span><br><span class="line">    end = end - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        begin = begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(nodes);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2020寒假在家，给19级小朋友出题时想了Two Sum的多种实现方法如下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Leetcode传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://liuyi12138.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="https://liuyi12138.github.io/tags/Leetcode/"/>
    
      <category term="C语言" scheme="https://liuyi12138.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>wannacry源码分析</title>
    <link href="https://liuyi12138.github.io/2019/11/09/wannacry%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://liuyi12138.github.io/2019/11/09/wannacry%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2019-11-09T02:53:23.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p>网安组wannacry分析<br><a id="more"></a> </p><h2 id="整体结构分析"><a href="#整体结构分析" class="headerlink" title="整体结构分析"></a>整体结构分析</h2><ul><li>由于时间原因，此博文只分析了wcry.exe主程序的初始化部分</li><li>下图是wannacry的结构图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191109164305.png" alt="20191109164305" title>                </div>                <div class="image-caption">20191109164305</div>            </figure><ul><li>主函数的C语言代码如下，对初始化部分做了注释</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191109164555.png" alt="20191109164555" title>                </div>                <div class="image-caption">20191109164555</div>            </figure><h2 id="初始化部分分析"><a href="#初始化部分分析" class="headerlink" title="初始化部分分析"></a>初始化部分分析</h2><h3 id="设置注册表项"><a href="#设置注册表项" class="headerlink" title="设置注册表项"></a>设置注册表项</h3><ul><li><p>主要作用是在<code>\HKEY_LOCAL_MACHINE\SOFTWARE</code>下添加一个注册表项，名称为wd,其值为wannacry的程序路径</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191109110418.png" alt="20191109110418" title>                </div>                <div class="image-caption">20191109110418</div>            </figure></li><li><p>运行后查询注册表结果如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191109105629.png" alt="20191109105629" title>                </div>                <div class="image-caption">20191109105629</div>            </figure></li></ul><h3 id="释放资源文件"><a href="#释放资源文件" class="headerlink" title="释放资源文件"></a>释放资源文件</h3><ul><li>此函数不太好分析，但内部调用了很多与资源有关的函数(如下图)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191109154147.png" alt="20191109154147" title>                </div>                <div class="image-caption">20191109154147</div>            </figure><ul><li>通过动调发现该函数释放出了很多资源文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191109154000.png" alt="20191109154000" title>                </div>                <div class="image-caption">20191109154000</div>            </figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网安组wannacry分析&lt;br&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="逆向" scheme="https://liuyi12138.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="病毒" scheme="https://liuyi12138.github.io/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>wannacry行为分析</title>
    <link href="https://liuyi12138.github.io/2019/11/08/wannacry%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/"/>
    <id>https://liuyi12138.github.io/2019/11/08/wannacry%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/</id>
    <published>2019-11-08T00:10:28.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p>网安组wannacry分析<br><a id="more"></a> </p><h2 id="使用PEID进行查壳和语言分析"><a href="#使用PEID进行查壳和语言分析" class="headerlink" title="使用PEID进行查壳和语言分析"></a>使用PEID进行查壳和语言分析</h2><ul><li>该病毒使用的是VC++6.0(这玩意真的不大好用哦)</li><li>没有加壳，子系统是Win32 GUI</li></ul><h2 id="使用LordPE分析"><a href="#使用LordPE分析" class="headerlink" title="使用LordPE分析"></a>使用LordPE分析</h2><ul><li>主要分许导入表，分析病毒的行为</li><li><p>从导入表中整理出来的API接口如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">文件操作:</span><br><span class="line">GetFileSizeEx</span><br><span class="line">ReadFile</span><br><span class="line">WriteFile</span><br><span class="line">CopyFileA</span><br><span class="line">CreateFileA</span><br><span class="line">GetFileAttributesW</span><br><span class="line">SetFileAttributesW</span><br><span class="line">SetFilePointer</span><br><span class="line">SetFileTime</span><br><span class="line">CreateDirectory</span><br><span class="line">SetCurrentDirectory//切换当前进程的当前工作目录</span><br><span class="line">GetWindowsDirectory//获取Windows目录的完整路径名</span><br><span class="line"></span><br><span class="line">服务操作:</span><br><span class="line">CreateServiceA</span><br><span class="line">OpenServiceA</span><br><span class="line">StartServiceA</span><br><span class="line">CloseServiceHandle</span><br><span class="line"></span><br><span class="line">注册表操作:</span><br><span class="line">RegCreateKeyW</span><br><span class="line">RegSetValueExA</span><br><span class="line">RegQueryValueExA</span><br><span class="line">RegCloseKey</span><br><span class="line"></span><br><span class="line">进程操作:</span><br><span class="line">CreateProcessA</span><br><span class="line">TerminateProcess//终止指定进程及其所有的线程。</span><br><span class="line">GetExitCodeProcess//获取一个已中断进程的退出代码。</span><br><span class="line"></span><br><span class="line">其他操作:</span><br><span class="line">LoadLibraryA</span><br><span class="line">GetProcAddress//检索指定的动态链接库(DLL)中的输出库函数地址</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">CriticalSection是每个线程中访问临界资源的那段代码</span><br><span class="line">不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问</span><br><span class="line">*/</span><br><span class="line">InitializeCriticalSection</span><br><span class="line">DeleteCriticalSection</span><br><span class="line">LeaveCriticalSection</span><br><span class="line">EnterCriticalSection</span><br><span class="line"></span><br><span class="line">资源操作</span><br><span class="line">SizeofResource</span><br><span class="line">LockResource</span><br><span class="line">LoadResource</span><br><span class="line">FindResourceA</span><br></pre></td></tr></table></figure></li><li><p>从API接口中我们可以看出，很多接口都涉及到了多线程的问题，需要我们重点了解一下</p></li></ul><h2 id="火绒剑模拟运行"><a href="#火绒剑模拟运行" class="headerlink" title="火绒剑模拟运行"></a>火绒剑模拟运行</h2><ul><li>使用火绒剑对wannacry进行行为监控发现只有文件操作和进程操作，像注册表和网络监控就没有获取到信息</li></ul><h3 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h3><ul><li>wannacry的文件操作主要是打开文件和设置文件安全信息，并不能获取太多信息</li></ul><h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><ul><li>跟之前分析的一样，确实监测到的进程动作最多，主要有以下动作<ul><li>PROC_exec   创建进程</li><li>PROC_exec   跨进程恢复线程</li><li>PROC_open   打开进程</li><li>PROC_readvm 跨进程读内存(尤其多)</li></ul></li></ul><h2 id="感染结果观察"><a href="#感染结果观察" class="headerlink" title="感染结果观察"></a>感染结果观察</h2><ul><li>感染后除了桌面上出现一些与wannacry有关的文件外没有太多变化</li><li>运行了一个exe文件后弹出如下窗口，并更改了桌面背景图,该窗口关闭后每隔一段时间弹出一次</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191108150711.png" alt="20191108150711" title>                </div>                <div class="image-caption">20191108150711</div>            </figure><ul><li>一些软件可以正常运行，它主要感染的还是图片和文档等文件，当然一般是这些文件更值钱</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191108151027.png" alt="20191108151027" title>                </div>                <div class="image-caption">20191108151027</div>            </figure><ul><li><p>这些文件被感染成了<code>@Please_Read_Me@.txt</code>和<code>@WanaDecryptor@.exe</code>，<code>@Please_Read_Me@.txt</code>内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Q:  What&apos;s wrong with my files?</span><br><span class="line"></span><br><span class="line">A:  Ooops, your important files are encrypted. It means you will not be able to access them anymore until they are decrypted.</span><br><span class="line">    If you follow our instructions, we guarantee that you can decrypt all your files quickly and safely!</span><br><span class="line">    Let&apos;s start decrypting!</span><br><span class="line"></span><br><span class="line">Q:  What do I do?</span><br><span class="line"></span><br><span class="line">A:  First, you need to pay service fees for the decryption.</span><br><span class="line">    Please send $300 worth of bitcoin to this bitcoin address: 115p7UMMngoj1pMvkpHijcRdfJNXj6LrLn</span><br><span class="line"></span><br><span class="line">    Next, please find an application file named &quot;@WanaDecryptor@.exe&quot;. It is the decrypt software.</span><br><span class="line">    Run and follow the instructions! (You may need to disable your antivirus for a while.)</span><br><span class="line">    </span><br><span class="line">Q:  How can I trust?</span><br><span class="line"></span><br><span class="line">A:  Don&apos;t worry about decryption.</span><br><span class="line">    We will decrypt your files surely because nobody will trust us if we cheat users.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">*   If you need our assistance, send a message by clicking &lt;Contact Us&gt; on the decryptor window.</span><br></pre></td></tr></table></figure></li><li><p>按照提示恢复了部分文件，文件恢复了但是那两个文件还在</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191108151619.png" alt="20191108151619" title>                </div>                <div class="image-caption">20191108151619</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网安组wannacry分析&lt;br&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="逆向" scheme="https://liuyi12138.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="病毒" scheme="https://liuyi12138.github.io/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>熊猫烧香源码分析</title>
    <link href="https://liuyi12138.github.io/2019/11/02/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://liuyi12138.github.io/2019/11/02/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2019-11-02T03:07:23.000Z</published>
    <updated>2021-02-23T06:34:31.925Z</updated>
    
    <content type="html"><![CDATA[<p>网安组熊猫烧香病毒分析<br><a id="more"></a> </p><h2 id="整体结构分析"><a href="#整体结构分析" class="headerlink" title="整体结构分析"></a>整体结构分析</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191106163334.png" alt="20191106163334" title>                </div>                <div class="image-caption">20191106163334</div>            </figure><ul><li>根据IDA逆向出的流程图可知熊猫烧香病毒逆向后大致分为主流程以及三个调用的函数</li></ul><h3 id="主流程分析"><a href="#主流程分析" class="headerlink" title="主流程分析"></a>主流程分析</h3><ul><li>在主流程中进行了两次字符串校验来判断病毒是否正常执行</li><li>字符串校验是将两个已有的字符串进过一个函数处理后与另一个字符串比较，若相同则继续进行后续操作，不同则退出程序。作用类似于哈希校验，防止其他人篡改程序</li></ul><h3 id="三个调用函数整体分析"><a href="#三个调用函数整体分析" class="headerlink" title="三个调用函数整体分析"></a>三个调用函数整体分析</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://attach.52pojie.cn/forum/201909/16/021214z53biwoa2xb6yfy3.png" alt="https://www.52pojie.cn" title>                </div>                <div class="image-caption">https://www.52pojie.cn</div>            </figure><h2 id="主模块一源码分析"><a href="#主模块一源码分析" class="headerlink" title="主模块一源码分析"></a>主模块一源码分析</h2><p><strong>主模块一的主要任务是判断运行的软件类型，根据不同的软件类型进行不同的操作</strong></p><ul><li>软件类型分类有:<ul><li>panda.exe，熊猫烧香源文件，若运行的是此文件则将其复制到C:\Windows\system32\drivers\spcolsv.exe并开启一个新的进程运行之</li><li>spcolsv.exe，复制后的文件，若运行的是此文件则进入到主模块二</li><li>被感染的文件.在主模块二中会有感染过程的分析，若运行的是被感染的文件则删除感染标识，从感染的文件中将感染前的文件释放，命名为xxx.exe.exe，并生成bat脚本，当用户运行xxx.exe.exe则自动删除其自身和被感染文件</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107094942.png" alt="20191107094942" title>                </div>                <div class="image-caption">20191107094942</div>            </figure><h3 id="自拷贝spcolsv-exe并运行"><a href="#自拷贝spcolsv-exe并运行" class="headerlink" title="自拷贝spcolsv.exe并运行"></a>自拷贝spcolsv.exe并运行</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107095713.png" alt="20191107095713" title>                </div>                <div class="image-caption">20191107095713</div>            </figure><ul><li>如图可看出在自拷贝函数中用的最多的API是LstrCatN(字符串拼接函数)，通过动调分析可知该函数拼接了panda.exe和spcolsv.exe的绝对地址</li><li>自拷贝函数中最主要的两个API为CopyFileA和WinExec，通过这两个API可以基本确定此函数的功能为拷贝文件并新建线程运行</li></ul><h3 id="创建bat文件自删除"><a href="#创建bat文件自删除" class="headerlink" title="创建bat文件自删除"></a>创建bat文件自删除</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107105953.png" alt="20191107105953" title>                </div>                <div class="image-caption">20191107105953</div>            </figure><ul><li>该函数创建了一个bat文件并执行之</li><li>某bat文件内容如下</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107110302.png" alt="20191107110302" title>                </div>                <div class="image-caption">20191107110302</div>            </figure><ul><li>该bat将被感染的文件删除，并将被释放出的原文件改名，运行，删除。即在用户看来，被感染的文件运行一次后会自删除</li></ul><h2 id="主模块二源码分析"><a href="#主模块二源码分析" class="headerlink" title="主模块二源码分析"></a>主模块二源码分析</h2><p><strong>主模块二的主要任务是新建一个线程来感染电脑中的其他文件，并在局域网中进行传播</strong></p><ul><li>其主要流程如下：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107162028.png" alt="20191107162028" title>                </div>                <div class="image-caption">20191107162028</div>            </figure><h3 id="获取电脑正在使用的盘符"><a href="#获取电脑正在使用的盘符" class="headerlink" title="获取电脑正在使用的盘符"></a>获取电脑正在使用的盘符</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107112039.png" alt="20191107112039" title>                </div>                <div class="image-caption">20191107112039</div>            </figure><ul><li>获取到正在使用的盘符后都拼接到一个字符串中，通过获取字符串的长度来获取正在使用的盘符数量</li><li>判断盘符数量，若小于1则陷入死循环，若大于1则依次判断是否存在A盘和B盘，若存在该字符串头指针++，继续判断盘符数量，最终目的即是让字符串头指指向”C”</li><li>若C盘存在对其进行感染，其实如果电脑不存在C盘，第三个盘是其他盘该函数也会进入并感染之，不过一般windows的系统盘符一般都是C</li></ul><h3 id="遍历C盘，感染指定类型的文件"><a href="#遍历C盘，感染指定类型的文件" class="headerlink" title="遍历C盘，感染指定类型的文件"></a>遍历C盘，感染指定类型的文件</h3><p><strong>此函数中主要感染的文件类型有exe、scr、pif、com，以及htm、html、asp、php、jsp对于这两种文件的处理方式不同</strong></p><ul><li>函数感染的主题流程如下，左侧为文件感染流程，主要是对不同类型的文件有不同的处理方式，右侧为文件夹遍历流程，主要是会过滤掉一些文件夹不做感染</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107154208.png" alt="20191107154208" title>                </div>                <div class="image-caption">20191107154208</div>            </figure><h4 id="文件夹过滤"><a href="#文件夹过滤" class="headerlink" title="文件夹过滤"></a>文件夹过滤</h4><ul><li>文件夹方面处理主要是获取当前目录名称，并与需要过滤的文件夹名称进行对比，相同则结束该函数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107154547.png" alt="20191107154547" title>                </div>                <div class="image-caption">20191107154547</div>            </figure><h4 id="exe-scr-pif-com文件感染"><a href="#exe-scr-pif-com文件感染" class="headerlink" title="exe scr pif com文件感染"></a>exe scr pif com文件感染</h4><ul><li>对于这四种文件采用的是同一个函数进行感染</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107154615.png" alt="20191107154615" title>                </div>                <div class="image-caption">20191107154615</div>            </figure><ul><li>该函数主要作用是复制，将被感染问价处理为如下格式</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107154856.png" alt="20191107154856" title>                </div>                <div class="image-caption">20191107154856</div>            </figure><h4 id="htm、html、asp、php、jsp文件感染"><a href="#htm、html、asp、php、jsp文件感染" class="headerlink" title="htm、html、asp、php、jsp文件感染"></a>htm、html、asp、php、jsp文件感染</h4><ul><li>该部分主要在文件末尾追加一个网址</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107155228.png" alt="20191107155228" title>                </div>                <div class="image-caption">20191107155228</div>            </figure><h4 id="删除GHO系统备份文件"><a href="#删除GHO系统备份文件" class="headerlink" title="删除GHO系统备份文件"></a>删除GHO系统备份文件</h4><ul><li>GHO文件即为ghost的镜像文件,可通过OneKey进行还原和备份,也可直接通过光盘优化启动,进入ghost11进行一键还原</li><li>在感染函数的开头就删除了GHO系统备份文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107155554.png" alt="20191107155554" title>                </div>                <div class="image-caption">20191107155554</div>            </figure></li></ul><h4 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107160756.png" alt="20191107160756" title>                </div>                <div class="image-caption">20191107160756</div>            </figure><h3 id="设置定时器在磁盘根目录生成文件"><a href="#设置定时器在磁盘根目录生成文件" class="headerlink" title="设置定时器在磁盘根目录生成文件"></a>设置定时器在磁盘根目录生成文件</h3><ul><li>该函数主要生成setup.exe和autorun.inf两个文件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107162348.png" alt="20191107162348" title>                </div>                <div class="image-caption">20191107162348</div>            </figure><ul><li>Autorun.inf是电脑使用中比较常见的文件之一 ，其作用是允许在双击磁盘时自动运行指定的某个文件</li><li>该函数将正在运行的程序自身拷贝到setup.exe,并写入Autorun.inf使得用户双击C盘时自动运行该病毒<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107162740.png" alt="20191107162740" title>                </div>                <div class="image-caption">20191107162740</div>            </figure></li></ul><h3 id="局域网感染"><a href="#局域网感染" class="headerlink" title="局域网感染"></a>局域网感染</h3><ul><li>该函数创建线程尝试连接139和445两个端口，通过共享内存的方式来感染局域网中的其他机器</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107161157.png" alt="20191107161157" title>                </div>                <div class="image-caption">20191107161157</div>            </figure><h2 id="主模块三源码分析"><a href="#主模块三源码分析" class="headerlink" title="主模块三源码分析"></a>主模块三源码分析</h2><ul><li>主模块三创建了四个定时器，分别用来结束杀软，解密url 下载并运行，删除共享，停止并删除杀软服务</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107163119.png" alt="20191107163119" title>                </div>                <div class="image-caption">20191107163119</div>            </figure><h3 id="结束杀软"><a href="#结束杀软" class="headerlink" title="结束杀软"></a>结束杀软</h3><ul><li>该定时器主要是关闭一些杀毒软件的进程以及创建并设置注册表键值(自启动以及不显示隐藏文件)</li></ul><h4 id="关闭杀软进程"><a href="#关闭杀软进程" class="headerlink" title="关闭杀软进程"></a>关闭杀软进程</h4><ul><li>关闭杀软是通过POSTMESSAGE的方式来完成的</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107163818.png" alt="20191107163818" title>                </div>                <div class="image-caption">20191107163818</div>            </figure><ul><li>主要关闭了以下杀软</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107164040.png" alt="20191107164040" title>                </div>                <div class="image-caption">20191107164040</div>            </figure><h4 id="创建并设置注册表键值"><a href="#创建并设置注册表键值" class="headerlink" title="创建并设置注册表键值"></a>创建并设置注册表键值</h4><ul><li>主要调用的API为RegCreateKeyExA(创建注册表)和RegSetValueExA(设置键值)</li></ul><h3 id="解密url-下载并运行"><a href="#解密url-下载并运行" class="headerlink" title="解密url 下载并运行"></a>解密url 下载并运行</h3><ul><li>该定时器主要调用的API为RLDownloadToFileA(下载url)，WinExec(创建线程并运行)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107164459.png" alt="20191107164459" title>                </div>                <div class="image-caption">20191107164459</div>            </figure><h3 id="删除共享"><a href="#删除共享" class="headerlink" title="删除共享"></a>删除共享</h3><ul><li>该定时器使用了net share命令来停止C盘的共享<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107164717.png" alt="20191107164717" title>                </div>                <div class="image-caption">20191107164717</div>            </figure></li></ul><h3 id="停止并删除杀软服务"><a href="#停止并删除杀软服务" class="headerlink" title="停止并删除杀软服务"></a>停止并删除杀软服务</h3><ul><li>该定时器主要调用CloseServiceHandle和DeleteService两个API来停止并删除杀软服务<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gitee.com/know_the_emperor/picture/raw/master/pictures/20191107165432.png" alt="20191107165432" title>                </div>                <div class="image-caption">20191107165432</div>            </figure></li></ul><hr><p><strong>至此整个熊猫烧香的逆向工程已经分析完了，结合上一篇<a href="https://liuyi12138.github.io/2019/10/31/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/">熊猫烧香行为分析</a>我们大致可以了解熊猫烧香的行为以及工作原理，在后期我们可能需要想办法去防御这种病毒的攻击，逆向才刚刚入门，冲冲冲！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网安组熊猫烧香病毒分析&lt;br&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="https://liuyi12138.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="逆向" scheme="https://liuyi12138.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="病毒" scheme="https://liuyi12138.github.io/tags/%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
</feed>
